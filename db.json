{"Asset":{"873nsr6dmcdllfnj":{"source":"source/CNAME","mtime":1404104045000,"modified":true,"_id":"873nsr6dmcdllfnj","full_source":"/Users/yangbolin/Documents/myblog/source/CNAME","path":"CNAME"},"is5dk120blima4xv":{"source":"themes/modernist/source/fancybox/blank.gif","mtime":1396961050000,"modified":true,"_id":"is5dk120blima4xv","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/fancybox/blank.gif","path":"fancybox/blank.gif"},"3dknpex0wxl3su4l":{"source":"themes/modernist/source/fancybox/fancybox_loading.gif","mtime":1396961050000,"modified":true,"_id":"3dknpex0wxl3su4l","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif"},"aidlo5cge1ddrij3":{"source":"themes/modernist/source/fancybox/fancybox_overlay.png","mtime":1396961050000,"modified":true,"_id":"aidlo5cge1ddrij3","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png"},"pg22lrfqzhutunhh":{"source":"themes/modernist/source/fancybox/fancybox_sprite.png","mtime":1396961050000,"modified":true,"_id":"pg22lrfqzhutunhh","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png"},"u79qzt72moyfnmjz":{"source":"themes/modernist/source/fancybox/jquery.fancybox.css","mtime":1396961050000,"modified":true,"_id":"u79qzt72moyfnmjz","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css"},"p2su1deb9svnpnml":{"source":"themes/modernist/source/fancybox/jquery.fancybox.pack.js","mtime":1396961050000,"modified":true,"_id":"p2su1deb9svnpnml","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js"},"2bnh6g88txomrp9e":{"source":"themes/modernist/source/js/gallery.js","mtime":1396961050000,"modified":true,"_id":"2bnh6g88txomrp9e","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/js/gallery.js","path":"js/gallery.js"},"jrc27dhv63qp1s2y":{"source":"themes/modernist/source/js/jquery-1.7.2.min.js","mtime":1403005868000,"modified":true,"_id":"jrc27dhv63qp1s2y","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/js/jquery-1.7.2.min.js","path":"js/jquery-1.7.2.min.js"},"1qrlb4d9yshxnb6s":{"source":"themes/modernist/source/js/jquery.imagesloaded.min.js","mtime":1396961050000,"modified":true,"_id":"1qrlb4d9yshxnb6s","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js"},"w65h0axjwutmco1l":{"source":"themes/modernist/source/js/moment.min.js","mtime":1396961050000,"modified":true,"_id":"w65h0axjwutmco1l","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/js/moment.min.js","path":"js/moment.min.js"},"a21eao02hmf2xt8z":{"source":"themes/modernist/source/js/scale.fix.js","mtime":1396961050000,"modified":true,"_id":"a21eao02hmf2xt8z","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/js/scale.fix.js","path":"js/scale.fix.js"},"u7pyggeea9t2fgei":{"source":"themes/modernist/source/css/style.styl","mtime":1397393331000,"modified":true,"_id":"u7pyggeea9t2fgei","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/style.styl","path":"css/style.styl"},"jdkh9q3j1bgigu9n":{"source":"themes/modernist/source/css/style.styl~","mtime":1397393331000,"modified":true,"_id":"jdkh9q3j1bgigu9n","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/style.styl~","path":"css/style.styl~"},"br1j1gzpj2i8abu8":{"source":"themes/modernist/source/css/fonts/FontAwesome.otf","mtime":1396961050000,"modified":true,"_id":"br1j1gzpj2i8abu8","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf"},"dq9yia81ajmr9yek":{"source":"themes/modernist/source/css/fonts/fontawesome-webfont.eot","mtime":1396961050000,"modified":true,"_id":"dq9yia81ajmr9yek","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot"},"xbyzi31aez06armv":{"source":"themes/modernist/source/css/fonts/fontawesome-webfont.svg","mtime":1396961050000,"modified":true,"_id":"xbyzi31aez06armv","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg"},"xirxhuwd0b7n3f6o":{"source":"themes/modernist/source/css/fonts/fontawesome-webfont.ttf","mtime":1396961050000,"modified":true,"_id":"xirxhuwd0b7n3f6o","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf"},"6m26vro9bnm81225":{"source":"themes/modernist/source/css/fonts/fontawesome-webfont.woff","mtime":1396961050000,"modified":true,"_id":"6m26vro9bnm81225","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff"},"947w4vv8pz57tmmn":{"source":"themes/modernist/source/css/images/checker.png","mtime":1396961050000,"modified":true,"_id":"947w4vv8pz57tmmn","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/images/checker.png","path":"css/images/checker.png"},"z0uw0bo5mw001sd1":{"source":"themes/modernist/source/css/images/icons.gif","mtime":1397438502000,"modified":true,"_id":"z0uw0bo5mw001sd1","full_source":"/Users/yangbolin/Documents/myblog/themes/modernist/source/css/images/icons.gif","path":"css/images/icons.gif"}},"Cache":{"auszh8vib5y4fx41":{"content":"title: 2014.04.25 Qcon北京第一天总结\ndate: 2014-04-25 22:46:14\ntags: Qcon\ncategories: 技术交流\n---\n\n####一.概述\n今天是2014北京Qcon第一天，也是自己第一次来北京，上午先去北京国际会议中心签到，领入场证和餐券，一进场就有人问我们要名片，感觉很多公司的人借此机会来挖其他公司里面的人。上午大家一起参加开场致词，接下来是三位国际友人的分享，上午的会议都是大家一起开的，下午我有选择性的听了四场会议，第一场是讲企业个人成长的，其余三场都是讲互联网架构的。\n\n<!-- more -->\n\n####二.InfoQ的CEO开场致词\nInfoQ的CEO做了开场致词，他的致词都是在宣传InfoQ的作用以及InfoQ的用户分析，最后还感谢了一下本次Qcon的赞助商，之前没怎么逛过InfoQ，看来后面需要抽时间去逛逛InfoQ了，目前InfoQ上大多数文章都是翻译过来的，CEO有提到要增加原创的文章数目，争取做到原创文章和翻译文章的比例是1:1，从他的发言中感觉到InfoQ上的文章质量还是很高的。\n###三.亚马逊NoSql数据产品的介绍\n一个亚马逊的工程师介绍了一下他们自己研发的NoSql数据库产品，首先他阐述的关系型数据库的优缺点，比如关系型数据库能进行很容易的查询操作，多表的JOIN操作，但是当数据量很大的时候，关系型数据库的分区操作比较困难，同时关系型数据库不具备纵向扩展的功能，于是他们自己研发了dynamo，dynamo是一个library不是一个service,dynamo缺乏数据的强一致性，学习曲线比较陡峭，继而产生了dynamoDB这种NoSql数据产品，数据写三份，冗余存储，数据之间互为备份。\n###四.大型前端应用的组件与模块\n一个英国人宣传了一下他们自己的一个前端组件，名称是origami，他们自己定义了一些前端的标准，基于这些标准，他们提供了丰富的前端组件，这样使用方只要在页面上引入相关的CSS/JS就可以直接使用相关的组件了。他讲到我们在构建小型的模块化组件，一个组件不要做太多事情，同时为别人做的事情要让别人用起来很方便。\n###五.大规模脑计算\n一个国外的神经学科学家讲述了他们研究神经元的手段，由于数据量很大，每次实验都有T级别的数据，这些数据的计算他们采用spark这个开源的东西来做，spark是用来做在线大规模数据计算的，关于spark我也不太了解，这个老外讲的神经元相关的东西我听的不是很懂。\n###六.高效能人才成长\n大会日程上说是高效能人才成长，我理解成个人成长，结果人家讲的是团队管理相关的东西，我不太care，就临时写了笔记，基本上都是从讲师的ppt抄下来的。\n\n* 高效能的理解\n1.高价值产出，持续创新\n2.团队高效率高质量\n3.持续能力成长\n\n* 成功的关键\n1.原则的力量\n2.组织的力量\n3.体系的力量\n\n* 管理的核心\n1.创新管理\n2.项目管理\n3.人才成长\n\n* 人才管理导向原则\n1.人员招聘导向\n    高级:内部成长，空降\n    中级:内部成长\n    初级:校招\n2.人才成长导向\n    合格上岗\n    学习型组织\n3.人才激励导向\n    高级：期权\n    终极：决策参与\n    初级：学习成长，员工福利\n4.人才绩效导向\n    战略导向\n    客户全面评价员工产出\n    绩效\n\n这个我不太care，所以就不做过多的评论和分析。\n###七.汽车之家论坛架构分析\nInfoQ请来了汽车之家的一位架构师来分享汽车之家论坛的架构，汽车之家也是一家比较有名的互联网公司，目前已经成功上市。这位架构师描述了汽车之家的三板斧：\n\n* 快\n对于浏览器的请求能够快速处理，就是说服务端的数据返回速度一定要有足够快的速度。\n* 稳\n稳指的就是稳定性，他们的目标是4个9或者3个9的稳定性，其实在互联网产品中工程师喜欢优化产品的性能，因为这个更能锻炼工程师，但是稳定性要比快重要一些，因此保持网张的稳定性很重要，这个关系到用户的切身利益。\n* 爱\n他们的目标是做一个用户喜爱的网站，这个在互联网产品中很重要，要是用户不喜欢，或者用户讨厌，那么这个产品估计离淘汰就不远了。\n\n汽车之家的架构师也提到了做一个论坛的三和核心东西：\n\n* 列表\n他们使用Redis排序列表实现分页，并且能够在O(1)的时间内找到某一个帖子，直接根据数组下标获取数组元素。\n* 帖子\nNigix Cache缓存帖子，使用MQ清楚缓存。\n* 发帖传图\n分布式上传图片\n\n另外这位架构师还提到了他们的日志分析，使用AOP做到方法级别的日志，然后使用storm来实时分析日志，使用spark来分析历史数据，感觉这个日志系统的架构还是比较NB的，不过不知道AOP拦截方法打日志对系统性能的影响有多大。\n\n最后，他也提到他们的推荐做的不好，其实论坛上的推荐功能还是很重要的，这貌似是每个网站所必须具有的一项功能，按照用户的行为和喜好推荐相关的内容，这样用户会爱上你的网站。\n###八.聚石塔介绍\n其实不太想去听聚石塔的，之前就听过聚石塔，也看过相关的文章，但是主讲的人是陈皓，酷壳的博主，很有名的一个人，仰慕大师风范所以去听，不过听的人很多，会场都是爆满。聚石塔是淘宝天猫对接外部商家IT系统的平台，目前被打造成一个云平台，为商家提供云服务，他把万网从聚石塔中剥离出去，让聚石塔只和阿里云打交道，同时优化了一些阿里云的系统，陈皓对阿里云的同学评价很高的。由于商家的IT服务性能很差，他们就对第三方应用做性能测试，发现很多问题都是因为数据库没有建立索引导致，可能小卖家不太会注意这个事情，因为他们的量小，没有必要给数据库字段建立索引，但是双11的时候订单量一旦上去，要是数据库没有建立索引，对卖家来说就是很大的损失了。\n\n做平台的时候需要先制定标准，无标准不平台。\n开发人员说明天或者后续会做的事情等于永远不会去做，其实他的意思是事情要一次性做到极致，不要托泥带水，这个我比较认同，追求卓越。\n这次他也强调了系统监控和运维的重要性，这可以保证系统的稳定性，不会导致系统挂掉很长时间。\n国内开发和运维分开搞，开发不知运维是怎么搞的，运维不知开发是怎么搞的。国外系统的开发和运维都由写代码的人搞定，运维工程师负责开发一些工具帮助写代码的人搞运维。\n很多人喜欢使用数据库来搞状态机器。\n给数据不如给功能来的安全，给用户提供相关数据的同时思考一下他们用这些数据来做什么事情。\n关于服务的监控，目前有两种方式，一是服务自己主动上报自己的状态，二是探测服务的状态，因为服务自己挂了，它就没法上报自己的状态了。\n\n###九.京东大规模内存存储平台\n京东中间件负责人介绍了他们最新研发的内存存储平台，基于Redis的改造，这个感觉和阿里巴巴的tair有点相似。他们利用RAM和SSD做存储介质，存储引擎也基于B+Tree构建，其实和mysql的索引树是一样的结构，在内存中维护一颗B+Tree，同时他们把热数据一直留在内存，SSD存储全量数据。\n\n感觉他们的难点在于存储的扩容，他们的扩容分为纵向扩容和横向扩容，横向扩容是增加分片的数目，纵向扩容是增加分片的容量，扩容就要考虑数据的一致性，他们使用一个proxy来控制扩容时数据的读写，但是感觉他们在讲如何保持数据一致性方面没讲清楚，他们号称扩容过程中不会丢任何数据，不知tair是如何保持数据一致性的，等回去后和tair那边沟通一下他们是如何做到扩容时不丢数据的，了解一下实现思路。另外他们给人传达的一个思想就是他们产品的诞生是为了满足业务需求，不是自己凭空构建出来的一个东西，这个确实，大家都喜欢玩技术，并且产出一些有用的东西来，这些东西不是凭空产生，要学会去把实际的业务场景进行抽象，用最终抽象出来的东西去解决某一类问题。\n\n之前一直觉得JD没啥技术含量，不过今天算是见识了，他们能对Redis结合自己的业务场景不断定制，优化，同时还引入分布式选举的思想，paxo算法，很佩服这种自主研发的精神。\n","mtime":1399632929000,"source":"source/_posts/2014-qcon-first.md","_id":"auszh8vib5y4fx41"},"9peunucp4zal2lqn":{"content":"title: 2014.04.27 Qcon北京第三天总结\ndate: 2014-04-30 11:03:53\ntags: Qcon\ncategories: 技术交流\n---\n\n####一.概述\n2014Qcon北京第三天我主要关注了一个主题，尖端之上的Java,分享者主要讲了一些自己公司中如何使用Java开进行日常开发，这个主题也比较火。下午关于文化科研相关的演讲，我没怎么仔细听。\n\n<!-- more -->\n\n####二.你应该更新的Java知识\n\n这位分享者已经有10年的开发经验了，他的博客也很有名[dreamhead](http://dreamhead.blogbus.com/),有空可以去翻翻。\n\n10多年来，软件的开发方式没有发生本质上的改变。\nRails 约定胜于配置。\n多核和函数式编程，MapReduce的思想来自函数式编程。\n每年都去学一门新的语言。\n\n* clean code\n整洁代码，函数越短越好，写代码不要太随便，不是说满足需求，实现功能就行，要能优雅的满足需求，实现功能。\n重构，rework,有时间读读这本书，[rework](http://book.douban.com/subject/3889178/)\n自定义注解，使用annotation来简化代码\n\n* 函数式编程\n懒加载\n* DSL\n领域特定语言，可以看看相关的书籍\n设计并实现自己的DSL\n* 新风格程序库\nGuava \nJoda-Time \nHamcrest \nMockito \nDropWizard \nJunit \nDSL\neasyMock\nJMock\n\n把getter/setter改造成更加良好的DSL\n有时间去看看Scala\n\n####三.API单位误解造成严重的故障\n\n在socket编程中有一个setLiner方法，我记不清是那个类的了，单位值是秒，但是被开发误以为是毫秒，导致了一个线上故障，出现线上故障的时候注意保留现场，方便后续问题的排查。\n\ntomcat和jetty都有线程池大小，每个应用都会配置一个活跃线程数。\n\n线程dump jstack\n内存dump jmap 使用MAT分析\n\n-XX:+PrintFlagsFinal 输出所有参数的名称和默认值,也可以使用jinfo -flags来查看值，使用jinfo -flag来设置值。\n-XX:+TraceClassLoading 跟踪类加载信息。\n\n应用无响应的排查思路，先看一下应用在干什么，使用jstack\njstack -l 打印锁状况\njstack -m 把native的堆栈也打印出来\n\nstatic代码块初始化的时候，会在类上加上一把锁。\n\n内存相关\n-XX:+HeapDumpOnOutOfMemory JVM在OutOfMemory的时候，会拍摄一个堆转储快照，同时转存到一个文件中。\n线上应用可以带上输出GC日志的JVM参数-XX:+PrintGC，对应用本身不会有太大的影响。\n\njmap -histo:live 查看JVM中存活的实例。\njmap -dump:file dump JVM的内存。\ndump出来的内存文件大小和堆大小差不多大，内存太大会导致内存的dump很耗时。\n\ngcore 命令\ngenerates a core file for the process specified by its process ID, pid. By default, the core file is written to core.pid, in the current directory。\n可以使用 gcore pid 来获取一个进程的core文件。\n\n使用MAT分析dump下来的内存的时候，没法定位到具体的代码，这时候可以结合BTrace来使用。\n\n[gperftools](http://www.cnblogs.com/caosiyang/archive/2013/01/25/2876244.html)\n\nulimit\ncat /proc/pid/limits\n这里的pid是进程ID\n\nCPU利用率\ntop -H && jstack\n1.使用top命令查看占用cpu最高的线程ID\n2.把线程ID转换成十六进制\n3.在jstack出来的内从找线程ID相关的线程，看看线程在做什么事情。\n\n注意:\ntop和jstack之间有时间的误差，就是说我们使用top看到的线程可能在jstack dump出来的线程堆栈的找不到。\n\nJava进程退出\n1. 打开core dump文件看看\n2. 使用gdb调试\n3. 使用dmesg | grep -i kill 看看是不是os把java进程kill掉\n\n####四.去哪儿网的java开发生态环境\n* 发布相关\n有相同的类，就不允许发布，解决依赖冲突的问题。\n\n* 架构相关\n在实际的业务逻辑处理中，有时候我们做完一些业务上的操作后，需要发消息给其他模块或系统，在一些高要求的系统中，我们需要保证业务操作和发消息的事务，为了达到这么目的，在数据库中建立一张消息表，发消息的时候往数据库中插入一条记录，这样往消息表中插入数据的操作和业务表的操作在数据库层面形成事务，最后又有一个后台线程，不断去扫描消息表，然后把消息发送出去。\n\n为了保证消息和业务逻辑之间的事务，他们借助一张消息表来实现，每次发消息都先往消息表中写一条记录，我个人感觉先尝试去发消息，要是消息发送失败再往消息表中写一条记录，然后使用一个后台线程去轮寻消息表，把这些发送失败的消息再发送出去，不太理解他们为什么每次发消息都往消息表中插入一条记录。\n\n* mock平台\n很多网站架构中都有mock平台这一部分，这样可以方便测试环境覆盖更多的业务逻辑分支。\n* 自动化测试\n产品经理要会写测试用例，这是他们的要求，在他们看来产品经理必须对产品的边边角角都有一个非常清晰的理解，他们通过这样的方法来保证这个点。\n* codeReview\n去哪儿网还是比较重视CodeReview的\n* 监控体系\n\n####五.大众点评零压力中间件部署\n大众点评需要解决的问题是降低中间件升级的成本，中间件的升级不需要应用方来修改相关的配置或者代码，由中间件团队自己在生产环境部署升级，实现平台也业务的分离。\n\n每次中间件的升级，中间件团队把新版本的中间件推送到线上，然后重新部署线上的应用，就可以完成中间件的升级，这时候新版本和老版本的中间件都会存储在线上应用中，他们提供一个规则的配置文件，应用会根据规则的配置文件来决定使用中间件的那个版本。\n\n技术点：\n重写tomcat的WebXmlLoader和WebApplicationLoader\n\n其实这种升级中间件的思路很好，但是他们做的不彻底。比如说今天要升级中间件A了，中间件团队在测试环境找QA测试好之后，便自己直接去线上部署，并且线上运行没啥问题，但是线上应用pom依赖中中间件的版本还是老版本，这个老版本还是需要相应应用的开发自己去改，在他们看来只要应用中依赖的版本不要过低，都没啥问题的。\n\n####六.搜狗商业广告平台java生态演化之路\n\n这个讲的有点虚，没啥实质性的内容，什么sso啥的都是一笔带过。他们也利用了Thrift，关于Thrift和Restful我不太了解。最后还提到了他们利用Zookeeper的推送机制来实现数据的推送,Zookeeper数据节点发生变化的时候，它会发起相关的通知。\n","mtime":1398952342000,"source":"source/_posts/2014-qcon-third.md","_id":"9peunucp4zal2lqn"},"n3laacuff42eszge":{"content":"title: 一个在方法返回前使用AOP的BUG分析\ndate: 2014-05-03 14:40:00\ntags: [JAVA,Spring]\ncategories: 编程开发\n---\n\n####源代码\n最近使用AOP拦截一个方法的返回值，并且修改一下方法的返回值，然后再返回，于是写了下面的代码：\n\n<!-- more -->\n\n![源代码](http://bolinyoung.qiniudn.com/aop-error.png)\n\n从上图可以看出这是一个AOP的切面，在getData方法返回前对returnValue做相关的修改，然后再返回。\n\n我们在写JAVA代码的时候经常会考虑NPE，我们发现这里也对returnValue考虑了NPE，看看红色框内代码，如果returnValue==null，就重新创建一个returnValue，其实问题就是出现在这里，我们在切面中把returnValue的指向修改了，这个修改只在afterReturning方法内部有效，出了这个方法后，这个修改就无效了，因为在afterReturning方法内部保存了一份returnValue的引用值拷贝，修改这份引用值的拷贝，方法外不会感知到，通过这份应用值拷贝去修改其指向内存空间的值，方法外能感知到内存值的修改。因此上述红色框内的代码是无效的，要是returnValue本身为null，执行完afterReturning方法后依旧是null。\n\n关于函数参数传递的分析，参考之前的一片文章[Java 函数参数引用思考](http://yangbolin.github.io/myblog/2014/04/08/java-parameter-reference/)\n","mtime":1399100216000,"source":"source/_posts/after-returning-advice-error.md","_id":"n3laacuff42eszge"},"gwyrtw77vrrgrl6s":{"content":"title: 一次JVM分享的相关记录\ndate: 2014-08-16 15:44:15\ntags: JVM\ncategories: JVM学习\n---\n\n####一.概述\n最近看见公司一位前辈有分享JVM相关的知识，自己特地从跑过去听了一下，感觉讲的不是很深入，但是相对来说还是不错的，本文就自己听到的一些东西做一个简单的总结。平时我们大多数都是用JAVA写代码,很多人学JAVA都是从HelloWorld开始，但是从你写HelloWorld代码到最终输出HelloWorld到底发生那些事情呢？要想清楚的回答这个问题，并不是很容易，你需要对JVM有一个清晰的了解后，才能说清楚这个问题，这只是一个引子，本文也不去挑战这个问题，这里主要记录一下自己从这个分享中听到的一些感兴趣的东西。\n\n<!-- more -->\n\n####二.JVM运行时数据区\n![JVM运行时数据区](http://bolinyoung.qiniudn.com/jvmdataarea.png)\n\nJVM运行时数据区域分为堆内存和非堆内存。注意这里的程序计数器，和CPU没有关系，不要看见Register就认为是CPU的寄存器，每个方法都会由一系列的字节码组成，这里的PC指向的是当前要执行的字节码，执行完字节码后，PC就会向前移动。\n\n####三.类初始化\n在JAVA代码中，我们经常写class，JVM加载一个类的时候，先会初始化一个类实例，这个初始化好的类实例存储在perm区中，注意这个类实例不是我们在代码中new出来的对象实例，我们在代码中new出来的对象实例是存储在堆内存中的，也就是说new一个对象的实例和类实例是存储在不同地方的。\n\n![类初始化的过程](http://bolinyoung.qiniudn.com/classinitprocess.png)\n\n类初始化的过程总体上分为Load,Link,Initialize三个阶段，当代码中需要某个类的时候，JVM先会在classpath中尝试去找，如果找不到相应的类，此时会抛出ClassNotFoundException，如果能找到相应的类，就会看这类是否有使用其他的类，有的话，又会去加载当前类依赖的类，接下来会做Link，其实和C/C++编译时的Link是一样的，把当前类所需要的其他类放在一起，看看会不会有问题，Link分为三个阶段，字节码校验，当然这个校验可以通过JVM参数去掉，即verify，prepare阶段会对类的静态成员变量做初始化，比如int会被初始化为0,引用类型会被初始化为null，resolve阶段就是看看当前类所依赖的其他类有没有问题，比如classA依赖classB，在classA中使用classB中的方法f，此时会校验classB中方法f是否存在。最后就是Initialize了，这里的Initialize其实就是执行clinit方法。\n\n注意Link中的Prepare阶段会对类静态成员初始化，我们new一个实例的时候，类的非静态成员变量也有类似初始化的过程，但是这两个初始化不是发生在同一个阶段，new的时候会在堆内存上分配内存空间，此时也会对非静态成员变量做初始化。\n\n下面我们来分析一段代码\n```java\npublic class StaticCode {\n\n    static {\n        a = 1;\n    }\n\n    private static int  a = 0;\n\t\n    public static void main(String[] args) {\n        System.out.println(StaticCode.a);\n    }\n}\n```\n这段代码的输出结果是什么？\n首先考虑这段代码会不会有编译的问题，提前使用了静态成员变量a。自己编译一下就知道了，这段代码不会有编译的问题。输出结果是0。自己运行一下就知道了。但是为啥结果是0呢？我们来分析一下字节码，看看为啥结果是0\n使用javap -verbose来查看字节码，注意字节码中静态代码块\n![StaticCode中的静态代码块](http://bolinyoung.qiniudn.com/staticcode-0.png)\n其实这个静态代码块对应的方法就是clinit方法。这个方法中有5条字节码指令，偏移量0和1处的字节码表示获取常量1并且赋值给静态成员变量i,这两个字节码指令从哪里来的呢？就是声明静态代码块中对静态成员变量a的赋值操作。偏移量4和5处的字节码表示声明静态成员变量a时的赋值操作，此时这个赋值操作排在静态代码块中赋值操作的后面，因此输出结果为0。\n\n对于上述代码块，如果我们把static代码块的顺序静态成员变量声明的顺序改变一下\n```java\npublic class StaticCode {\n\n\tprivate static int  a = 0;\n\t\n    static {\n        a = 1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(StaticCode.a);\n    }\n}\n```\n此时输出结果为1,因为静态成员变量的声明排在静态代码块的前面，此时静态成员变量声明时的赋值字节码会出现静态代码块中赋值字节码的后面，再看看相关的字节码就能发现\n![改变顺序后的字节码](http://bolinyoung.qiniudn.com/staticcode-0-latter.png)\n\n关于静态代码块中的字节码和静态成员变量赋值的字节码谁先执行谁后执行，取决于java代码中静态成员变量和静态代码块出现的先后顺序。\n\n再看一个对象实例化的例子\n```java\npublic class Base {\n\tprivate int i = 12;\n\tpublic Base() {\n\t\tfoo();\n\t}\n\t\n\tpublic void foo() {\n\t\tSystem.out.println(i);\n\t}\n}\npublic class Child extends Base {\n\tprivate int i = 13;\n\t\n\tpublic Child() {\n\t}\n\t\n\tpublic void foo() {\n\t\tSystem.out.println(i);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Child();\n\t}\n}\n```\n这段代码很简单，在基类构造函数中调用foo方法，这个方法被派生类重写了，此时输出结果为多少？\n运行发现此时输出结果为0,首先我们new Child()后在基类构造函数中调用的foo方法一定是在派生类中重写过的foo方法，因为当前实例对象是派生类类型的，初始化实例的时候都是先初始化父类，再初始化子类，这是关键，初始化父类的时候子类还没有初始化好，但是调用子类的foo方法，此时i的值是在分配内存空间时初始化的值，int类型的被初始化为0,因此输出结果为0。我们再来分析一下Child类构造函数的字节码。\n![Child类构造函数字节码](http://bolinyoung.qiniudn.com/ChildByteCode.png)\nJVM调用每个方法的时候都会给这个方法创建一个方法栈帧，每个方法栈帧都包含一个局部变量表，一个操作数栈，当然还有其他的比如堆栈映射表。局部变量表其实就是一个数组，实例方法中局部变量表的第一元素表示当前实例this，我们看看Child构造函数的字节码发现第一条就是aload\\_0，表示把局部变量表的第0个元素放到栈顶，也就是this引用放到栈的顶部，然后执行invokespecial，即调用父类的构造函数，调用结束后，栈顶的this引用会被弹出，因此需要继续给栈顶压一个this引用，因为后面要对成员变量i赋值，执行aload\\_0后就能把this引用再次压入到栈顶部，bipush 13标识把13转换成int型的值，然后压入到栈的顶部，putfield表示弹出栈顶的整型值，赋值给成员变量i，此时栈顶部就是this引用了，this引用也会被弹出，因为赋值的时候需要知道变量i是哪个实例的成员变量。分析完这段字节码后，输出结果为0也就很好解释了。因为调用基类构造函数时，派生类成员变量i的赋值还没有进行。\n\nJVM有一个限制，不允许多个线程去初始化同一个类，当一个线程初始化ClassA的时候，另外一个线程要是也来初始化ClassA的话，此时只能等待，等迁移个线程初始化完后后一个线程直接返回。下面这例子就是来证明这个结论\n```java\nclass Lock {}\n\nclass Danger {\n  static {\n    System.out.println(\"clinit begin...\");\n    try {\n    \tThread.sleep(2000);\n    } catch (Exception e) {\n    \tSystem.out.println(e);\n    }\n    synchronized (Lock.class) \n    { \n    \tSystem.out.println(\"clinit done!\");\n    }\n  }\n}\n\npublic class Test {\n  public static void main(String[] args) {\n  \t// 创建一个线程,此处标记为Thread1，方便下面好描述\n    new Thread() {\n      public void run() {\n        synchronized (Lock.class) {\n          System.out.println(\"new thread start!\");\n          try {\n          \tThread.sleep(1000);\n          } catch (Exception e) {\n          \tSystem.out.println(e);\n          }\n          new Danger();\n        }\n        System.out.println(\"new thread end!\");\n      }\n    }.start();\n    try {\n    \tThread.sleep(500);\n    } catch (Exception e) {\n    \tSystem.out.println(e);\n    }\n    \n    System.out.println(new Danger());\n    System.out.println(\"DONE!\");\n  }\n}\n```\n\n上述代码运行就会死锁。\n现在我们来分析为什么会死锁，线程Thread1先执行获取到Lock.class上的锁，然后sleep等待1000ms,此时Main线程sleep等待500ms，Main线程睡醒后，开始创建Danager实例，然后在创建Dananger实例时执行Danager类实例初始化的代码，在类初始化的代码中sleep等待2000ms,在这个过程中Thread1睡醒了，然后也去创建Danger实例，当然也需要执行类实例初始化的代码了，但是Main线程正在执行Danger类实例的初始化，因此Thread1只能等待，等Main线程睡醒了，但是需要等Thread1释放Lock.class上的锁才能完成Danger类实例初始化，此时Thread1等Main线程初始化完Danger类，Main线程等Thread1释放Lock.class上的锁，因此Thread1和Main互等，形成死锁，死锁的本质原因就是JVM不允许多个线程同时初始化一个类实例。\n\n同事F说这段代码写的太复杂了，不太好理解，的确，然后F给出了一个更简单的例子证明JVM不允许多个线程同时初始化一个类实例。\n```java\npublic class ShutDownDeadLock {\n\n    public static final Object referObject = new Object();\n    static {\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n\n            @Override\n            public void run() {\n                if (referObject == null)\n                ;\n            }\n\n        });\n        System.exit(0);\n    }\n\n    public static void main(String[] args) {\n\n    }\n}\n```\n上述代码会导致JVM没法退出，static代码块中在类初始化的时候会执行，System.exit(0);会导致JVM退出，但是有一个JVM退出时回调的钩子线程，这个线程会访问ShutDownDeadLock的静态成员变量referObject，但是此时ShutDownDeadLock类实例不允许其他线程使用，因为当前类实例正在被初始化，被JVM加锁了。\n\n上面的代码做如下修改就能正常退出了\n```java\npublic class ShutDownUnDeadLock {\n    public static final Object referObject = new Object();\n    \n    static {\n        final Object oo = referObject;\n        \n        Runtime.getRuntime().addShutdownHook(new Thread() {\n\n            @Override\n            public void run() {\n                if (oo == null)\n                ;\n            }\n\n        });\n        System.exit(0);\n    }\n    \n\n    public static void main(String[] args) {\n\n    }\n}\n```\n此时JVM能够正常退出，因此线此时访问oo时不需要通过ShutDownUnDeadLock类实例来访问，直接从方法栈帧的局部变量表中读取，也就是说直接从栈上读取。\n\n我们经常在代码中定义常量\n```java\npublic class IQuantConstant {\n\tpublic static final int IQUANT_PAGE_SIZE = 30;\n}\n```\n```java\npublic class IQuantConstantTest {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(IQuantConstant.IQUANT_PAGE_SIZE);\n\t}\n}\n```\n如果IQuantConstant和IQuantConstantTest在不同的JAR包中，此时修改了IQuantConstant中常量IQUANT_PAGE_SIZE的值后，另外一个JAR包感知不到，这个是编译器做的优化，编译的时候直接把IQUANT_PAGE_SIZE的值拷贝过去。\n\nTLAB是指thread local allocation buffers，用来避免线程竞争同步的开销。\n\n一个class能被卸载的前提是加载这个class的classloader加载的所有类都能被卸载，这个在使用groovy脚本时要注意，容易引起classloader的泄漏，导致perm区OOM。perm区的gc就能卸载满足条件的class。\n\n####三.GC相关\n![CMS](http://bolinyoung.qiniudn.com/cmsgc.png)\n使用CMS垃圾回收的时候，会有两次stop-the-world,因此使用jstat -gcutil查看FGC次数时，发现每次FGC都是增加2。\n\n新生代分为eden区，s0和s1,之所以有s0和s1两个对等的区，是因为MinorGC采用的是拷贝复制的算法进行垃圾回收，MinorGC会把存活的对象从s0拷贝到s1，或者从s1拷贝到s0。\n\nGC算法\n标记-清除，该算法先去标记可回收的对象，然后再一个个回收调，容易产生内存碎片。\n\n复制，该算法把内存划分为两个对等的区域，把存活的对象直接从一个区域拷贝到另外一个区域。\n\n标记-整理，先标记出需要可回收的对象，然后对不可回收的对象进行移动，让不可回收的对象集中在内存的一端。","mtime":1410234410000,"source":"source/_posts/a-jvm-share.md","_id":"gwyrtw77vrrgrl6s"},"r058higp1zp8p5a6":{"content":"title: akka如何和Spring集成起来\ndate: 2014-11-17 22:08:04\ntags: Akka\ncategories:\n---\n\n####一.概述\n最近又重新学习了一下akka，并且在一个web应用中成功使用了akka提升了系统的性能。我们在web应用中一般都会有dao&&service，这些都是spring的bean，我们定义一个actor，这个actor中可能调用dao读写数据库，也可能调用service做业务逻辑，因此我们就希望actor也是从spring容器中获取到的，这样就可以在actor中注入service&&dao了。\n\n<!--more-->\n\n####二.如何从Spring容器中获取actor\n1.用于从Spring容器中获取actor\n```java\npublic class SpringActorProducer implements IndirectActorProducer {\n\n    final ApplicationContext applicationContext;\n    final String             actorBeanName;\n\n    public SpringActorProducer(ApplicationContext applicationContext, String actorBeanName){\n        this.applicationContext = applicationContext;\n        this.actorBeanName = actorBeanName;\n    }\n\n    @Override\n    public Actor produce() {\n        return (Actor) applicationContext.getBean(actorBeanName);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Class<? extends Actor> actorClass() {\n        return (Class<? extends Actor>) applicationContext.getType(actorBeanName);\n    }\n}\n```\n\n2.扩展actor的创建\n```java\npublic class SpringExtension extends AbstractExtensionId<SpringExtension.SpringExt> {\n\n    /**\n     * The identifier used to access the SpringExtension.\n     */\n    public static SpringExtension SpringExtProvider = new SpringExtension();\n\n    /**\n     * Is used by Akka to instantiate the Extension identified by this ExtensionId, internal use only.\n     */\n    @Override\n    public SpringExt createExtension(ExtendedActorSystem system) {\n        return new SpringExt();\n    }\n\n    /**\n     * The Extension implementation.\n     */\n    public static class SpringExt implements Extension {\n\n        private volatile ApplicationContext applicationContext;\n\n        /**\n         * Used to initialize the Spring application context for the extension.\n         * \n         * @param applicationContext\n         */\n        public void initialize(ApplicationContext applicationContext) {\n            this.applicationContext = applicationContext;\n        }\n\n        /**\n         * Create a Props for the specified actorBeanName using the SpringActorProducer class.\n         * \n         * @param actorBeanName The name of the actor bean to create Props for\n         * @return a Props that will create the named actor bean using Spring\n         */\n        public Props props(String actorBeanName) {\n            return Props.create(SpringActorProducer.class, applicationContext, actorBeanName);\n        }\n    }\n}\n```\n\n3.示例actor以及actor依赖的service\n```java\npublic class CountingService {\n  /**\n   * Increment the given number by one.\n   */\n  public int increment(int count) {\n    return count + 1;\n  }\n}\nclass CountingActor extends UntypedActor {\n\n    public static class Count {}\n    public static class Get {}\n\n    // the service that will be automatically injected\n    private CountingService countingService;\n\n    private int count = 0;\n\n    @Override\n    public void onReceive(Object message) throws Exception {\n        System.out.println(countingService);\n        if (message instanceof Count) {\n            count = countingService.increment(count);\n        } else if (message instanceof Get) {\n            getSender().tell(count, getSelf());\n        } else {\n            unhandled(message);\n        }\n    }\n\n    public void setCountingService(CountingService countingService) {\n        this.countingService = countingService;\n    }\n    \n    public CountingActor() {\n        System.out.println(\"CountingActor is Creating...\");\n    }\n}\n```\nCountingActor依赖了CountingService，CountingService到时候会被注入到CountingActor中。\n\n4.配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t\thttp://www.springframework.org/schema/beans/spring-beans-2.0.xsd\"\n\tdefault-autowire=\"byName\">\n\n\t<bean id=\"countingService\" class=\"com.bolin.young.akka.spring.CountingService\" />\n\t<bean id=\"countingActor\" class=\"com.bolin.young.akka.spring.CountingActor\"  scope=\"prototype\" />\n\n\t<bean id=\"myActorSystem\" class=\"akka.actor.ActorSystem\"\n\t\tfactory-method=\"create\" destroy-method=\"shutdown\" scope=\"singleton\">\n\t\t<constructor-arg value=\"mySpringAkkaSystem\" />\n\t</bean>\n\t\n</beans>\n```\n\n5.如何使用\n```java\n// create a spring context and scan the classes\n    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n\n    ActorSystem myActorSystem = (ActorSystem)ctx.getBean(\"myActorSystem\");\n    \n    System.out.println(myActorSystem);\n    \n    SpringExtProvider.get(myActorSystem).initialize(ctx);\n    \n    final ActorRef myActor = myActorSystem.actorOf(\n                   SpringExtProvider.get(myActorSystem).props(\"countingActor\"), \"countingActor\");\n```\n\n####三.最后总结\n1.一般actorA发消息给actorB，actorB返回消息给actorA。我们可以自己在代码中发消息给actorA，然后坐等actorA的返回，如下面的代码\n```java\nBootstrapAnalyzeMsg bootstrapAnalyzeMsg = new BootstrapAnalyzeMsg();\nbootstrapAnalyzeMsg.setFileItem(treeFile);\n\nTimeout timeout = new Timeout(Duration.create(TIME_OUT, \"seconds\"));\nFuture<Object> future = Patterns.ask(bootstrapAnalyzeActor, bootstrapAnalyzeMsg, timeout);\n\ntry {\n     // 当前线程会阻塞，直到有当前的Actor有消息过来。\n     ProjectAnalyzeResultMsg projectAnalyzeResultMsg = (ProjectAnalyzeResultMsg) Await.result(future,                                            timeout.duration());\n     return projectAnalyzeResultMsg.getJarConflictInfoList();\n} catch (Exception e) {\n     e.printStackTrace();\n} finally {\n     bootstrapAnalyzeActor.tell(new ActorStopMsg(), null);\n}\n```\n该思想类似于java的Future。\n2.actor也可以终止自己,没用的actor尽量提前终止。\n```java\ngetContext().stop(getSelf());\n```\n3.actor在系统中的名字必须唯一。\n\n4.自己动手写了一个完整的小例子 https://github.com/yangbolin/akka-demo","mtime":1448006800000,"source":"source/_posts/akka-spring.md","_id":"r058higp1zp8p5a6"},"2k6ewpypl3ei6tql":{"content":"title: Akka入门\ndate: 2014-10-25 22:35:44\ntags: Akka\ncategories: 并发技术\n---\n#### 一.概述\n为了提高一个数据计算平台的吞吐了，最近抽空看了看akka，之前听同事说akka能够提高并发吞吐量，高容错，很稳定，今天抽时间先简单看了相关的文档，写了个简单的例子，主要演示如何使用akka，当然我们也可以搭建一个akka的集群。\n\n<!-- more -->\n\n#### 二.快速开始\n\nakka相关的依赖\n```xml\n<!--  akka starting -->\n<dependency>\n\t<groupId>com.typesafe.akka</groupId>\n\t<artifactId>akka-actor_2.10</artifactId>\n\t<version>2.2.3</version>\n</dependency>\n<dependency>\n\t<groupId>com.typesafe.akka</groupId>\n\t<artifactId>akka-remote_2.10</artifactId>\n\t<version>2.2.3</version>\n</dependency>\n<dependency>\n\t<groupId>com.typesafe.akka</groupId>\n\t<artifactId>akka-kernel_2.10</artifactId>\n\t<version>2.2.3</version>\n</dependency>\n<dependency>\n\t<groupId>com.typesafe.akka</groupId>\n\t<artifactId>akka-cluster_2.10</artifactId>\n\t<version>2.2.3</version>\n</dependency>\n<dependency>\n\t<groupId>com.typesafe.akka</groupId>\n\t<artifactId>akka-contrib_2.10</artifactId>\n\t<version>2.2.3</version>\n</dependency>\n<dependency>\n\t<groupId>com.typesafe.akka</groupId>\n\t<artifactId>akka-slf4j_2.10</artifactId>\n\t<version>2.2.3</version>\n</dependency>\n<dependency>\n\t<groupId>org.fusesource</groupId>\n\t<artifactId>sigar</artifactId>\n\t<version>1.6.4</version>\n</dependency>\n<dependency>\n\t<groupId>com.typesafe.akka</groupId>\n\t<artifactId>akka-cluster_2.10</artifactId>\n\t<version>2.2.3</version>\n</dependency>\n<!--  akka ending  -->\n```\njava代码\n```java\npublic enum Msg {\n    GREET, DONE, WELCOME;\n}\n\npublic class Greeter extends UntypedActor {\n    @Override\n    public void onReceive(Object msg) throws Exception {\n        if (msg == Msg.GREET) {\n            System.out.println(\"Greeter Messgae!\");\n            // 收到GREET消息后发出一个DONE的应答\n            getSender().tell(Msg.DONE, getSelf());\n        }\n    }\n}\n\npublic class Welcome extends UntypedActor {\n\n    @Override\n    public void onReceive(Object arg0) throws Exception {\n        if (arg0 == Msg.WELCOME) {  \n            System.out.println(\"Welcome Messgae!\");\n            // 收到WELCOME消息后，发出一个WELCOME的应答\n            getSender().tell(Msg.WELCOME, getSelf());\n        }\n    }\n}\n\npublic class HelloWorld extends UntypedActor {\n\n    @Override\n    public void preStart() {\n        // 发送WELCOME消息给welcome这个Actor\n        final ActorRef welcome = getContext().actorOf(Props.create(Welcome.class), \"welcome\");\n        welcome.tell(Msg.WELCOME, getSelf());\n        \n        // 发送GREET消息给greet这个Actor\n        final ActorRef greeter = getContext().actorOf(Props.create(Greeter.class), \"greeter\");\n        greeter.tell(Msg.GREET, getSelf());\n    }\n\n    @Override\n    public void onReceive(Object msg) throws Exception {\n        if (msg == Msg.DONE) {\n            System.out.println(\"Message DONE\");\n            getContext().stop(getSelf());\n        } else {\n            System.out.println(msg);\n        }\n    }\n}\n```\n这里的HelloWorld，Welcome，Greeter是三个Actor，在上述代码中HelloWorld向Welcome，Greeter发消息，Welcome，Greeter收到消息后分别向HelloWorld发出回应。\nHelloWorld在收到DONE消息后会终止自己。通过akka.Main来启动，设置启动参数com.bolin.young.akka.HelloWorld，这样就能看到相关的输出了。\n\n####三.总结\n通过上面这个小例子，我们发现akka中有一个核心的东西，那就是actor，actor之间通过消息通信，actorA发消息给actorB，actorB收到actorA的消息后，也可以对actorA发送一个回应的消息。\n","mtime":1414248941000,"source":"source/_posts/akka-start.md","_id":"2k6ewpypl3ei6tql"},"mdp2cr7bi3obv32f":{"content":"title: 关于ArrayBlockingQueue的put和offer方法\ndate: 2016-05-15 11:01:06\ntags: JAVA\ncategories: 编程开发\n---\n\n最近线上出现了一个故障，故障的表现就是服务请响应很慢，依赖方获取不到执行结果，查看调用堆栈，发现所有的操作都阻塞在写日志的地方，这个写日志是先写日志到内存，然后再刷新到其他地方。采用了ArrayBlockingQueue，但是调用了ArrayBlockQueue的put方法\n```java\n/**\n * Inserts the specified element at the tail of this queue, waiting\n * for space to become available if the queue is full.\n *\n * @throws InterruptedException {@inheritDoc}\n * @throws NullPointerException {@inheritDoc}\n */\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        insert(e);\n    } finally {\n        lock.unlock();\n    }\n}\n```\n这里的put方法会等待一个空的位置出来，然后再执行insert，但是系统的请求量非常大，此时一个请求过来后，前面的请求可能还处于等待空位置这一步，此时当前请求获取lock就等待，这样这个业务操作就一直处于获取锁获取不到的场景中了。这是一个真实出现的case，血一般的教训，当时只能不断重启机器来缓解问题。如何彻底解决这个问题，换个API\n```java\n/**\n * Inserts the specified element at the tail of this queue, waiting\n * up to the specified wait time for space to become available if\n * the queue is full.\n *\n * @throws InterruptedException {@inheritDoc}\n * @throws NullPointerException {@inheritDoc}\n */\npublic boolean offer(E e, long timeout, TimeUnit unit)\n    throws InterruptedException {\n\n    checkNotNull(e);\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length) {\n            if (nanos <= 0)\n                return false;\n            nanos = notFull.awaitNanos(nanos);\n        }\n        insert(e);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n换成offer判断返回值为false的情况，不然把业务操作阻塞住。以后在高并发场景下面就不要在使用put这个API了。\n\n","mtime":1463282422000,"source":"source/_posts/arrayblockingqueue-put-offer.md","_id":"mdp2cr7bi3obv32f"},"2rq0nxez17trnjkg":{"content":"title: 使用ASM读取class的字节码\ndate: 2014-07-16 20:18:54\ntags: ASM\ncategories: 编程开发\n---\n\n####一.概述\n我们平时写的JAVA代码经过编译后就是class文件，class文件其实有非常严谨的结构，具体可以参考[JVM class文件格式规范](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.1),认真读完这个规范，只要你按照这个规范来解析class文件，你就一定能写个javap出来。\n\n<!-- more -->\n\n我们写的JAVA代码最终都是跑在JVM上面的，但是JVM不会跑JAVA源代码，JVM上面跑的是编译后的字节码，也就是说JVM只认识class文件，不认识.java文件。最近在分析Java字节码然后检测一些代码中存在的问题，需要读取Java的class文件，当然按照前面的规范去自己解析class文件也可以，不过这么做你需要处理很多细节问题，ASM就是一个优秀的字节码读取框架，这个框架把byte数组转换成更加具体的对象，方便我们对字节码进行深层次的分析，以及修改，因此最后选择ASM作为字节处理的工具，不过在使用这个工具的时候，发现常量池没法体现出来，因为我只需要常量池中的东西就够了，为了避免全部解析class文件，自己动手解析了常量池。\n\nASM把class文件定义成下面几部分\n![ASM字节码分块](http://bolinyoung.qiniudn.com/ASM-SECTION-PDF.png)\n\n####二.ASM读取Class的字节码文件\n使用ASM读取Class的字节码文件时，我们与两种思路可以选择\n\n* Core-API\n这中思路其实就是事件的思想，前面我们提到过ASM对字节码进行分块，读取到某一块的时候就会调用相应的visit方法，类似与产生一个事件，然后相应的事件监听者做出相应的响应。这中思路的优点解析过程中内存占用少，速度快，但是缺点就是过了这村就没这店，因为这种解析是顺序的，不可能倒过来的，除非你重新触发一次解析的过程，类似XML的SAX解析思想。流水式的解析，错过了，就永远错过了，除非从头再来。\n\n* Tree-API\nTree-API弥补了Core-API的不足，Tree-API会把解析出来的每一块都保存在内存中，你可以随时获取字节码中的任意一块，这样避免了Core-API的缺点，但是暴漏出来的缺点就是内存占用比较大，类似XML的DOM解析思想。保证字节码的每一块内容在整个解析的过程中一直存储在内存中。\n\n我们可以借鉴ASM这种API设计的理念，解决API设计中存在的一些问题。\n\n![ASM-API核心类图](http://bolinyoung.qiniudn.com/ASM-API.png)\n\nClassVistor是一个抽象类，我们在使用Core-API的时候需要构造一个自己的Visitor继承ClassVistor即可，然后重载一些ClassVistor中访问各个字节码模块的方法，这样在解析到每个class文件的相应模块时，这些方法会被回调。我们在使用Tree-API的时候，需要构造一个ClassNode,通过上述类图就能看出ClassNode也是ClassVisitor的一个派生类，这不过这个ClassNode在实现这些visit方法的时候把流水式解析的结果存储在一些自己的成员变量中，从而保证各个字节码分块在整个解析的过程中都在内存中一直存在。","mtime":1405516047000,"source":"source/_posts/asm-read-class-bytes.md","_id":"2rq0nxez17trnjkg"},"72ubtfxmij5cdpie":{"content":"title: BeanFactoryPostProcessor和BeanPostProcessor\ndate: 2014-06-24 23:29:37\ntags: Spring\ncategories: 编程开发\n---\n\n\n一.概述\n我们经常使用Spring框架，Spring帮我托管bean的创建以及bean的管理，同时又暴漏出一些可扩展的地方，方面程序员去干涉bean或者Spring容器的创建。今天有同学问BeanPostProcessor相关的东西，由此很容易想到BeanFactoryPostProcessor，这里总结一下，方便后面在开发的过程中灵活使用。\n\n<!-- more -->\n\n二.BeanPostProcessor前置处理器\nSpring容器在创建bean的时候，会看有没有BeanPostProcessor，如果有的话，会回调BeanPostProcessor接口中的两个方法，在bean创建之前执行程序员的一些个性化代码，在bean创建之后也执行一些程序员的个性化代码。\n```\npublic interface BeanPostProcessor {\n    /** 创建bean之前回调 **/\n\tObject postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\t/** 创建bean之后回调 **/\n\tObject postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n}\n```\n\n三.BeanFactoryPostProcessor\n这个可以让程序员去干涉一下Spring容器的创建，Spring容器创建的时候会回调这个接口的定义的这个方法，比如你可以在实现了这个接口的方法中给Spring容器注册一个JVM关闭时回调的钩子。\n```\npublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor{\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n        // 注册JVM关闭时的回调\n        ConfigurableApplicationContext cxt = (ConfigurableApplicationContext)beanFactory;\n        cxt.registerShutdownHook();\n    }\n}\n```","mtime":1404107666000,"source":"source/_posts/beanfactorypostprocessor-and-beanpostprocessor.md","_id":"72ubtfxmij5cdpie"},"v63s63352ikhbl43":{"content":"title: 一个数据产品中异步写数据的实现思路\ndate: 2014-04-12 15:20:21\ntags: 并发\ncategories: 编程开发\n---\n\n####一.需求描述\n最近在开发一个大数据产品，这个数据产品主要是快速产出用户需要的数据，每次用户调我们数据产品提供的接口后，我们都会把接口的返回值存储到HBase和缓存，存储到HBase目的是后续做一些统计用，存储到缓存的目的加速数据产品的计算速度，因为某些数据在一段时间内计算的结果都是一样的。这个需求可以简单描述成这样，把数据产品的计算结果写缓存和HBase。\n\n<!-- more -->\n\n####二.分析\n上述数据产品先计算数据，然后把计算结果存储起来，计算和存储是两个模块，先计算后存储，首先我们想到不应该同步做这两件事情，毕竟存储不存储对使用数据产品的人来说他不关心，他所关心的是我们的数据产品能否准确快速地返回他所需要的数据，这样一旦数据产品计算出结果后，我们应该立即返回给用户，从这点说我们应该在计算模块结束后就把数据直接返回到客户端，因此异步存储计算结果的思路就出来了，不要等结果都存储后，再把计算结果返回，这样可以加速数据产品数据产出的速度，因此我们采用异步存储的思路。\n####三.异步存储思路\n* 方案1：每次存储都创建一个线程，由这个线程负责把数据写到缓存和HBase\n* 方案2：把每次要写的数据先在内存中存储起来，使用固定数目的后台线程把数据写入HBase和缓存\n\n关于方案1是最常见也最容易想到的一种思路，采用固定大小的线程池，每次写数据的时候都new一个线程对象，然后交给线程池去调度执行。\n\n在方案2中我们需要启动N个后台线程，这N个后台线程不断轮循内存中存储数据的BlokingQueue,如果BlockingQueue中有数据，这N个线程会竞争获取一块数据，然后异步把数据写入到HBase和缓存。关于线程的同步我们使用了BlockingQueue，要是BlockingQueue中没有数据，线程就会阻塞，当BlockingQueue中有数据了，线程就会被唤醒。\n\n对于方案2我们需要考虑一下线程的善后处理，当系统中线程池要销毁时，该如何应对呢？此时，我们要保证两个点，第一，保证BlockingQueue中的数据都被存储，第二，保证正在RUNNABLE的线程把数据写完。关于第一点我们可以在线程池销毁的时候，也轮循一下BlockingQueue这个队列，当这个队列中还有数据的话，我们就取数据出来，然后把数据写入HBase和缓存，直到这个队列为空。伪代码如下\n```java\nwhile (!blockingQueue.isEmpty()) { // 阻塞队列中还有数据\n    // 取出阻塞队列中的数据\n    StoreDataObject storeDataObject = blockingQueue.take();\n    // 存储数据\n    dataWriteService.write(storeDataObject);\n}\n```\n\n当上面这个代码块执行完后，我们再开始考虑销毁线程池。\n\n接下来我们考虑，如何保证第二点，即保证正在运行的线程把数据写完，我们先让线程池发出一个shutdownNow的信号，此时线程池处于stop状态，拒绝接受新的线程，同时调用线程的interrupt方法，尝试中断线程，要是线程处于RUNNABLE的话，调用interrupt是不会被中断的，由于当BlockingQueue中没有数据的话的，线程就会处于BLOCKED状态，直到BlockingQueue中有数据，线程才会被唤醒，基于这个原理我们就有了下面的思路，伪代码如下\n```java\n// 先调用线程池的shutdownNow,这样线程池会调线程的interrupt\nFIELD_DATA_WRITE_THREAD_POOL.shutdownNow(); \n//处于RUNNABLE的线程不会受影响\nwhile (!FIELD_DATA_WRITE_THREAD_POOL.isTerminated()) {\n    // 继续调用线程池的shutdownNow，让线程池调用线程的interrupt\n    FIELD_DATA_WRITE_THREAD_POOL.shutdownNow();\n}\n```\n\n这样我们就保证了上面的第二点，保证处于RUNNABLE的线程能够把数据正常写入到缓存和HBase.\n\n另外，我们写数据的线程都是轮循BlockingQueue的，这些线程需要对中断作出合理响应，即放弃轮循。伪代码如下：\n```java\nwhile (true) {\n    try {\n        StoreDataObject storeDataObject = storeDataQueue.take();\n        dataWriteService.writestoreDataObject();\n    } catch (InterruptedException e) {\n        LOG.info(String.format(\"%s has bean interrupted!!!\", this.getName()), e);\n         break; // 轮循终止\n    } catch (Exception e) {\n        LOG.error(String.format(\"%s store iquant data exception\", this.getName()), e);\n        break; // 轮循终止\n    }\n}\n```\n\n至此，方案2表面上看起来是差不多了，但是我们想一下，要是轮循写数据出现异常的时候，线程就退出了，这样消费能力就降低了，这样BlockingQueue中的数据就会堆积，占用很大的内存，从这个角度出发我们需要考虑两个问题，如何保证轮循的线程在挂掉之后，补充一个轮循线程，其次，如何保证BlockingQueue中的数据暴增对系统的不会产生影响，关于第一个问题，我们可以使用一个后台线程去管理这些轮循线程，当轮循的线程数目少于N的时候，这个后台线程自动新增线程，第二个问题有很多解决思路，比如最简单可以限定BlockingQueue的大小，超过大小后，BlockingQueue就拒绝接收数据，把这些被拒绝的数据持久化到某个地方，后续再补充到BlockingQueue中。\n\n####四.最后总结\n* 在系统中一旦使用了线程池，在线程池销毁的时候，需要考虑线程正在做什么事情，要不要在销毁之前等线程把自己该做的事情做完，不要贸然就去销毁一个线程池。\n* 对于生产者和消费者模型的并发问题，注意考虑如何维持消费能力，以及如何避免共享内存暴增对系统造成的影响。","mtime":1397539046000,"source":"source/_posts/async-write-data.md","_id":"v63s63352ikhbl43"},"88vjjgti2p41tklz":{"content":"title: awk使用总结\ndate: 2015-09-09 21:12:36\ntags: awk\n---\n####一.概述\n在平时工作中经常会遇到一些文本的处理，awk就是一种文本处理语言，很方便，很轻量，可以说awk也是一种编程语言。\n\nawk的工作流程是这样的：读入有'\\n'换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，\\$0则表示所有域，\\$1表示第一个域，\\$n表示第n个域。默认域的分隔符是\"空白键\"或\"tab键\"。\n<!-- more -->\n\n####二.常用命令\n#####1.显示指定分隔符分隔后的第一列\n```awk\nawk -F ':' '{print $1}' /etc/passwd\n```\n-F ':' 指定了awk处理行文本的分隔符号\n{print $1}表示是action，对于文本中的没一行都要执行这个action\n这个文本处理模式是awk+action\n\n#####2.搜索文件中包含某一关键字的行\n```awk\nawk -F: '/root/' /etc/passwd\n```\n这里使用的pattern，匹配了pattern的行才会执行后面的action，没有指定action默认输出正行内容。\n```awk\nawk -F: '/^root/' /etc/passwd\n```\n匹配所有以root开头的行\n\n#####3.awk内置变量\n```awk\nawk -F ':' '{printf(\"filename:%s,linenumber:%s,linecontents:%s columns:%s\\n\",FILENAME,NR,NF,$0)}' /etc/passwd\n```\nFILENAME awk浏览的文件名\nNR 已读出的记录数目\nNF 浏览记录的域的个数\nprintf用于格式化输出\n\n#####4.变量和赋值\n统计一个文件中的行数\n```awk\nawk '{count++;print $0} END{print \"user count is \", count}' /etc/passwd \n```\n注意这里的count虽然没有被初始化，但是它的值是0，但是稳妥的做法还是初始化一下\n```awk\nawk 'BEGIN {count=0;print \"[start]user count is \", count}' {count=count+1;print $0} END {print \"[end] user count is \", count}' /etc/passwd\n```\nBEGIN后面的action只有在开始的时候才会执行，END后面的语句只有结束的时候才会执行\n\n统计某个文件夹下的文件占用的字节数\n```awk\nls -l | awk 'BEGIN {size=0} {size=size+$5} END{print \"[end]size is \",size}'\n```\n\n如果以M为单位显示：\n```awk\nls -l | awk 'BEGIN {size=0} {size=size+$5} END{print \"[end] size is \", size/1024/1024, \"M\"}'\n```\n这个统计命令在排查线上日志超出限制时很有用。","mtime":1441850518000,"source":"source/_posts/awk-command.md","_id":"88vjjgti2p41tklz"},"splgza0fgl161jq3":{"content":"title: 使用BTrace监控方法入参\ndate: 2014-10-12 18:06:18\ntags: BTrace\ncategories: 开发工具\n---\n####一.现象\n昨天在生产环境出现一个类的方法被调用然后出现了异常，这个异常没有被catch而是直接抛给上层的调用，我们想知道抛异常时调用该方法的参数是什么样子的，然后根据这个参数分析问题聚图出现在什么地方。\n\n<!-- more -->\n\n为了能够清晰的说明问题，这里大致描述一下昨天出问题的类的代码结构\n```java\npublic class xxxUtil {\n\tpublic static Object decodeXxx(String sSrc, String sSkey,String iVParam) throws Exception {\n\t// 在这里做解码，然后在这里抛异常了\n\t}\n}\n```\n静态方法decodeXxx被调用时，在方法内部抛出了没有被catch住的异常，这就是基本现象。\n\n####二.排查过程\n我们需要知道调用decodeXxx方法是参数是什么样子的，生成环境没法DEBUG只能考虑使用BTrace脚本了，使用BTrace动态监控decodeXxx的调用，然后输出方法调用的参数，于是我准备了如下的BTrace脚本，此时所有decodeXxx方法的调用都会被监控到，如何区分有异常的case呢？我们日志中记录的异常以及异常发生的时间，因此我们需要在监控脚本中输出监控时间，然后和日志中异常发生的时间对比，找出最终出现问题的方法调用。\n```java\nimport static com.sun.btrace.BTraceUtils.*;\nimport com.sun.btrace.annotations.*;\nimport com.sun.btrace.AnyType;\n\n@BTrace\npublic class TraceMethodArgsAndReturn{\n\n        @OnMethod(\n        clazz=\"xxx.xxxUtil\",\n        method=\"decodeXxx\",\n        location=@Location(Kind.RETURN)\n        )\n        public static void traceExecute(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){\n                println(\"Call xxxUtil.decodeXxx\");\n                // 打印入参sSrc\n                println(strcat(\"sSrc is:\",str(sSrc)));\n                // 打印入参sSkey\n                println(strcat(\"sSkey is:\",str(sSkey)));\n                // 打印入参iVParam\n                println(strcat(\"iVParam is:\",str(iVParam)));\n                // 打印函数返回结果result\n                println(strcat(\"result is:\",str(result)));\n                // 输出时间,这里之所以输出时间就是为了和日志中的时间对比寻找出错时方法调用的入参，日志中记录了异常时间\n                println(strcat(\"time is:\",str(timeMillis()));\n        }\n}\n```\n脚本准备好了，然后在线上和JVM建立链接\n```\nsudo -u admin /home/boris.yangbl/btrace/bin/btrace -cp /home/boris.yangbl/btrace/build 8485 TraceMethodArgsAndReturn.java\n```\n其中8485是JVM的PID。\n执行命令后，监控确实被监控到了，但是方法内部抛异常的case没有被监控到，奇怪，此时子写检查上面的监控脚本，发现location=@Location(Kind.RETURN)，这说明方法返回时才会被监控到，要是方法抛异常了，方法的return字节码压根就不会被调用，要是方法的return字节码不会被调用，那BTrace动态增加的字节码也不会被调用，因此需要修改一下BTrace脚本了，输出的时候不要限制方法返回，现在把BTrace脚本修改如下\n\n```java\nimport static com.sun.btrace.BTraceUtils.*;\nimport com.sun.btrace.annotations.*;\nimport com.sun.btrace.AnyType;\n\n@BTrace\npublic class TraceMethodArgsAndReturn{\n\n        // 方法返回时的监控\n        @OnMethod(\n        clazz=\"xxx.xxxUtil\",\n        method=\"decodeXxx\",\n        location=@Location(Kind.RETURN)\n        )\n        public static void traceExecute(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){\n                println(\"return xxxUtil.decodeXxx\");\n                // 打印入参sSrc\n                println(strcat(\"sSrc is:\",str(sSrc)));\n                // 打印入参sSkey\n                println(strcat(\"sSkey is:\",str(sSkey)));\n                // 打印入参iVParam\n                println(strcat(\"iVParam is:\",str(iVParam)));\n                // 打印函数返回结果result\n                println(strcat(\"result is:\",str(result)));\n        }\n        // 进入方法的监控\n        @OnMethod(\n        clazz=\"xxx.xxxUtil\",\n        method=\"decodeXxx\"\n        )\n        public static void traceExecute(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){\n                println(\"enter xxxUtil.decodeXxx\");\n                // 打印入参sSrc\n                println(strcat(\"sSrc is:\",str(sSrc)));\n                // 打印入参sSkey\n                println(strcat(\"sSkey is:\",str(sSkey)));\n                // 打印入参iVParam\n                println(strcat(\"iVParam is:\",str(iVParam)));\n                // 打印函数返回结果result\n                println(strcat(\"result is:\",str(result)));\n        }\n}\n```\n修改成上面的监控脚本后，我们都不需要在脚本中输出监控时间了，要是有方法抛异常的化了，必然会出现只有enter(进入方法的监控)没有return(方法返回时的监控)的输出，由于线上有两台机器，因此同时在这两台机器上使用了这个BTrace脚本，最终定位到了decodeXxx方法内部抛出异常时方法的入参是什么。后面的分析和业务有关，这里不做过多解释。\n\n####三.最后总结\nlocation=@Location(Kind.RETURN)要是方法内部出现异常的话，此时被BTrace修改后的字节码就没法执行了。\n","mtime":1415431232000,"source":"source/_posts/btrace-for-exception.md","_id":"splgza0fgl161jq3"},"x71i11jt1rkeol6f":{"content":"title: JAVA字节码常量池中常量编号的疑问\ndate: 2014-07-16 17:50:43\ntags: JVM\ncategories: JVM学习\n---\n####一.问题描述\n最近在解析JAVA字节码的时候，发现常量池中常量编号不连续了，导致解析程序经常NPE，然后仔细测试了一下，发现常量类型如果是Long或者Double的话，就会导致常量池中常量的编号不连续了。\n\n<!-- more -->\n\n假如当前常量类型是Long的话，并且当前常量编号是N，此时如果还有下一个常量的话，下一个常量的编号就是N+2不是N+1了。\n\n![字节码常量池中常量的编号](http://bolinyoung.qiniudn.com/bytecode-why.png)\n\n此时我们发现编号为2的常量是Long类型，结果下面一个常量的编号变成4了，为什么不是3?同时编号为5的常量是Double类型，结果下面一个常量的编号变成7了，为什么不是6?\n\n从上面的分析暂时可以得出的结论是:Long或者Double类型的常量在常量池中占据两个常量的编号，这个是为什么呢？\n\n####二.相关解释\n一开始以为这里的编号可能不是按照自然顺序来的，或者是相对与什么的偏移量，因为方法的字节指令前面的编号就是字节码数组中的偏移量。后面查找了一下[JVM规范](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.5)，发现这是一个Class文件的规范定义。\n\n![JVM常量池规范](http://bolinyoung.qiniudn.com/bytecode-guifan.png)\n\n而且已经在规范里面吐槽过了。因此在解析常量池中常量编号的时候不能一直按照自然顺序单调递增，如果常量是Long或者Double类型的话，需要跳过一个常量的编号。","mtime":1406375286000,"source":"source/_posts/class-bytecode-constant-pool-num.md","_id":"x71i11jt1rkeol6f"},"zsu1rq9txyvdvgxi":{"content":"title: 一个jar包冲突的解决\ndate: 2014-05-09 18:59:01\ntags: JAVA\ncategories: 编程开发\n---\n\n最近在发布一个需求的时候，遇到下面的错误\n\n<!-- more -->\n\n![出错截图](http://bolinyoung.qiniudn.com/conflict1.png)\n\n应用主干部署出现这个问题，从日志中看貌似是jar包冲突导致，上图中红色框圈起来的内容是关键信息\n\n> java.lang.NoSuchMethodError: org.objectweb.asm.ClassWriter.<init>(Z)V\n\n找不到ClassWriter类的构造函数，即这行出错日志所要表达的信息。\n\n<init>(Z)V是构造函数ClassWriter(boolean arg0)的字节码，其中V标识函数返回值void。这时候错误很明显了，就是说JVM自己加载的ClassWriter类没有ClassWriter(boolean arg0)这样的构造函数，但是系统需要一个这样的构造函数，至此，问题很明确，jar包冲突啦。但是到底是那个jar包冲突了呢？\n\n使用mvn dependency:tree打了依赖树，发现org.objectweb.asm.ClassWriter这个类在一个asm的jar包中，但是asm这个jar包我们的应用没有显式依赖，都是间接依赖，难道要一个一个去仲裁掉吗？\n\n此时，我没有继续排查，而是把上面那行java.lang.NoSuchMethodError: org.objectweb.asm.ClassWriter.<init>(Z)V作为关键词到google搜了一把，很快就有答案说升级sourceforge.cglib到nodep-2.2，因此在顶级pom中增加了\n```xml\n<dependency>\n    <groupId>com.alibaba.external</groupId>\n    <artifactId>sourceforge.cglib</artifactId>\n    <version>nodep-2.2</version>\n</dependency>\n```\n同时在相应的子pom中也配置相关的依赖，重启应用，问题解决。\n\n关于jar包冲突经常会说某个类的方法找不到，但是具体是什么方法，显示出来的都是字节码，因此我们需要了解一些字节码的知识，才能看到具体是那个方法。其中关于类型相关的可以看一下这个联合体的定义\n```c\ntypedef union jvalue { \n    jboolean z; \n    jbyte    b; \n    jchar    c; \n    jshort   s; \n    jint     i; \n    jlong    j; \n    jfloat   f; \n    jdouble  d; \n    jobject  l; \n} jvalue; \n```\n\n下面给出具体类型对照\n\n|Type Signature|Java Type|\n|---|---|\n|Z|boolean|\n|B|byte|\n|C|char|\n|S|short|\n|I|int|\n|J|long|\n|F|float|\n|D|double|\n|L fully-qualified-class ;|fully-qualified-class|\n|[ type|type[]|\n|( arg-types ) ret-type|method type|\n\n例如\n```java\nlong f (int n, String s, int[] arr); \n```\n具有如下的字节码签名\n> (ILjava/lang/String;[I)J ","mtime":1399637861000,"source":"source/_posts/class-conflict-analyse-1.md","_id":"zsu1rq9txyvdvgxi"},"u269p4c8lggnjjhp":{"content":"title: 使用BTrace来定位方法中Catch住的异常\ndate: 2014-05-14 15:55:55\ntags: [JAVA,BTrace]\ncategories: 开发工具\n---\n\n####一.问题\n今天在自己应用中引入了一个新的中间件，发布到线上后，发现一个接口一直获取不到数据，此时找不到日志，因为代码中的日志输出不按常理出牌，误引入了某一中间件自定义的Logger导致日志很难找到，此时要是在测试环境，debug一下就搞定，但是线上不能这么搞，如何去查看一下本次调用接口返回的数据到底是什么呢？\n\n<!-- more -->\n\n####二.被调用到的代码\n![被调用到的代码](http://bolinyoung.qiniudn.com/udc.png)\n\n上面代码的getData方法被调用了，但是返回的DataResult中没有数据。\n\n####三.使用BTrace监控一下getData方法的返回值以及输入参数\n```java\nimport static com.sun.btrace.BTraceUtils.*;\nimport com.sun.btrace.annotations.*;\nimport com.sun.btrace.AnyType;\n\n@BTrace\npublic class TraceMethodArgsAndReturn{\n\n        @OnMethod(\n        clazz=\"xxx.UdcDataSource\",\n        method=\"getData\",\n        location=@Location(Kind.RETURN)\n        )\n        public static void traceExecute(@Self Object dataSource, AnyType context, @Return Object result){\n                println(\"Call UdcDataSource.getData\");\n                // 打印当前被BTrace拦截到的实例\n                println(strcat(\"dataSource is:\",str(dataSource)));\n                // 打印getData方法的参数 xx.DefaultParamContext是context的类型\n                println(strcat(\"fields are:\",str(get(field(\"xx.DefaultParamContext\",\"fields\"),context))));\n                println(strcat(\"context are:\",str(get(field(\"xx.DefaultParamContext\",\"context\"),context))));\n                // 打印getData的返回值 xx.DataResult是result的实际类型\n                println(strcat(\"result is:\",str(get(field(\"xx.DataResult\",\"result\"),result))));\n        }\n}\n```\n\n使用上面这段BTrace脚本，就可以跟踪getData方法的调用了，跟踪的结果是getData方法返回DataResult实例，但是DataResult实例中的Map实例大小为0,也就是说上面代码中ret大小为0。\n\n仔细看看上面调用到的代码，如果返回结果是这样的话，只能说明getData方法中抛异常了。看看catch语句中的日志，竟然没有把exception也输出到log里面，那如何看这里面的异常呢？难道要再发布一次。。。。要是BTrace也能把这个异常跟踪到，那就好办了。\n\n在BTrace脚本中不能出现自己定义的类型，要是自己定义的类类型，要么使用AnyType,要么使用Object在BTrace脚本中来指定。\n\n####三.使用BTrace来跟踪方法中catch住的异常\n不清楚怎么搞，只能google一下，看了一些BTrace的文档，发现BTrace竟然能跟踪到方法中catch住的异常。于是写了下面的代码\n\n```java\nimport static com.sun.btrace.BTraceUtils.*;\nimport com.sun.btrace.annotations.*;\n\n@BTrace\npublic class TraceException {\n   // 异常捕捉\n   @OnMethod(clazz = \"xxx.UdcDataSource\", method = \"getData\", location = @Location(Kind.CATCH))\n   public static void traceExecute(@ProbeClassName String pcn, @ProbeMethodName String pmn, Exception e) {\n      print(pcn);\n      print(\".\");\n      print(pmn);\n      print(\"(\");\n      println(\") cacth Exception\");\n      println(e);\n   }\n}\n```\n使用Kind.CATCH就能捕获方法中catch住的异常了，至此异常发现，问题搞定。\n\n####五.BTrace使用\n关于BTrace的使用很简单，可以参考http://jm-blog.aliapp.com/?p=509\n\n####六.需要注意的问题\n我们知道BTrace是动态修改类的字节码的，动态增加一些字节码，那么这些动态增加的字节码在BTrace断开后，会被删除吗？也就是说被修改了的类能恢复到修改之前吗？答案是不能，在BTrace断开后，BTraceRuntime就会记录自己已经禁用了,把disabled设置为true，于是虽然被改写的字节码还保留着对它的调用，但BTraceRuntime看到disabled为true就直接返回了.\n\n```java\n/**\n * Enter method is called by every probed method just\n * before the probe actions start.\n */\n\npublic static boolean enter(BTraceRuntime current) {\n\tif (current.disabled) return false;\n\treturn map.enter(current);\n//        // check we have entered already or disabled\n//        if (current.disabled || (tls.get() != null)) {\n//            return false;\n//        } else {\n//            tls.set(current);\n//            return true;\n//        }\n}\n\n// 这个方法在BTrace退出的时候会被调用\nprivate synchronized void exitImpl(int exitCode) {\n\tif (exitHandler != null) {\n\n\ttry {\n\t\texitHandler.invoke(null, exitCode);\n\t    } catch (Throwable ignored) {\n \t    }\n         }\n\n\t// 退出的时候把disabled设置成true\n\tdisabled = true;\n\t// ...后面的代码省略\n\n}\n```\n[BTraceRuntime源码](https://kenai.com/projects/btrace/sources/hg/content/src/share/classes/com/sun/btrace/BTraceRuntime.java?rev=462)\n","mtime":1413111027000,"source":"source/_posts/btrace-for-production-problem.md","_id":"u269p4c8lggnjjhp"},"ym71hkwu4bh50a1j":{"content":"title: 聊聊一致性哈希算法\ndate: 2014-05-10 22:03:25\ntags: Algorithm\ncategories: 编程开发\n---\n\n####一.一致性哈希算法要解决什么问题\n假设我们有N个缓存空间，我们现在要把对象存储到到这个N个缓存空间中，我们可以定义这样的哈希函数\n\n> hash(object) mod N\n\n<!-- more -->\n\n每次存储对象的时候，计算一下这个哈希函数的值，这个值在[0,N)之间，这样我们就可以知道当前这个对象需要存储在那个缓存空间中了。\n\n基于上面的解决方案，我们考虑如果缓存空间增加1个的话，我们该怎么处理，此时我们的哈希函数就变成了\n\n> hash(object) mod (N + 1)\n\n哈希函数的变动意味着什么呢？意味着所有的对象需要重新哈希，这个代价太高了，会导致系统不可用的时间大大增加。\n\n我们再考虑如果缓存空间有一个不可用啦，此时我们的哈希函数就变成了\n\n> hash(object) mod (N - 1)\n\n哈希函数同样发生了变化，哈希函数的变化就意味着你之前存储的所有对象都要进行再次哈希。\n\n上面这两种情况都是在实际生产环境中经常发生的，要是我们采用上面的解决方案，我们就没法把系统的稳定性保持在4个9。因此一致性哈希算法出现了，该算法能够保证缓存空间增加和减少的时候把再哈希的范围缩到最小。\n####二.哈希空间\n这里的哈希空间是指哈希函数值域形成的取值空间，一般情况下哈希函数的值域在[0,2^32)，我们把这个值域想象成一个环形的空间，这个环形的空间就是我们这里一致性哈希算法的对应的哈希空间。至于为什么这里需要把它想象成一个环，就是为了后面对象和存储空间的映射。关于哈希空间如下图所示\n\n![哈希空间](http://bolinyoung.qiniudn.com/hashspace.png)\n\n接下来对象和对象的存储空间都是需要向这个哈希空间来映射的。\n####三.把对象映射到哈希空间\n假设这里有四个对象，object1,object2,object3,object4,我们现在需要通过哈希函数把这个四个对象映射到我们前面提到的哈希空间中。\nhash(object1) mod N = key1\nhash(object2) mod N = key2\nhash(object3) mod N = key3\nhash(object4) mod N = key4\n如下图所示，我们把四个对象映射到我们上面提到的哈希空间中\n![对象映射到哈希空间](http://bolinyoung.qiniudn.com/object2hashspace.png)\n这样我们的对象就在哈希空间中找到了自己的位置。\n####四.把缓存空间映射到哈希空间\n假设我们有三个缓存空间，cacheA,cacheB,cacheC,现在我们把这个三个缓存空间映射到哈希空间中\nhash(cacheA) mod N = keyA\nhash(cacheB) mod N = keyB\nhash(cacheC) mod N = keyC\n![缓存空间映射到哈希空间](http://bolinyoung.qiniudn.com/cache2hashspace.png)\n这样我们的缓存空间在哈希空间中也找到了自己的位置。\n####五.把对象映射到缓存空间\n我们的目的不是映射到哈希空间，而是把对象映射到缓存空间，目前对象和缓存空间都映射到了哈希空间，现在我们需要把对象映射到缓存空间，如何处理呢？我们可以把哈希空间顺时针绕一圈，遍历哈希空间中的object,找到离object最近的cache，然后把这个object放在这个cache上面，这样即可完成object到cache的映射。如下图所示：\n![对象映射到缓存空间](http://bolinyoung.qiniudn.com/object2cache.png)\n此时此刻，我们的对象已经和缓存空间之间建立了关系，并且对象已经找到自己应该前往那个缓存空间了。\n####六.增加一个缓存空间\n现在我们考虑增加一个缓存空间cacheD\n![增加一个缓存空间](http://bolinyoung.qiniudn.com/addcache.png)\n我们看到增加一个缓存空间cacheD后，我们需要重新映射的对象只有object2,其他三个对象都不需要重新映射。\n####七.删除一个缓存空间\n现在我们考虑删除一个缓存空间cacheB\n![删除一个缓存空间](http://bolinyoung.qiniudn.com/removecache.png)\n删除缓存空间cacheB后，我们只需要把object4做重新映射即可。\n####八.解决负载均衡的问题\n要是我们的缓存空间数目不多，但是哈希空间很大，这会导致object不均衡地存储到缓存空间中，因此我们引入虚拟节点来解决这个问题，针对每个缓存空间，我们可以引入多个虚拟节点，v1...vn,所有映射到这几个虚拟节点的对象都会存储到同一个物理节点上。\n![虚拟节点的引入](http://bolinyoung.qiniudn.com/virtualnode.png)\n\n这里的cacheA引入了两个虚拟节点vA1和vA2\n这里的cacheB引入了两个虚拟节点vB1和vB2\n这里的cacheC引入了两个虚拟节点vC1和vC2\n\n虚拟节点不会存储对象，正真存储对象的是物理节点。\n####九.为什么叫一致性哈希算法\n* 存储对象和存储空间使用相同的哈希空间\n* 存储空间的数目变化不会导致哈希函数的变化\n\n####十.参考资料\n[一致性哈希算法](http://www.codeproject.com/Articles/56138/Consistent-hashing)","mtime":1408175489000,"source":"source/_posts/consistent-hashing.md","_id":"ym71hkwu4bh50a1j"},"lnpnzf2dj73enhae":{"content":"title: CountDownLatch和CyclicBarrier\ndate: 2014-05-11 21:11:11\ntags: [JAVA,并发]\ncategories: 编程语言\n---\n####一.概述\n在编写并发程序的时候，我们经常遇到这样的事情，就是当N个线程都走到某一步后再继续做其他事情，都走到某一步包含这N个线程都运行结束这种场景。我们可以使用线程同步的思想来解决这类问题，在C语言中中我们经常使用信号量来解决此类问题。当然要是你自己使用线程同步来解决个问题，你需要做很多事情，不过jdk提供了一些封装好的类帮助我们解决此类问题，这里我们来看如何使用juc包中提供的CountDownLatch和CyclicBarrier来解决这类问题。\n\n<!-- more -->\n\n####二.使用CountDownLatch\n![CountDownLatch](http://bolinyoung.qiniudn.com/CountDownLatchTest.png)\n\n* 1.在主线线程我们创建一个CountDownLatch实例，其计数值为2，这样必须要执行两countDown()方法，await()方法才能被唤醒。\n* 2.在ComputeThread中等线程的计算完成后我们执行countDown()方法，这里只是为了演示，一般我们需要把countDown()方法的执行写在finally代码块中。\n* 3.在main方法中我们执行await()方法等待CountDownLatch的计数值变为0后，主线程再继续向下执行。\n\n这样我们使用CountDownLatch就可以保证这两个线程把核心的计算做完之后，主线程再继续向下，因此主线程继续向下的前置条件是等这两个线程把该做的事情做完。\n\n上述代码的运行结果如下：\n\n> compute thread 1 is running...\n> compute thread 2 is running...\n> All compute Thread has finished...\n\n\n三.使用CyclicBarrier\n![CyclicBarrier](http://bolinyoung.qiniudn.com/CyclicBarrierTest.png)\n\n* 1.在主线程中我们创建一个CyclicBarrier实例，并且传递一个计数值2,同时我们以匿名内部类的方式提供一个barrier,当所有的线程都达到某个点的时候，我们就执行这个barrier。\n* 2.在没有线程中我们执行await方法等待其他线程执行，当计数值减少到0后就表示相关的线程都到barrier前面，此时barrier就开始执行，如下图所示\n![线程屏障](http://bolinyoung.qiniudn.com/barrier4thread.png)\n此时要是线程Thread2先执行完了，它必须等线程Thread2把相关的操作也执行完。\n\n上述代码的运行结果如下：\n\n> Horse Thread1 is running...\n> Horse Thread2 is running...\n> All threads have arrived here...\n\n\n####四.CountDownLatch和CyclicBarrier区别\n* 1.CountDownLatch一个线程等其他N线程执行完相关的操作\n* 2.CyclicBarrier N线程中每个线程都需要等待其他N-1线程执行完\n* 3.CyclicBarrier的计数可以复用，CountDownLatch不可以复用","mtime":1399816444000,"source":"source/_posts/countdownlatch-and-cyclicbarrier.md","_id":"lnpnzf2dj73enhae"},"k3xskc3ebnwuzwno":{"content":"title: css换行\ndate: 2015-05-07 21:55:59\ntags: CSS\ncategories: 前端开发\n---\n\n最近在搞一个后台系统的时候，发现table表格的宽度没法调整，找前端大神看了一下，发现是table表格中的全英文内容过长，不会自动换行导致。因此需要用CSS来实现换行，浏览器默认不会对英文内容进行换行的。具体CSS的写法如下\n```css\nword-break: break-all;\nword-wrap: break-word;\n```\n","mtime":1431048156000,"source":"source/_posts/css-break-line.md","_id":"k3xskc3ebnwuzwno"},"i4w0jqqkvy2r5kup":{"content":"title: 实现页面区块随屏幕滚动的效果\ndate: 2014-04-16 18:56:55\ntags: [CSS,jQuery]\ncategories: 前端开发\n---\n\n####一.需求描述\n为了提升用户体验，我们经常需要在页面上显示一块内容，这块内容当屏幕向下滚动到一定位置后就展示出来，然后随着屏幕一起上下滚动，当屏幕向上滚动到一定程度，这块内容就消失，这样这块内容在就会有时候消失，有时候随着屏幕一起滚动。\n\n<!-- more -->\n\n####二.需求分析\n这个需求需要从两个方面来把握，第一，内容块随着屏幕的滚动一直展示在页面上的某个位置，第二，当屏幕向上滚动到一定位置，内容块隐藏，向下滚动到一定位置，内容块显示出来，先实现第一点，在实现第二点，这个需求就满足了。\n\n####三.实现思路\n按照上面的分析，我们先来看第一点如何实现，内容块随着屏幕的滚动一直出现在页面上的某个位置，我们很容易想到css的position:fixed这个属性，可是别太高兴，IE6说你这个属性我不认识，所以在我的地盘你这样我不生效。这个时候就需要我们解决浏览器兼容性问题了，解决完这个问题我们就成功了一大半了,解决浏览器兼容性问题，使用hack啦，我们在IE6下面通过hack来使用绝对定位，伪代码如下：\n```css\n.mod-scroll{ \n    position:fixed; \n    top:0; \n    left:50%;\n    /** for IE6, 这个表达式可以根据实际需求具体调整 **/\n\t_top: expression(documentElement.scrollTop + documentElement.clientHeight-this.offsetHeight);\n\t_position:absolute;\n}\n```\n通过上面的css我们第一个问题就解决了，第二个问题需要监听一下滚动事件，当滚动到某个高度的时候显示内容块，当滚动到另外一个高度的时候把内容块隐藏起来。伪代码如下：\n```javascript\n$(window).on('scroll',function(){\n    // 260这个高度可以自己根据实际需求调整\n\tif($(window).scrollTop() > 260) {\n\t    // 内容区块带有class='xxxx'\n\t\t$('div.xxxx').show();\n\t\t// 25也可以自己调整\n\t\t$('div.xxxx').css('top',($(window).scrollTop()-25)+ 'px');\n\t} else {\n\t\t$('div.xxx').hide();\n\t}\n});\n```\n\n这样上面这个需求就完美解决啦。\n\n","mtime":1397649152000,"source":"source/_posts/css-screen-scroll.md","_id":"i4w0jqqkvy2r5kup"},"51gahag16xy2e3y9":{"content":"title: 枚举在hessian序列化和反序列化中的问题\ndate: 2016-05-22 11:03:47\ntags: JAVA\ncategories: 编程开发\n---\n\n####一.概述\n最近在拆分一个枚举类，但是该枚举类使用在一个RPC接口上，枚举类使用在RPC接口上，必然要考虑序列化和反序列化的问题，需要确保自己对枚举的拆分不会导致序列化和反序列化的问题。\n\n<!-- more  -->\n\n 原来的代码为\n```java\npublic enum xxxEnum {\n  X(\"a11\",\"a22\"),\n  Y(\"a111\",\"a222\"); \n  private String a1;\n  private String a2;\n  public String getA1(){ return a1;}\n  public String getA2(){ return a2;}\n }\n```\n修改后的代码为\n```java\npublic enum xxxEnum {\n  X(\"b11\",\"b22\"),\n  Y(\"b111\",\"b222\"); \n  private String b1;\n  private String b2;\n  public String getB1(){ return b1;}\n  public String getB2(){ return b2;}\n }\n```\n \n 变更了两个成员变量的名字。这样修改反序列化会不会有问题？\n\n####二.问题分析\n要想知道序列化和反序列化会不会有问题，得先看看序列化和反序列化的源码，关于hessian的序列化和反序列化有很内容，这里就拿枚举这一个点来分析。\n<font color=\"#336699\">先看看枚举序列化的代码</font>\n```java\npublic class EnumSerializer extends AbstractSerializer {\n    private Method _name;\n\n    public EnumSerializer(Class cl) {\n        // hessian/32b[12], hessian/3ab[23]\n        if (!cl.isEnum() && cl.getSuperclass().isEnum())\n            cl = cl.getSuperclass();\n\n        try {\n      // 通过反射来获取枚举类的name方法\n            _name = cl.getMethod(\"name\", new Class[0]);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void writeObject(Object obj, AbstractHessianOutput out) throws IOException {\n        if (out.addRef(obj))\n            return;\n\n        Class cl = obj.getClass();\n\n        if (!cl.isEnum() && cl.getSuperclass().isEnum())\n            cl = cl.getSuperclass();\n\n        String name = null;\n        try {\n      //调用枚举类的name方法来生成枚举序列化的值\n            name = (String) _name.invoke(obj, (Object[]) null);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        out.writeMapBegin(cl.getName());\n        out.writeString(\"name\");\n        out.writeString(name);\n        out.writeMapEnd();\n    }\n}\n```\n<font color=\"red\">关于枚举的序列化可以总结为调用枚举类的name方法来生成序列化的字符串。</font>\n<font color=\"#336699\">再看看枚举反序列化的代码</font>\n```java\npublic class EnumDeserializer extends AbstractDeserializer {\n  private Class _enumType;\n  private Method _valueOf;\n  \n  public EnumDeserializer(Class cl)\n  {\n    // hessian/33b[34], hessian/3bb[78]\n    if (cl.isEnum())\n      _enumType = cl;\n    else if (cl.getSuperclass().isEnum())\n      _enumType = cl.getSuperclass();\n    else\n      throw new RuntimeException(\"Class \" + cl.getName() + \" is not an enum\");\n\n    try {\n      // 反射获取枚举类的valueOf方法\n      _valueOf = _enumType.getMethod(\"valueOf\",\n           new Class[] { Class.class, String.class });\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  \n  public Class getType()\n  {\n    return _enumType;\n  }\n  \n  public Object readMap(AbstractHessianInput in)\n    throws IOException\n  {\n    String name = null;\n    \n    while (! in.isEnd()) {\n      String key = in.readString();\n\n      if (key.equals(\"name\"))\n        name = in.readString();\n      else\n  in.readObject();\n    }\n\n    in.readMapEnd();\n\n    Object obj = create(name);\n    \n    in.addRef(obj);\n\n    return obj;\n  }\n  \n  @Override\n  public Object readObject(AbstractHessianInput in, Object []fields)\n    throws IOException\n  {\n    String []fieldNames = (String []) fields;\n    String name = null;\n\n    for (int i = 0; i < fieldNames.length; i++) {\n      if (\"name\".equals(fieldNames[i]))\n        name = in.readString();\n      else\n  in.readObject();\n    }\n\n    Object obj = create(name);\n\n    in.addRef(obj);\n\n    return obj;\n  }\n\n  private Object create(String name)\n    throws IOException\n  {\n    if (name == null)\n      throw new IOException(_enumType.getName() + \" expects name.\");\n\n    try {\n      //反射调用枚举类的valueOf方法\n      return _valueOf.invoke(null, _enumType, name);\n    } catch (Exception e) {\n      throw new IOExceptionWrapper(e);\n    }\n  }\n}\n```\n<font color=\"red\">枚举的反序列化可以总结为反射调用枚举的valueOf方法来获取最终的的枚举值。</font>\n\n有了上面对枚举序列化反序列化源码的分析，现在我们看看相关的问题。(假定服务端做的序列化，客户端做的是反序列化，方便描述)\n\n1.服务端枚举多了一个枚举值\n假如服务端的枚举类为\n```java\npublic enum A {\n  X,\n  Y,\n  Z;\n}\n```\n客户端的枚举类为\n```java\npublic enum A {\n  X,\n  Y;\n}\n```\n如果服务端返回一个A.Z给客户端，此时hessian反序列化调用枚举类的valueOf方法来获取反序列化，但是客户端的枚举类中没有Z，<font color=\"red\">那么客户端反序列化直接跑异常。</font>\n\n2.服务端枚举ordinal值以及枚举类成员变量值和客户端不一致\n假设服务端的枚举类为\n```java\npublic enum A {\n  X(\"aaa\"),\n  Y(\"bbbb\");//此时Y的ordinal为1，对应的value为bbb\n  String value;\n  A(String value) {this.value=value}\n}\n```\n客户端的枚举类为\n```java\npublic enum A {\n  X(\"aaa\"),\n  Z(\"ccc\"),\n  Y(\"ddd\");// 此时Y的ordinal为2对应的value为ddd\n  String value;\n  A(String value) {this.value=value;}\n}\n```\n<font color=\"red\">假如入服务端传递给客户端的是A.Y，此时客户端拿到的A.Y对应的ordinal为2，对应的value为ddd。</font>\n上面这个点非常重要。\n3.枚举是单例的\n```java\npublic enum TestEnum {\n    \n    XX(\"xx\");\n    \n    TestEnum(String value) {\n        this.value = value;\n    }\n    \n    String value;\n\n    \n    public String getValue() {\n        return value;\n    }\n\n    \n    public void setValue(String value) {\n        this.value = value;\n    }\n}\npublic class Test {\n    \n    public static void main(String[] rgs) {\n        TestEnum testEnum1 = TestEnum.XX;\n        TestEnum testEnum2 = TestEnum.XX;\n        \n        testEnum1.setValue(\"XX\");\n        testEnum2.setValue(\"YY\");\n        System.out.println(testEnum1.value); // 输出 YY\n        System.out.println(testEnum2.value); // 输出 YY\n    }\n}\n```\ntestEnum1和testEnum2其实指向了同一个枚举引用。每次修改的都是同一个对象，所以前一个set的值被后面的set给覆盖了。\n\n####三.总结\n* 还是不要在RPC的接口中直接使用枚举类了，直接使用String就行\n* 在枚举类中使用字符串时直接使用name()就行，不要再做过度封装，尽量保持枚举类的简洁\n* 枚举类使用在RPC接口上的时候就一定要小心，重构的时候要注意保持ordinal\n* 枚举在序列化和反序列化的时候，除了name值，其他啥都不带的\n* 禁止给枚举提供set方法，没用的","mtime":1464518166000,"source":"source/_posts/enum-probolems-in-hessian.md","_id":"51gahag16xy2e3y9"},"lpza697i52s84smc":{"content":"title: 裂变思想\ndate: 2014-09-06 10:49:07\ntags: Algorithm\ncategories: 编程开发\n---\n\n\n#### 一.概述\n关于裂变这个词语，一开始想到的就是双11的时候红包的裂变，一个红包经过裂变后变成多个红包，让更多的人参与进来，这个红包裂变的想法当时就给自己留下了深刻的印象，其实这不是什么业务的创新，而是算法思想在业务上的经典使用。\n\n<!-- more -->\n\n在算法中一个经典的思想就是分治，要解决一个问题A，先把问题A分解为A1，A2，A3三个子问题，这三个子问题解决了，问题A也就得到相应的解决，此时可以理解为问题A在需要解决的时候裂变成3个子问题。问题变多了，但是原来的问题更好解决了，因此在这种状况下面问题变多不一定是坏事情。\n\n####二.裂变\n当一些业务点没法在一个实体体现出来的时候，考虑把这个实体裂变，然后修改裂变后实体的相关状态以满足业务需求，此时实体A裂变成两个实体A1和A2，裂变后实体A就不存在了，但是通过A1和A2上的一些关联信息一定能推理出A1和A2是实体A裂变而来的。\n![裂变](http://bolinyoung.qiniudn.com/%E8%A3%82%E5%8F%98.png)\n\n####三.总结\n在设计的时候注意裂变思想的灵活使用，虽然很简单，但是能不能灵活使用是另外一个问题。\n","mtime":1409973404000,"source":"source/_posts/fission-thought.md","_id":"lpza697i52s84smc"},"jgimto6zgftcimzx":{"content":"title: Java局部变量有没有final关键字对JVM性能影响不大\ndate: 2014-05-17 18:08:12\ntags: [JAVA,JVM]\ncategories: 编程语言\n---\n\n####一.概述\n在写Java代码中我们经常使用final这个关键字，被final修饰的变量，编译器不允许我们修改它的值，如果是基本类型，编译器不允许我们在第一次赋值后再修改基本类型的值，如果是引用类型，编译器不允许我们在第一次赋值后再修改引用的指向，这都是编译器层面的限制，因为如果你试图去修改它，就会得到一个编译错误。\n\n<!-- more -->\n\n####二.如何证明final关键字对JVM的性能影响不大\n我们写下面的Java代码\n```java\npublic class FinalLocalVariableTest {\n\tpublic int generateInt() {\n\t\treturn 3;\n\t}\n\t\n\tpublic int f1() {\n\t\tfinal int a = generateInt();\n\t\tfinal int b = generateInt();\n\t\treturn a + b;\n\t}\n\t\n\tpublic int f2() {\n\t\tint a = generateInt();\n\t\tint b = generateInt();\n\t\treturn a + b;\n\t}\n\t\n\tpublic int f3() {\n\t\tfinal int a = 2;\n\t\tfinal int b = 3;\n\t\treturn a + b;\n\t}\n\t\n\tpublic int f4() {\n\t\tint a = 2;\n\t\tint b = 3;\n\t\treturn a + b;\n\t}\n}\n```\n\n上面的java代码很简单，我们分组来对比，首先看看f1和f2的写法，f1和f2的写法一样，只是在f1是使用了final类型的局部变量，但是在f2中没有使用final类型的局部变量，此时我们编译上面的代码后，使用javap -verbose来查看编译后f1和f2的字节码\n![函数f1的字节码](http://bolinyoung.qiniudn.com/f1.png)\n红色框内的字节码表示局部变量量a,b的赋值\n![函数f2的字节码](http://bolinyoung.qiniudn.com/f2.png)\n红四框内的字节码表示final类型局部变量a,b的赋值\n\n对比发现，使用final关键字声明局部变量和不使用final关键子声明局部变量，生成的字节码都是一样的，对于JVM来说，最终执行的是字节码，既然字节码都一样，那么执行的性能也一样。\n\n接下来我们看看f3和f4的字节码有何不同\n![f3&&f4的字节码](http://bolinyoung.qiniudn.com/f3&&f4.png)\n观察上图，我们发现f3中使用了final关键字声明了局部变量a和b，此时a,b的值在编译阶段就能确定，因此字节码中直接返回常量5,但是f4中我们没有使用final关键字，因此先要把变量值load到方法栈上，然后执行变量的相加操作，最后返回相加的结果，不过这个对JVM的性能影响较小。\n\n综上所述：\n使用不使用final关键字修饰局部变量，对JVM的性能影响不大。\n","mtime":1400405477000,"source":"source/_posts/final-local-variable-for-jvm.md","_id":"jgimto6zgftcimzx"},"jeapz3p5dz48c0y4":{"content":"title: 通过Future来取消任务\ndate: 2014-05-31 19:01:51\ntags: [JAVA,并发]\ncategories: 编程开发\n---\n\n####一.概述\n在多线程程序中，我们经常使用Future来获取线程的执行结果，我们想线程的执行是异步的，因此要想获取线程执行结束后的结果，我们就需要等线程执行结束，这是一种主动获取线程执行结果的方法，当然你也可以让线程拿到结果后通知你。在使用Future的时候我们经常会设置一个超时时间，要是过了这个超时时间，线程的结果还没返回，那么我们经常就会忽略这个结果，但是这个获取结果的线程怎么办呢？让他自生自灭？我看代码中经常有这种写法，让这样的线程自生自灭。\n\n<!-- more -->\n\n####二.通过Future来取消线程\n要是相应的线程在规定的时间内没有返回结果，我们就把这个线程给终止了，不要让它自生自灭，因为此时线程的执行已经没有意义了，要是我们不管它，让它自生自灭就等于浪费系统资源，这个点很容易被忽略，说实话自己之前也经常忽略，直到今天看书的时候才发现。下面我们来看看使用Future的良好编程习惯：\n\n```java\npublic static void timedRun(Runnable r, long timeout, TimeUnit unit) throws InterruptedException {\n    Future<?> task = taskExec.submit(r);\n    try {\n        // 设置任务执行的超时时间\n        task.get(timeout,unit);\n    } catch(TimeoutException e) {\n        // 超时异常\n    } catch(ExecutionException e) {\n        // 执行异常\n    } finally {\n        // 如果任务已经结束，那么执行取消不会带来任何影响，如果任务正在执行，那么将会被中断\n        task.cancel(true);\n    }\n}\n```\n\n使用Future的时候，记得不要让没有用的任务自生自灭。","mtime":1401535579000,"source":"source/_posts/future-cancel-task.md","_id":"jeapz3p5dz48c0y4"},"mpjzb5ueiaifcm7m":{"content":"title: Java HashMap死循环分析\r\ndate: 2014-05-02 12:11:27\r\ntags: [JAVA,并发]\r\ncategories: 编程语言\r\n---\r\n\r\n####一.引言\r\n我们在平时的Java代码中经常会用到HashMap这个结构，JDK的官方文档上描述这个结构是非线程安全的，就是说在并发的情况下，HashMap的操作可能不是我们想要的。为了避免并发造成的影响，我们推荐在代码使用ConcurrentMap。一个经常被讨论的问题就是HashMap在高并发的情况下面，使用get方法就会出现死循环，导致应用的load彪高，此时重启应用，一切都会正常。记得在应用出现问题的时候保留现场，出现load彪高，一般需要把线程堆栈使用jstack保留下来，方便后续问题的排查。那么为什么在高并发的情况下，HashMap中会出现死循环呢？下面我们就慢慢分析一下。\r\n\r\n<!-- more -->\r\n\r\n####二.Hash表数据结构介绍\r\nHash表是一种经典的数据结构，这种数据结构的两个核心元素是Hash数组以及Hash函数。每次往Hash数组中增加一个元素的时候，先通过Hash函数计算出一个数组下表i,然后就在Hash数组中下标为i的位置把这个元素保存下来。获取Hash数组中元素的时候也是按照同样的方法先通过Hash函数计算出元素在Hash数组中的位置，然后再获取。当多个元素通过Hash函数计算出来的值都是i的时候，我们称发生了Hash冲突，此时要么再Hash一次，要么在Hash数组的第i个位置处建立一个链表，把发生冲突的元素依次插入到链表的头部，这样要是Hash函数设计的不够散列化，就会出现很多Hash冲突，这会导致原本O(1)的时间复杂度变成了O(n)。我们这里所说的HashMap解决冲突是利用链表而不是再Hash的方法。\r\n\r\n我们的Hash数组有大小的限制，当Hash表中的元素超过一定数量后，经常会发生Hash冲突，这样会导致Hash数组中元素i处的链表长度不断增加，最终影响我们的查询效率，因此当元素数目超过一定数量后，就会触发rehash操作，就是新建立一个Hash数组，这Hash数组的大小是原来的2倍，然后把老的Hash数组中的元素在新的Hash数组中重新映射一遍，这个操作的代价很高的。\r\n\r\n下面我们通过一个简单的示意图来演示一下HashMap的数据结构\r\n![HashMap数据结构图示](http://bolinyoung.qiniudn.com/hashmap.png)\r\n这里Hash数组的大小为5，每个Hash数组中的元素其实就是一个链表的第一个节点，这个链表是一个不带头指针的链表。\r\n\r\n####三.HashMap死循环分析\r\n我们在上面也提到过，当Hash表中的元素超过一定数量后，会触发rehash的过程，所谓rehash就是把原来Hash表中的元素基于一个新大小的Hash数组再重新映射一遍，以保证查询效率在O(1)时间范围内，所谓HashMap的死循环就是在并发rehash的过程中造成的。下面我们先看看HashMap并发rehash的过程，如下图所示:\r\n\r\n![HashMap的rehash过程](http://bolinyoung.qiniudn.com/htransfer.png)\r\n\r\nrehash的过程很简单，遍历老的Hash数组table,把Hash数组中的每个元素基于新的Hash数组重新计算一下Hash函数的值，在新的Hash数组中找到相应的位置，把这个值插入到对应链表的第一个节点处，3,4,5处的代码就是做这个事情的，把新来的节点插入到新表i位置对应链表的头部。\r\n\r\n下面假设有两个线程同时进入transfer方法中，目前Hash数组大小为2,假设使用的Hash函数是key mod Hash数组的长度，数组中元素的分布为：\r\n![Hash数组中元素的分布](http://bolinyoung.qiniudn.com/1.png)\r\n\r\n假设此时Hash表中的元素数目超过了规定的值，因此会触发rehash的过程，此时Hash数组大小会翻倍。我们先看看单个线程rehash过程是怎么发生的，如下图所示:\r\n\r\n* 进入while循环后，我们先看看e和e.next的指向\r\n![e和e.next的指向](http://bolinyoung.qiniudn.com/hashInit.png)\r\n\r\n* while循环一次后，观察老数组和新数组中的元素分布，以及e和e.next的指向\r\n![第一次while循环](http://bolinyoung.qiniudn.com/whilefirst.png)\r\n\r\nwhile循环发生一次后，key=3的节点从老表中摘除下来，同时老表的第1个元素值被设置为null,然后重新在新表中根据Hash函数寻找新的位置，把这个元素插入，同时e和e.next继续向下移动，这个是传统的链表移动方式，很好理解。\r\n\r\n* while循环第二次后\r\n![第二次while循环](http://bolinyoung.qiniudn.com/whilesecond.png)\r\n此时key=7的节点从老表中移动到新表。\r\n\r\n* while循环第三次后\r\n![第三次while循环](http://bolinyoung.qiniudn.com/whilelast.png)\r\n\r\n经过三次while循环后，正常的rehash过程就完成了，这里也不会出现任何问题。\r\n\r\n接下来我们看看两个线程并发执行transfer方法的后果：\r\n我们假设线程一在执行\r\n```java\r\nEntry<K,V> next = e.next;\r\n```\r\n时由于某种原因挂起了。此时线程一的上下文如下图所示:\r\n![线程一的上下文](http://bolinyoung.qiniudn.com/hashInit.png)\r\n线程二进入后，正常执行，并且执行结束，结束后Hash表的中数据分布如下：\r\n![线程二执行完后的数据分布](http://bolinyoung.qiniudn.com/hashmapthread2.png)\r\n线程一在挂起的时候，e指向了key=3的数据节点,e.next指向了key=7的数据节点，但是线程二执行结束后，key=3的数据节点下一个数据节点不再是key=7这个数据节点了。\r\n此时线程一开始执行，经过一次while循环后如下图所示:\r\n![线程一执行第一次while循环后](http://bolinyoung.qiniudn.com/thread1while1.png)\r\n\r\n按照链表的遍历规则，当前的e.next就是下一轮循环的e,因此在本次循环结束后出现了e指向key=7的节点，e.next指向了key=3的节点。\r\n\r\n此时再进行第二次循环，把e所指向的节点key=7插入到thread1中Hash表中,如下图所示:\r\n![线程一执行第二次while循环后](http://bolinyoung.qiniudn.com/thread1while2.png)\r\n\r\n注意理解这里e和e.next的移动\r\n\r\n此时再进行第三次循环，把e所指向的key=3的节点插入到线程一中的Hash表中，同时修改key=3节点的next指向，如下图所示：\r\n![线程一执行第三次while循环后](http://bolinyoung.qiniudn.com/thread1while3.png)\r\n\r\n此时就可以看到出现了一个环，这就是后续死循环出现的根本原因，此时要是get(15)立马出现死循环,CPU的load不断彪高,此时重启应用后load就会正常，记得在有应用有问题的保留线程，包括线程堆栈和内存堆栈。\r\n\r\n####四.总结\r\n关于HashMap死循环的问题，表面上看起来很复杂，其实只要自己动手画画图，还是很好理解的，这里涉及不带头节点链表的遍历操作。JVM中的线程共享主内存，同时又有各自私有的本地内存，当线程自己的操作完成后，就会把本地内存中的值刷回到主内存，这样就会导致在并发情况下面，各个线程从主内存中读取到值不一样，因此就需要同步操作来保证个各个线程从主内存中读取到的值都是一样的。如下图所示:\r\n![线程内存示意图](http://bolinyoung.qiniudn.com/thread.png)\r\n\r\n","mtime":1399101137000,"source":"source/_posts/hash-map-infinite-loop.md","_id":"mpjzb5ueiaifcm7m"},"b06bcgvvce6xelf1":{"content":"title: FutureTask\ndate: 2014-05-31 20:18:57\ntags: [JAVA,并发]\ncategories: 编程开发\n---\n\n在juc的包中有这么一个类FutureTask,我们可以直接用来创建一个该类的实例，然后调用run方法，最后调用get来获取线程的执行结果。\n\n<!-- more -->\n\n看看FutureTask相关的类图\n\n![FutureTask相关的类图](http://bolinyoung.qiniudn.com/futuretask.png)\n\nRunnableFuture一个核心的接口，该接口是Runnable和Future的合体。当然我们也可以创建一批FutureTask然后submit到一个线程池中。\n\n之前不了解juc中的FutureTask这个类，今天看书的时候发现了这个类，算是做个笔记。在以后的开发过程中，需要注意FutureTask这个类的灵活使用。\n","mtime":1401539131000,"source":"source/_posts/futuretask.md","_id":"b06bcgvvce6xelf1"},"qjee4qyn29ygzuz7":{"content":"title: guava中的Multimap\ndate: 2015-04-12 14:32:31\ntags: guava\ncategories: 编程开发\n---\n\n####一.概述\n我们在日常开发过程中都会使用Map这个数据结构，使用这个数据结构能够很方便维护一些映射关系，有时候，我们存储的结构是Key-Collection的映射关系，关于这个映射关系调用put方法的时候，我们需要先调用get方法，然后看看对应的Key是否在当前映射关系中已经存在Collection，如果不存在，我们直接忘Collection中增加一个元素，不存在我们需要手动去创建，然后在往我们手工创建的Collection中增加一个元素，最后再把这个Collection写入我们的Map中，很麻烦。对于C++ STL有过了解的人都知道，STL中有一个Multimap这个数据结构，该数据结构能方便地解决上面映射关系的问题。但是JDK本身不存在这样的数据结构。。。好在guava这个开源的二方库中自己定义了这个容器，该容器既能维护好Key-Collection这个数据结构，也能很方便往这个数据结构中写数据。\n\n<!-- more -->\n\n####二.Multimap数据结构\n![Multimap](http://bolinyoung.qiniudn.com/key-collection.png)\n\n####三.如何使用\n```java\npublic class MultimapTest {\n    public static void main(String[] args) {\n        Multimap<String, Integer> multimap = HashMultimap.create();\n        multimap.put(\"A\", 1);\n        multimap.put(\"A\", 2);\n        \n        System.out.println(multimap.get(\"A\"));\n    }\n}\n输出结果：\n[1, 2]\n```\n关于上述代码，我们看到我们的操作很简单，并不需要开发工程师自己去创建一个Collection，然后把这个Collection在手工写入Map中去。\n\n####四.总结\n可能很多工程师自己愿意创建Collection，并且自己写到Map中去，但是这个维护起来很不好维护，其实想想自己创建Collection并且写到Map中，也是一件很麻烦的事情，从此以后对于Key-Collection这种数据结构，直接走Multimap。","mtime":1428821910000,"source":"source/_posts/guava-multimap.md","_id":"qjee4qyn29ygzuz7"},"893nq48f00fxc8nd":{"content":"title: HBase理解\ndate: 2014-04-09 19:25:55\ntags: HBase\ncategories: 大数据\n---\n###一.概述\n在互联网应用中，经常需要存储大量的用户数据，然后对这些数据进行加工，分析最终产出对用户有价值的数据，关于数据的存储，我们可以选择文件，缓存以及数据库等，在数据库我们经常使用关系型数据库(mysql,oracle等)来存储，当数据达到一定量就需要进行分表分库，以便提高数据库的查询效率，例如在mysql中当表记录行数超过400万的时候，通常就需要分表。但是如果我们存储数据的时候选择的是HBase，这时候就不用分表，HBase中的表可以支撑上亿行，上百万列，这些数据最终存储都是分布在多台机器上的，因此HBase可以存储大量的数据，但是HBase就不具备关系型数据库的关联查询，就是说在HBase中不存在表和表的JOIN查询，关系型的查询是关系型数据库天生的优势，这样在HBase中存储的数据一定是一些弱关系的数据，要是数据之间有很强的关系，那就不太适合存储在HBase中了。\n\n<!-- more -->\n\nHBase中表的Schema很灵活，每行记录的列数都可能不一样，第m行的有x列，第n行有y列，不像关系型数据库，第m行和第n行必须有相同的列数。在定义HBase表Schema的时候，我们不需要指定这张表有多少列，列的增加和删除都是动态的。\n\n关系型数据库数据的存储是面向行的，HBase数据的存储是面向列，在HBase中存储数据的时候都是以K/V的形式存储的，一行HBase的记录对应存储层的多条K/V的记录。\n\n###二.HBase相关概念\n\n* 表\n和关系型数据库一样，存储数据到HBase的时候先要建立一张表\n* 列族\nHBase中每张表都是有1个或者多个列族组成的，每张表至少要有1个列族\n* 列\n在关系型数据库中列是直接属于表的，但是在HBase中列是和列族关联在一起的，一个列族下面可以有多个列\n* rowkey\n在HBase中每行记录都和一个rowkey关联，这个rowkey决定了记录存储在什么地方，在获取记录的时候通常需要指定一个rowkey或者rowkey相关的数据，这样就能定位到在那台机器上获取数据了，在存储数据的时候，都是按照rowkey的字典序来存储的\n* timestamp\n在HBase中，每个列的数据可以存储多个版本，这个timestamp就是用来标识数据存储写入HBase时的时间戳\n* version\nHBase中每个列存储数据的时候，默认存储三个版本的数据，每个数据都有一个版本号，这个版本号可以让HBase自动来生成，也可以自己指定。\n* TTL\ntime-to-live,HBase中列的数据都有一定的过期时间，当超过这个时间后，这个数据就会自动被HBase删除\n* cell\nHBase中数据存储的最小单元，这个单元包含了列名，列的值，时间戳，版本，列族以及rowkey\n\n在HBase中，可以有多张表，每张表有多个列族，一个列族中可以有多个列，每个列可存储多个版本的数据。因此对于某张表某一列族下面的一行记录，我们可以抽象出这样的数据结构\n    \n    SortedMap<RowKey,List<SortedMap<Column,List<Value,Timestamp>>>\n    \n注意:\n1.存储的时候首先按照rowkey进行排序，一个rowkey会关联多个列，多个列存储的时候按照列名的字典序排列。\n2.由于HBase中存储了多个版本的数据单元，因此HBase中就没有真正意义上的数据更新，所有的更新都是插入，超过数据单元的版本数目后，老的数据自动被剔除。\n\n####三.HBase数据存储理念\n我们创建HBase表的时候，只要需要指定表名和列族即可，不用特意去指定某个特定的列族下面有多少列，如下图所示:\n![HBase建表](http://bolinyoung.qiniudn.com/company.png)\n\n建完表后，我们可以使用describe命令来查看我们刚才所建立的表。前面我们已经说过HBase在数据存储的时候是面向列存储的，而mysql在存储数据的时候是按照行存储的。我们可以使用scan命令来查看表中的数据(自己完可以这么搞，但是线上千万别用scan乱来)，如下图所示:\n![HBase数据存储](http://bolinyoung.qiniudn.com/store.png)\n\n通过上图我们可以看到HBASE_PUT_ROW_KEY_A所在的行有4列数据，即COL_NAME_A,COL_NAME_B,COL_NAME_C,COL_NAME_D。HBASE_PUT_ROW_KEY_B所在的行有两列数据既COL_NAME_A,COL_NAME_D。HBASE_PUT_ROW_KEY_C所在的行有两列数据，即COL_NAME_B和COL_NAME_C。HBASE_PUT_ROW_KEY_D所在的行也有两列数据，既COL_NAME_B和COL_NAME_C，假如我们把这样的数据存储在mysql后会出现下面的存储视图:\n![HBase存储转换成mysql存储试图](http://bolinyoung.qiniudn.com/htable.png)\n\n这样的存储视图出现在mysql中会造成两个问题：\n\n* 上图已经很清楚描述了存储格局，明显出现有些数据单元被浪费掉了。\n* 要是在来一行数据，这行数据需要有五列，这时mysql表就满足不了，需要重新修改表结构才能满足这样的存储需求。\n\n在HBase中存储是面向列进行存储的，因此上面的存储格局不会出现存储单元的浪费，同时HBase表的列是可以动态增加的，因此也不用担心多出四列的行没法存储的问题。其实可以这么说，正是由于HBase的存储理念是面向列的存储，才导致HBase中表schema非常灵活，列可以动态增加和删除。\n","mtime":1398140983000,"source":"source/_posts/hbase-idea.md","_id":"893nq48f00fxc8nd"},"pokm9aa8k7flbv2i":{"content":"title: HBase的基础类型KeyValue\ndate: 2014-07-20 16:22:39\ntags: HBase\ncategories: 大数据\n---\n\n####一.概述\nHBase是面向列的存储数据的，最终的存储单元都是KeyValue的结构，HBase本身也定义了一个KeyValue的类型，这是HBase数据存储的基本类型。那么KeyValue本身会存储那些信息呢？\n\n<!-- more -->\n\n从名字来看应该只有两个数据，一个是Key,一个是Value,的确如此，不过这里的Key是多个元素的聚合，有rowkey,列族，列名，时间戳以及key的类型，key的类型定义如下\n\n```java\n  public static enum Type {\n    Minimum((byte)0),\n    Put((byte)4),\n\n    Delete((byte)8),\n    DeleteColumn((byte)12),\n    DeleteFamily((byte)14),\n\n    // Maximum is used when searching; you look from maximum on down.\n    Maximum((byte)255);\n    ....\n  }\n```\n\n####二.KeyValue结构概述\n![HBase的KeyValue](http://bolinyoung.qiniudn.com/HBase-key-value.png)\n\nHBase的KeyValue内部维护着一个字节数组，然后通过不同的偏移量来获取不同的部分，前面说过KeyValue本身就两部分，Key&&Value,因此KeyLength标识KeyValue中Key在字节数组中所占的长度，ValueLength标识Value在字节数组中所占的长度。观察上图，我们看到从RowLength到KeyType都是KeyValue这个基本类型的Key,我们来看一下这个Key中包含那些东西，RowLength即rowkey的长度，RowKey即rowkey的内容，ColumnFamilyLength即列族的长度，ColumnFamily即列族的内容，ColumnQualifier即列的名称，TimeStamp即时间戳，KeyType即Key的类型，前面已经介绍过。\n\n我们看到从ColumnQualifier开始内容前面不在带有长度了，关于TimeStamp和KeyType很好理解，因为他们所占的字节数目是固定，时间戳是一个long型的数字，占固定、字节数目，KeyType看其定义就能知道占1个字节，此时就剩下ColumnQualifier了，列名所占的字节数目计算一下即可，KeyLength-RowLength-ColumnFamilyLength即可，其中TimeStamp以及KeyType所占的字节长度不计算到KeyLength中，虽然他们是Keyalue中key的一部分，原因就是他们的长度固定，没有必要单独表示。\n下面我们看看KeyValue中计算列名所占字节数目的代码\n```java\n  // 字节数组中用固定长度的字节数目表示内容所占的字节数目\n  public static final int KEY_INFRASTRUCTURE_SIZE = ROW_LENGTH_SIZE\n      + FAMILY_LENGTH_SIZE + TIMESTAMP_TYPE_SIZE;\n      \n  ......\n  /**\n   * @return Qualifier length\n   */\n  public int getQualifierLength() {\n    return getQualifierLength(getRowLength(),getFamilyLength());\n  }\n\n  /**\n   * @return Qualifier length\n   */\n  public int getQualifierLength(int rlength, int flength) {\n    // KeyLength-表示长度的字节数目-rowKeyLength-familyLength即列名所占的字节数目\n    return getKeyLength() -\n      (KEY_INFRASTRUCTURE_SIZE + rlength + flength);\n  }\n```","mtime":1405849097000,"source":"source/_posts/hbase-keyvalue-type.md","_id":"pokm9aa8k7flbv2i"},"uqdtqhnu8or79u6w":{"content":"title: JAVA代码中如何感知到JVM退出\ndate: 2014-06-19 22:42:58\ntags: JAVA\ncategories: 编程语言\n---\n\n####一.需求\n当JVM退出的时候，把内存中的某块数据写入到DB。分析这个需求，我们需要让应用感知到JVM准备退出了，然后把数据写入DB，然后JVM继续执行退出...\n\n<!-- more -->\n\n####二.实现\n* 基于Spring的DisposableBean接口来实现\n我们只要在自己的应用编写一个bean,实现DisposableBean这个接口中的destroy方法，然后在destroy方法中编写清理逻辑即可。要是我们不给Spring容器注册这样一个JVM关闭的钩子，JVM关闭的时候destroy方法同样不会被调用。\n\n```java\nConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"....xml\");\n// 注册JVM关闭时回调的钩子到Spring容器\nctx.registerShutdownHook();\n```\n必须在应用中给Spring容器注册这样关闭钩子，负责bean的destroy方法在JVM退出的时候是没法调用的。\n\n另外，如果我们的应用是一个web应用，我们在停止web应用是，该应用中实现了DisposableBean这个接口的bean的destroy方法也会被调用，这个被调用的原因不是由于创建Spring容器时注册了关闭JVM回调的钩子，而是因为关闭web应用时会回调ServletContextListener的contextDestroyed方法，ServletContextListener的实现类是ContextLoaderListener，contextDestroyed的实现如下\n\n```java\npublic class ContextLoaderListener implements ServletContextListener {\n    private ContextLoader contextLoader;\n    ...\n\tpublic void contextDestroyed(ServletContextEvent event) {\n\t\tif (this.contextLoader != null) {\n\t\t    //  关闭Spring容器\n\t\t\tthis.contextLoader.closeWebApplicationContext(event.getServletContext());\n\t\t}\n\t}\n    ...\n}\n```\n我们再看看ContextLoader的closeWebApplicationContext方法实现\n\n```java\npublic class ContextLoader {\n    //....\n\tpublic void closeWebApplicationContext(ServletContext servletContext){\n\t\tservletContext.log(\"Closing Spring root WebApplicationContext\");\n\t\ttry {\n\t\t\tif (this.context instanceof ConfigurableWebApplicationContext){\n\t\t\t    // 销毁servlet的上下文，调用Spring容器的close方法\n\t\t\t    ((ConfigurableWebApplicationContext) this.context).close();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t    // ...\n\t\t}\n\t}\n\t//...\n}\n```\n\n因此web应用中不需要给Spring容器注册JVM关闭的钩子，代码中依然能够感知到JVM的关闭。\n\n* 直接基于Runtime的addShutdownHook方法来实现\n\n```java\nRuntime.getRuntime().addShutdownHook(new Thread(){\n\n    @Override\n    public void run() {\n        System.out.println(\"JVM EXIT...\");\n    }\n});\n```\nJVM退出的时候会回调我们注册的这个钩子，Spring注册JVM关闭的回调也是这么搞的，具体AbstractApplicationContext.java中源代码如下。\n\n```java\npublic class AbstractApplicationContext extends DefaultResourceLoader\n\t\timplements ConfigurableApplicationContext, DisposableBean {\n\t....\n\t\t/**\n\t * Register a shutdown hook with the JVM runtime, closing this context\n\t * on JVM shutdown unless it has already been closed at that time.\n\t * <p>Delegates to <code>doClose()</code> for the actual closing procedure.\n\t * @see java.lang.Runtime#addShutdownHook\n\t * @see #close()\n\t * @see #doClose()\n\t */\n\tpublic void registerShutdownHook() {\n\t\tif (this.shutdownHook == null) {\n\t\t\t// No shutdown hook registered yet.\n\t\t\tthis.shutdownHook = new Thread() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tdoClose();\n\t\t\t\t}\n\t\t\t};\n\t\t\tRuntime.getRuntime().addShutdownHook(this.shutdownHook);\n\t\t}\n\t}\n\t....\n}\n```\n\n####三.总结\n* 回调思想\n回调也是实现程序解耦的一种思路，在平时开发的过程中要注意回调的使用，回调的调用面向接口，回调的实现交给第三方来实现，我们也可提供缺省的回调实现。\n\n* 可扩展性\n自己实现的框架或一定要提供可扩展的地方，方便满足别人个性化的一些需求。","mtime":1404138616000,"source":"source/_posts/how-to-aware-jvm-exit.md","_id":"uqdtqhnu8or79u6w"},"albt2w7uca1g42aj":{"content":"title: 如何编写maven的helloworld插件\ndate: 2014-06-04 20:32:22\ntags: maven\ncategories: 开发工具\n---\n\n####一.概述\nmaven提供了一套插件机制，我们只要按照maven定义的规范编写一个插件，maven就能运行我们的插件，在平时开发的过程中我们经常会开发一些maven的插件工具，这写插件工具可以实现类冲突检测，工程部署，工程打包...等等。这里就大致记录一下如何编写一个maven的Hello Word插件，就是说在maven编译的过程中输出Hello Word。\n\n<!-- more -->\n\n####二.如何编写maven插件\n1.执行下面的maven命令,生成一个maven的插件工程\n```\nmvn archetype:create -DgroupId=com.alibaba.maven -DartifactId=maven-hello-plugin -DarchetypeArtifactId=maven-archetype-mojo\n```\n-DgroupId和-DartifactId就不用多解释了，插件本身也是一个二方库，二方库需要坐标，这样别人才能依赖。\n-DarchetypeArtifactId=maven-archetype-mojo 创建maven插件工程的时候必须指定这个参数，参数值也需要写成上面这样。\n\n2.进入插件工程所在的目录,并把插件工程变成一个eclipse可识别的工程，然后导入eclipse进行开发。\n```\ncd maven-hello-plugin\nmvn eclipse:clean eclipse:eclipse\n```\n\n3.在eclipse中开发，编写下面的类\n```java\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\n\n/**\n * @goal helloworld\n */\npublic class MyMojo extends AbstractMojo {\n\n    /**\n     * @parameter expression=\"${helloworld.words}\" default-value=\"Hello World!\"\n     */\n    private String words;\n\n    public void execute() throws MojoExecutionException {\n        getLog().info(words);\n    }\n}\n```\n4.在插件的目录下面执行\n```\nmvn clean install\n```\n把这个插件install到本地的maven仓库中\n5.插件的运行\n```\nmvn com.alibaba.maven:maven-hello-plugin:1.0-SNAPSHOT:helloworld\n```\n输出: Hello World\n```\nmvn com.alibaba.maven:maven-hello-plugin:1.0-SNAPSHOT:helloworld -Dhelloworld.words=\"welcome!\"\n```\n输出: welcome\n\n####三.注意点\n* maven2中插件参数的注入都是通过javadoc的，使用的Plexus\n* 每个maven插件都是一个MOJO,我们自己的MOJO必须extends AbstractMojo,同时我们需要重写execute方法\n* getLog()实际上是maven编译时信息输出的地方\n* 对于maven这种插件的设计理念可以在平时开发的过程中借鉴","mtime":1402151693000,"source":"source/_posts/how-to-dev-maven-hello-world-plugin.md","_id":"albt2w7uca1g42aj"},"gx8wk39whfti7rao":{"content":"title: GIT常用命令总结\ndate: 2015-04-26 14:27:34\ntags: git\ncategories: 开发工具\n---\n####一.概述\n最近有个项目分支使用了git托管代码，虽然之前在github上托管过很多代码，但是对git本身的使用以及特性也没有太多的深入的了解，最近使用git出现了一个问题，查到最后是环境问题，很悲摧，为了避免悲剧再次出现，就看了一遍git相关的所有常见命令以及一些git的设计思想，比如工作区，暂存区，本地仓库等等，也算是对平时编写代码思路的一种启发。很多人都说git是分布式的，svn不是分布式的，那么git分布式到底体现在哪里，每个人本地都有一个完整的仓库吗？难道svn每个人本地的代码就不是完善的吗？关于git分布式，我们从下面几个点来解释：\n\n<!-- more -->\n\n* 1.每个人都可以在本地管理代码的变更，而不像svn如果svn中心挂了，本地代码的管理就无法实现。\n* 2.使用git人人都可以成为中心，而不像svn中心有且只有1个，中心挂了，只能坐等中心恢复，不然两个开发之间的代码就没法相互感知到。但是git可以在某个中心挂了之后，其他人能快速成为中心。\n* 3.github的fork功能就一个分布式的典型例子，比如作者A拥有一个仓库repo，此时开源爱好者m对这个repo很感兴趣，想贡献一些代码，因此m就去fork了repo仓库，此时开源爱好者n也知道了这个事情，n和m一起基于fork出来的repo1来贡献代码，此时有两个仓库，一个是repo一个是repo1，repo挂掉不影响repo1，repo1挂掉不影响repo，等m和n都开发结束了，就提交分支合并请求到A那边，A觉得没啥问题就合并代码到repo仓库。\n\n\n\n####二.命令\n基于命令维度总结了一下git的一些常用命令\n![GIT-COMMAND](http://bolinyoung.qiniudn.com/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.bmp)\n\n","mtime":1430030996000,"source":"source/_posts/git-command.md","_id":"gx8wk39whfti7rao"},"1zhe8db0aetwv5q4":{"content":"title: 如何获取当前JAVA进程的PID\ndate: 2014-06-14 09:24:39\ntags: JAVA\ncategories: 编程开发\n---\n\n####一.需求\n如何在JAVA代码中获取当前运行JAVA进程的进程ID，通常我们可以在JVM外部执行jps命令看到某一JAVA进程的PID，但是如何在JVM内部获取这个PID呢？\n\n<!-- more -->\n\n####二.实现\n```java\n/**\n * 获取java进程PID\n * \n * @return\n */\npublic static int getPID() {\n    String rtName = ManagementFactory.getRuntimeMXBean().getName();\n    int index = rtName.indexOf(\"@\");\n    if (index != -1) {\n        return Integer.parseInt(rtName.substring(0, index));\n    }\n\n    return -99;\n}\n```","mtime":1402709297000,"source":"source/_posts/how-to-get-java-pid.md","_id":"1zhe8db0aetwv5q4"},"b3gcr902soly2rv3":{"content":"title: 如何在本地通过eclipse来调试HBase的源代码\ndate: 2014-06-07 22:36:16\ntags: HBase\ncategories: 大数据\n---\n\n####一.概述\n要想把HBase的源代码梳理清楚，需要在本地调试一下，可能直接看代码也能搞清楚，但是调试能让我们尽快搞清楚HBase的源代码，下面就来看一下如何在eclipse中调试HBase的源代码。\n\n<!-- more -->\n\n####二.编译HBase的源代码\n\n1.HBase源代码的获取\n你可以直接从HBase的官方网站上下载HBase的包，[HBase官方地址](http://hbase.apache.org/)\n你也可以使用svn把hbase的代码签出\n```\nsvn co http://svn.apache.org/repos/asf/hbase/tags/0.94.2/ hbase_sources\n```\n\n2.HBase源代码的编译\n进入到HBase代码的目录下面，执行下面的命令\n```\nmvn clean install mvn clean install -DskipTests\nmvn eclipse clean eclipse:eclipse\n```\n执行完上面的命令后，就把HBase的源码导入到eclipse中去。在执行maven命令的时候注意使用maven包自带的settings.xml，不要使用其他settings.xml文件，会导致编译不过的。\n\n3.在eclipse中做相关的设置\n\n在eclipse的Run Configurations中设置启动类\n![设置启动类HMaster](http://bolinyoung.qiniudn.com/hbase-start.png)\n\n在eclipse的Run Configurations中设置启动参数\n![设置启动参数](http://bolinyoung.qiniudn.com/hbase-start-args.png)\n\n在eclipse的Run Configurations中把conf文件放到classpath中\n![把conf文件放到classpath中](http://bolinyoung.qiniudn.com/hbase-start-conf.png)\n\n4.点击Run运行\n出现了下面的错误\n![xml版本校验出错](http://bolinyoung.qiniudn.com/hbase-xml-version.png)\n观察出错日志，显示hbase-default.xml版本校验出错，搞不定，搜一把，有人说在hbase-site.xml增加下面的配置项\n```xml\n<property>\n\t<name>hbase.defaults.for.version.skip</name>\n\t<value>true</value>\n\t<description>\n\t\tSet to true to skip the 'hbase.defaults.for.version' check.\n\t\tSetting this to true can be useful in contexts other than\n\t\tthe other side of a maven generation; i.e. running in an\n\t\tide. You'll want to set this boolean to true to avoid\n\t\tseeing the RuntimException complaint: \"hbase-default.xml file\n\t\tseems to be for and old version of HBase (@@@VERSION@@@), this\n\t\tversion is X.X.X-SNAPSHOT\"\n\t</description>\n</property>\n```\n索性试一下，此错误消失了，又来一错误\n![HBase ZK ERROR](http://bolinyoung.qiniudn.com/hbase-zk-error.png)\n这个错之前遇到过是由于zookeeper没启动导致，一直以为运行HMaster类，会自己启动zookeeper，所以一直在网上找答案，结果找到的答案都是错的，于是怀疑zookeeper在自己的电脑上压根就没有启动起来,所以需要想办法在本地启动zookeeper，我们看到hbase源代码中有一个HQuorumPeer类，这个类就是hbase-zookeeper的启动类，该类中有一个main方法，我们在eclipse中以application的方式启动。\n![hbase zk启动类](http://bolinyoung.qiniudn.com/hbase-zk-start.png)\n把conf下面的配置文件设置到classpath中\n![设置conf到classpath](http://bolinyoung.qiniudn.com/hbase-zk-classpath.png)\n这样我们就可以在eclipse中启动zookeeper啦。接下来我们再次启动HMaster\n![启动HMaster控制台不断输出错误日志](http://bolinyoung.qiniudn.com/hbase-region-server-error.png)\n又出错了，看看错误日志，我们发现是RegionServer没有启动好，使用jps可以发现没有RegionServer的进程，虽然日志的级别是INFO的，回头一看确实没有启动过RegionServer，所以启动一下RegionServer啦，我们还是在eclipse中以application的方式去启动RegionServer\n![HBase RegionServer的启动配置](http://bolinyoung.qiniudn.com/hbase-region-server.png)\n同样需要把conf文件加入到eclipse的classpath中，方法和前面一样，这里就不用再重复了。配置好就启动,然后发现HMaster的控制台INFO级别的日志停掉了。关于这个点我们稍微再深入一些，我们刚才的场景是启动了HMaster但是没有启动RegionServer，此时HMaster的控制台一直有INFO级别的日志输出，我们看一下ServerManager这个类中输出这段日志的代码\n```java\n/**\n   * Wait for the region servers to report in.\n   * We will wait until one of this condition is met:\n   *  - the master is stopped\n   *  - the 'hbase.master.wait.on.regionservers.maxtostart' number of\n   *    region servers is reached\n   *  - the 'hbase.master.wait.on.regionservers.mintostart' is reached AND\n   *   there have been no new region server in for\n   *      'hbase.master.wait.on.regionservers.interval' time AND\n   *   the 'hbase.master.wait.on.regionservers.timeout' is reached\n   *\n   * @throws InterruptedException\n   */\n  public void waitForRegionServers(MonitoredTask status)\n  throws InterruptedException {\n    final long interval = this.master.getConfiguration().\n      getLong(WAIT_ON_REGIONSERVERS_INTERVAL, 1500);\n    final long timeout = this.master.getConfiguration().\n      getLong(WAIT_ON_REGIONSERVERS_TIMEOUT, 4500);\n    int minToStart = this.master.getConfiguration().\n      getInt(WAIT_ON_REGIONSERVERS_MINTOSTART, 1);\n    if (minToStart < 1) {\n      LOG.warn(String.format(\n        \"The value of '%s' (%d) can not be less than 1, ignoring.\",\n        WAIT_ON_REGIONSERVERS_MINTOSTART, minToStart));\n      minToStart = 1;\n    }\n    int maxToStart = this.master.getConfiguration().\n      getInt(WAIT_ON_REGIONSERVERS_MAXTOSTART, Integer.MAX_VALUE);\n    if (maxToStart < minToStart) {\n        LOG.warn(String.format(\n            \"The value of '%s' (%d) is set less than '%s' (%d), ignoring.\",\n            WAIT_ON_REGIONSERVERS_MAXTOSTART, maxToStart,\n            WAIT_ON_REGIONSERVERS_MINTOSTART, minToStart));\n        maxToStart = Integer.MAX_VALUE;\n    }\n\n    long now =  System.currentTimeMillis();\n    final long startTime = now;\n    long slept = 0;\n    long lastLogTime = 0;\n    long lastCountChange = startTime;\n    int count = countOfRegionServers();\n    int oldCount = 0;\n    while (\n      !this.master.isStopped() &&\n        count < maxToStart &&\n        (lastCountChange+interval > now || timeout > slept || count < minToStart)\n      ){\n\n      // Log some info at every interval time or if there is a change\n      if (oldCount != count || lastLogTime+interval < now){\n        lastLogTime = now;\n        String msg =\n          \"Waiting for region servers count to settle; currently\"+\n            \" checked in \" + count + \", slept for \" + slept + \" ms,\" +\n            \" expecting minimum of \" + minToStart + \", maximum of \"+ maxToStart+\n            \", timeout of \"+timeout+\" ms, interval of \"+interval+\" ms.\";\n        LOG.info(msg);\n        status.setStatus(msg);\n      }\n\n      // We sleep for some time\n      final long sleepTime = 50;\n      Thread.sleep(sleepTime);\n      now =  System.currentTimeMillis();\n      slept = now - startTime;\n\n      oldCount = count;\n      count = countOfRegionServers();\n      if (count != oldCount) {\n        lastCountChange = now;\n      }\n    }\n\n    LOG.info(\"Finished waiting for region servers count to settle;\" +\n      \" checked in \" + count + \", slept for \" + slept + \" ms,\" +\n      \" expecting minimum of \" + minToStart + \", maximum of \"+ maxToStart+\",\"+\n      \" master is \"+ (this.master.isStopped() ? \"stopped.\": \"running.\")\n    );\n  }\n```\n重点关注这段代码中的while循环，这段代码不断轮寻RegionServer数目，只有启动起来的RegionServer数目>=hbase.master.wait.on.regionservers.mintostart这个while循环才能退出，不然while循环里面就会一直输出INFO的级别的日志，说没有RegionServer启动好，其实hbase.master.wait.on.regionservers.mintostart的默认值就是1.\n\n至此，Zookeeper，HMaster，HRegionServer都已经启动好了，这里所说的HRegionServer和上面所说的RegionServer指的是同一个东西。接下来我们访问http://localhost:60010/master-status 就能看到相关的信息。\n\n这样我们就可以在本地eclipse中debug一下HBase的源代码啦^=^。\n\n####三.最后总结\n我们发现在本地部署HBase，我们需要启动三个东西，Zookeeper,HMaster以及RegionServer。\n\nzookeeper通过HMaster负责协调整个HBase集群，同时zookeeper保存了hbase中-ROOT-表的地址和HMaster的地址。HRegionServer也会把自己以Ephemeral方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的健康状态。\n\nHMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行，HMaster在功能上主要负责Table和Region的管理工作：\n1. 管理用户对Table的增、删、改、查操作\n2. 管理HRegionServer的负载均衡，调整Region分布\n3. 在Region Split后，负责新Region的分配\n4. 在HRegionServer停机后，负责失效HRegionServer 上的Regions迁移\n\nHRegionServer主要负责响应用户I/O请求，向HDFS文件系统中读写数据，是HBase中最核心的模块。\nHRegionServer内部管理了一系列HRegion对象，每个HRegion对应了Table中的一个Region，HRegion中由多个HStore组成。每个HStore对应了Table中的一个Column Family的存储，可以看出每个Column Family其实就是一个集中的存储单元，因此最好将具备共同IO特性的column放在一个Column Family中，这样最高效。","mtime":1402212657000,"source":"source/_posts/how-to-debug-hbase-source.md","_id":"b3gcr902soly2rv3"},"d65dx5r33tvvnwvv":{"content":"title: 如何使用ASMifier\ndate: 2014-07-27 13:53:45\ntags: ASM\ncategories: 编程开发\n---\n\n####一.概述\nASM这个字节码处理框架，不仅能够读字节码，而且还能修改字节码，我们经常是先写好JAVA代码，然后编译(IDE或者javac)生成class文件，最后classloader再把相应的class文件加载到内存，但是有了ASM后，我们可以直接使用ASM生成class文件的字节数组，即面向字节码写JAVA代码，这样可以让JVM动态去加载一个类，但是这个类的class文件并不存在磁盘上，也就是说这个类的class文件是在内存中构建出来的。\n\n<!-- more -->\n\n下面我们就来看看如何在内存中构造class文件的字节数组，并且让JVM动态加载对应的class.\n\n####二.如何使用\n假如我们我们需要JVM动态加载的类的源代码如下\n```\npublic class ASMTest {\n    public void hello() {\n        System.out.println(\"Hello ASM\");\n    }\n}\n```\n\n此时这类并不再当前应用所对应的classpath中。当然我们可以自己去分析这个类的字节码，然后一步一步去构造这个类的字节码，但是这样比较麻烦，ASM提供了这样一个工具，可以把一个编译过的class文件转换一段java代码，运行这段java代码可以产生这个编译过的class文件对应的字节数组。\n\n因此，我们先执行\n```\njavac ASMTest.java\n```\n生成ASMTest对应的class文件。接下来我们使用ASMifier来生成可以产生字节数组的代码\n```\njava -classpath asm-debug-all-4.1.jar:. org.objectweb.asm.util.ASMifier ASMTest > ASMTestDump.java\n```\n在执行java命令的时候我们指定了classpath,多个classpath使用冒号分隔，此时一定要保证ASMTest的所在的路径被加入到classpath中，生成的ASMTestDump类如下。\n\n```java\npublic class ASMTestDump implements Opcodes {\n\n    public static byte[] dump() throws Exception {\n\n        ClassWriter cw = new ClassWriter(0);\n        MethodVisitor mv;\n\n        cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, \"ASMTest\", null, \"java/lang/Object\", null);\n        {\n            mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n            mv.visitCode();\n            mv.visitVarInsn(ALOAD, 0);\n            mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\");\n            mv.visitInsn(RETURN);\n            mv.visitMaxs(1, 1);\n            mv.visitEnd();\n        }\n        {\n            mv = cw.visitMethod(ACC_PUBLIC, \"hello\", \"()V\", null, null);\n            mv.visitCode();\n            mv.visitFieldInsn(GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\");\n            mv.visitLdcInsn(\"Hello ASM\");\n            mv.visitMethodInsn(INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\");\n            mv.visitInsn(RETURN);\n            mv.visitMaxs(2, 1);\n            mv.visitEnd();\n        }\n        cw.visitEnd();\n\n        return cw.toByteArray();\n    }\n}\n```\n\n接下来定义自己的classloader\n\n```java\npublic class MyClassLoader extends ClassLoader {\n\n    public Class defineClass(String clazz, byte[] bytes) {\n        return defineClass(clazz, bytes, 0, bytes.length);\n    }\n}\n```\n\n使用自己的classloader加载ASMTestDump产生的字节数组,并通过反射来调用ASMTest类的Hello方法\n\n```java\npublic class ClassWriterTest {\n\n    public static void main(String[] args) {\n        MyClassLoader mycl = new MyClassLoader();\n        Class classInstance = null;\n        try {\n            classInstance =  mycl.defineClass(\"ASMTest\", ASMTestDump.dump());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        \n        if (classInstance != null) {\n            try {\n                Object oo = classInstance.newInstance();\n                Method method = classInstance.getMethod(\"hello\", null);\n                method.invoke(oo, null);\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n使用ASMifier就这么简单。\n\n####三.总结\nASMifier其实也可以认为是一个编译器，把class文件转换成java代码，这里的java代码并不是反编译后的java代码，而是一段可以生成当前class字节数组的代码，可能很多人会有以为，class文件到字节数组需要这么麻烦吗？我们直接读取class文件，然后字节转换成字节数组不就搞定了么，不用这么绕一大圈的么，关键是有时候字节码并不是存在磁盘上的，需要在内存中动态构建，如果你愿意在内存中写字节码也行。\n","mtime":1406443650000,"source":"source/_posts/how-to-use-asmifier.md","_id":"d65dx5r33tvvnwvv"},"4k04hqvdkfzqm9na":{"content":"title: 如何读懂JVM GC日志\ndate: 2014-07-01 23:55:05\ntags: JVM\ncategories: JVM学习\n---\n我们经常会在线上观察JVM运行时GC日志，其实GC日志中有很多信息可以挖掘，比如下面的GC日志信息\n\n> [GC [DefNew: 34538K->2311K(36352K), 0.0232439 secs] 45898K->15874K(520320K), 0.0233874 secs]      \n> [Full GC [Tenured: 313563K->15402K(483968K), 0.2368177 secs] \n343563K->18402K(520320K), [Perm : 28671K->28635K(28672K)], 0.2371537 secs]\n\n<!-- more -->\n\n观察上面的GC日志，我们发现出现了一次YGC和一次FGC,JVM的内存是分代的，有老年代，新生代，还有永久代。一般我们创建的对象先会进入新生代，要是经过N次YGC后，这个对象还存在，那么这个对象就晋升到老年代，这个N是可以配置的。永久代主要存储JVM字节码以及相关的类信息。\n\n* 关于YGC日志的解释：\n新生代的总大小是36352K,当新生代使用到34538K时发生了一次YGC,此时新生代的占用从34538K变到2311K，同时我们也能看到整个堆内存的变化，整个堆内存大小是520320K，当使用到45898K时发生了一次YGC,堆内存的使用由45898K变化到15874K。后面的时间是指内存回收的耗时。\n\n* 关于YGC日志的解释：\n老年代总大小为483968K，当老年代使用到313563K，发生了一次FGC,老年代的使用由313563K变到15402K。堆的总内存大小为520320K，当使用到343563K发生了一次FGC,堆内存的使用由343563K变到18402K。永久代的总大小为28672K，当永久代内存使用到28671K时发生了一次FGC，永久代使用的内存由28671K变到28635K。后面的时间表示内存回收的耗时。","mtime":1406375337000,"source":"source/_posts/how-to-read-gc-log.md","_id":"4k04hqvdkfzqm9na"},"1c4xpwp7cedd8han":{"content":"title: 如何动态修改JVM的字节码\ndate: 2015-10-13 19:13:30\ntags: JVM\ncategories: JVM学习\n---\n####一.概述\n最近在做一个需求的时候，需要在JVM启动好之后，能够动态的修改JVM已经加载的一个类的一个方法，把这个方法的返回值直接改成返回true。\n\n<!-- more -->\n\n上述需求概括为动态修改JVM字节码，我们需要借助修改字节码的工具，同时也要让启动中的JVM能感知到我们的修改，这个需要借助java的instrument。下面我们就来看一下具体的实现。\n####二.实现\n#####1.编写修改字节码的agent\n在JVM已经加载的类中找到要修改的类，然后使用javassist从磁盘上读取到要修改类的字节码，修改指定方法的返回值后，让JVM重新再加载一下我们刚才修改的这个类，具体代码如下：\nagent的代码\n```java\npublic class XxxmockAgent {\n    // 指定我们要修改字节码的类的全限定名\n    private static final String CLASS_NAME = \"xxxCommonBO\";\n    @SuppressWarnings(\"rawtypes\")\n    public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException{\n        System.out.println(\"loadagent after main...\");\n        //获取当前JVM已经加载过的所有类\n        Class[] classes =  inst.getAllLoadedClasses();\n        for (Class clazz : classes) {\n\t    //找到需要修改的类\n            if(clazz.getName().equals(CLASS_NAME)) {\n                System.out.println(\"find class \" + CLASS_NAME);\n                //按照要求字节吗\n                inst.addTransformer(new XxxCommonTransformer(), true);\n                //让JVM重新加载修改过字节码的类\n                inst.retransformClasses(clazz);\n            }\n        }\n        System.out.println(\"loadagent after main sucess...\");\n    }\n}\n```\n修改字节码的代码\n```java\npublic class XxxCommonTransformer implements ClassFileTransformer {\n\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n                            ProtectionDomain protectionDomain,\n                            byte[] classfileBuffer) throws IllegalClassFormatException {\n        String compareClass = className.replace('/', '.');\n        System.out.println(\"transformer...\" + compareClass);\n        try {\n\t    //构建javassist需要ClassPool\n            ClassPool classPool = ClassPool.getDefault();\n            //把要修改的类的classpath加入到javassist的ClassPool中\n            classPool.appendClassPath(\"/xxx/WEB-INF/lib/*\");\n            //从磁盘上读取要修改类的字节码，并且转换成javassit中的CtClass模型\n            CtClass ctClass = classPool.get(compareClass);\n            //获取需要修改的字节码的方法\n            CtMethod ctMethod = ctClass.getDeclaredMethod(\"isFromA\");\n            //修改方法体\n            ctMethod.setBody(\"return true;\");\n            //写入修改后的字节码\n            ctClass.writeFile();\n            return ctClass.toBytecode();\n        } catch (Exception e) {\n\t    e.printStackTrace();\n        }\n        return null;\n    }\n}\n```\n#####2.编写attach到JVM的client\n```java\npublic class Client {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"[usage:java -jar client-1.0.0.jar pid path] and args.lenght=\"+args.length);\n            return;\n        }\n        // 第0个参数是要attach的JVM进程ID\n        String pid = args[0];\n        // 第1个参数是agent JAR包所在的路径\n        String agentPath =args[1];\n        System.out.println(\"pid:\" + pid);\n        System.out.println(\"agentPath:\" + agentPath);\n        try {\n            attach(pid, agentPath);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void attach(String pid, String agentPath) throws Exception {\n        try {            \n            //attach到远程JVM上去\n            VirtualMachine  vm = VirtualMachine.attach(pid);\n            //加载agent\n            vm.loadAgent(agentPath);\n        } catch (RuntimeException re) {\n            throw re;\n        } catch (IOException ioexp) {\n            throw ioexp;\n        } catch (Exception exp) {\n            exp.printStackTrace();\n            throw exp;\n        }\n    }\n}\n```\n####三.注意点\n1.在编写agent的时候我们需要指定要修改的类所在的classpath，此时的类加载器是AppClassLoader，如果你要attach的JVM进程是用jetty&&tomcat等容器启动起来的，必须要指定要修改的类所在的classpath。\n2.在agent中我们使用到javassit这个开源的操作字节码的二方库，加载javassit中类的类加载器也是AppClassLoader，同样如果你的JVM进程是用jetty或者tomcat启动的话，而且你的应用中已经包含了javassit这个二方库，AppClassLoader也加载不了，会出现ClassPool加载失败的异常，此时需要我们显式地把javassit包含到agent中去，如果你的agent是使用maven构建的话，你可以使用maven-shade-plugin这个maven插件，该插件既能把依赖的jar聚合起来，也能在jar包中自动生成MANIFEST.MF。\n3.在编写client的时候我们用到了VirtualMachine这个类，这个类在tools.jar中，这个jar是jdk自己携带的。如果你是用maven来构建你的client的话，你可以用下面方式把tools.jar自动引入到你的project中。\n```xml\n<dependency>\t\t\t\t\t\n\t<groupId>com.sun</groupId>\n\t<artifactId>tools</artifactId>\n\t<version>1.6</version>\n\t<scope>system</scope>\n\t<systemPath>${JAVA_HOME}/lib/tools.jar</systemPath>\n</dependency>\n```\n4.在运行client的方式，我们通过java -jar来运行，此时需要tools.jar，如果你不想把tools.jar打包的client中，你需要在运行client JAR的时候带上tools.jar.\n```java\njava -Xbootclasspath/a:tools.jar  -jar /home/xxx/client-1.0.0.jar 22410 /home/xxx/agent-1.0.0.jar \n```\n22410是进程PID\n\n","mtime":1444740700000,"source":"source/_posts/how-to-modify-jvm-bytecode-dynamic.md","_id":"1c4xpwp7cedd8han"},"682l7wk5wojz9mjl":{"content":"title: IBatis不同版本对parameterMap的处理\ndate: 2014-07-23 19:58:04\ntags: IBatis\ncategories: 编程开发\n---\n\n####一.概述\n今天在升级一个监控的中间件时，发现必须升级ibatis的版本到2.3.4,原来ibatis的版本是2.3.0,升级后，发现sqlmap的解析出问题了，对于parameterMap这个标签解析出错，原因是parameterMap对应class没法实例化，为什么原来没有问题，升级后就有问题了呢？这时候只能怀疑版本的问题,2.3.4和2.3.0在解析parameterMap时有所不同。\n\n<!-- more -->\n\n下面是我们应用中一份sqlmap中写的parameterMap\n![parameterMap](http://bolinyoung.qiniudn.com/parameterMap.png)\n\n其实这个parameterMap在这份配置文件中压根就没有被使用过，TA-COACH-CONFIG-PARAM这个class在当前的classpath中显然不存在，同时也不是某个class在sqlmap中的别名，因此在解析的时候会报TA-COACH-CONFIG-PARAM这个class找不到。\n\n#####二.到底那里不一样\n那具体到ibatis的源代码中，那些代码发生了变更呢？我们首先找到解析sqlmap的类即SqlMapParser这个类，先看看2.3.0中这个类解析paramterMap的行为\n![2.3.0](http://bolinyoung.qiniudn.com/parameterMap230.png)\n我们看到在2.3.0这个版本中拿到parameterClassName后，尝试去实例化这个类型的实例，此时要是这个类找不到就出现Exception，但是该版本中没有处理这个异常，就是说这个异常默默地被吞了。\n\n接下来再看看2.3.4中SqlMapParser解析parameterMap的行为\n![2.3.4](http://bolinyoung.qiniudn.com/parameterMap234.png)\n其实在2.3.0中作者已经意识到这个事情了，只是写了TODO，在2.3.4中正式开始抛出异常了。\n\n综上所述：\n在ibatis的配置的文件中，要么使用类的权限定名，要么使用类的别名，要是一个class在classpath中不存在，但是你在sqlmap中使用了，你就等着翻源码查问题吧。还好上面的那个parameterMap形同虚设，我可以放心地删了它。","mtime":1406119597000,"source":"source/_posts/ibatis-version-for-parametermap.md","_id":"682l7wk5wojz9mjl"},"ppuqf1w6mfstj9le":{"content":"title: iframe在IE下面session失效了\ndate: 2014-04-19 18:13:16\ntags: web\ncategories: web开发\n---\n\n####一.问题\n记得之前做一个项目的时候，把我们自己web系统的中的一个表单提交页面嵌入到其他产品线web系统的一个页面中，在IE浏览器下面出现表单提交失败的场景，查看日志是由于csrfToken失效导致。\n\n<!-- more -->\n\n把上面的问题抽象一下，系统A中有一个页面a,以iframe的方式嵌入到系统B的b页面中，a页面中有一个form表单，此时用户访问b页面后，然后提交表单，在IE浏览器下面表单没法提交，这里的IE浏览器指所有IE系列的浏览器。\n\n####二.分析\n通过后台日志分析，发现是csrfToken失效导致，因此我们怀疑在b页面中提交表单后，session中不存在csrfToken导致，debug后事实的确如此。然后我们把a页面从b页面中剥离出来后，发现一切正常，此时只有iframe值得怀疑了，网上搜索一把，发现在IE浏览器中iframe存在session/cookie丢失的问题，因为a页面对b页面来说是第三方网站，IE限制存储第三方网站的session和cookie，当然这个限制可以在浏览器客户端进行设置，把这个限制去除掉，不过我们不能要求用户这么去做。网上搜索的结果也告诉我们相关的解决方案，需要我们在服务端设置一下Servlet的response即可，具体解决办法如下：\n```java\nhttpServletResponse.addHeader(\"P3P\",\"CP='CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR'\");\n```\n在后台java代码中获取iframe请求的response，然后增加P3P的头，关于P3P可以参考百度百科的解释，这里就不详细介绍了。\n[P3P介绍](http://baike.baidu.com/view/722330.htm)\n\n####三.聊聊CSRF攻击以及csrfToken的原理\n* CSRF攻击介绍\n下面这张图详细描述了CSRF攻击的过程\n![CSRF攻击过程](http://bolinyoung.qiniudn.com/csrf.png)\n第4第5就是所谓csrf攻击。举个简单的例子，假如xx银行提供了一个http的get请求，这个http的get请求可以修改用户银行账户余额，用户用自己的账号登录了xx银行的web系统，然后再登录一个不可信的钓鱼网站，此时这个钓鱼网站模拟用户发出一个修改用户银行余额的http请求，这样用户账户余额就被钓鱼网站给修改了，当然这只是举一个简单的例子，银行系统肯定不会这么干的，除非...此处略去N个字。\n\n* csrfToken原理\n为了防止上面描述的csrf攻击，我们可以在页面上生成一个csrfToken,然后把这个csrfToken也写入到session，浏览器发起get/post请求的时候必须要带上这个csrfToken，不然就认为请求不合法，同时要是get/post请求中带了这个token我们就去和session中存储的token进行比较，要是一致我们才做相关的事情。那么此时我们很容易想到要是钓鱼网站也知道了这个token的话，就一样可以模拟用户发起get/post请求了，不过这个token一般是很难获取到的，这个token只对用户是可见的，钓鱼网站很难获取到这个token，当然这个办法不是万能的。\n","mtime":1399101942000,"source":"source/_posts/ie-iframe-session-cookie.md","_id":"ppuqf1w6mfstj9le"},"93fzxvkusmsbbxpo":{"content":"title: 幂等性&&数据库的锁\ndate: 2014-10-07 18:52:48\ntags: Experience\ncategories: 编程开发\n---\n\n####一.幂等性\n幂等性是高等代数中的概念，这里不是讨论数学上幂等性的概念，而是讨论程序中幂等性。幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的. 声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试.\n\n<!-- more -->\n\n比如系统A提供了接口f1给系统B调用，系统B调用了系统A提供的f1接口，发现超时，然后再调用一次，超时可能是由于系统A处理的有点慢导致，此时系统A会感知到接口f1的两次调用，如果f1是给用户的账户增加10000RMB的话，这样的场景可能会导致最终给用户增加了N*10000RMB(N>1)，此时接口f1就需要做幂等性处理，不管这个请求重复调用多少次，最终只会给用户增加10000RMB，首先我们需要从业务层面去思考看能否解决这个问题，一般的业务都会根据业务逻辑推算出那些重复请求的，实在推算不出的话，我们就需要做额外的处理了，要求调用方调用f1的时候传递一个唯一性的请求标识进来，系统A感知到f1的调用后，会先查当前请求标识是否已经被接受，如果被接收的话，先看是处理中还是已经完成，如果是这两个状态中的任何一个，我们都认为是重复调用。要是查不到记当前请求被接受的记录的话，先插入一条当前请求被接受的记录，并且状态记录为处理中，然后再去处理请求，此时如果请求处理成功就把请求被接受的记录状态修改为处理成功，要是处理失败就把请求被接受的记录删除。如果处理成功就把当前请求被接受的记录状态修改为处理成功。\n\n####二.数据库锁\n我们在写代码的时候经常会遇到这样的场景，从数据库中读取一批数据出来，然后根据一些逻辑条件修改这批数据，修改完后写回到数据库中，我们读出数据进行逻辑处理时，数据库中的这些数据可能已经发生变化了。为了保证上面数据的正确性，我们需要引入数据库的锁来解决这个问题即select for update锁，先对需要修改的记录加锁，等数据库事务提交后再把锁释放，这个过程中其他对数据的修改要先拿到这个锁才能继续做写操作。\n```sql\nSELECT * FROM XXXTable WHERE conditions FOR UPDATE\n```","mtime":1412681469000,"source":"source/_posts/idempotency-and-db-lock.md","_id":"93fzxvkusmsbbxpo"},"11meiqbge30e0jls":{"content":"title: IBatis DTD 文件的转换\ndate: 2014-05-17 20:26:28\ntags: IBatis\ncategories: 编程开发\n---\n\n####一.概述\n我们经常使用IBatis这个ORM框架来操作数据库，在使用IBatis的时候我们需要编写sqlMap以及sqlMapConfig的配置文件。\n\n<!-- more -->\n\n在编写sqlMap配置文件的时候，我们需要写下面的DTD\n\n```xml\n<!DOCTYPE sqlMap PUBLIC \"-//ibatis.apache.org//DTD SQL Map 2.0//EN\" \"http://ibatis.apache.org/dtd/sql-map-2.dtd\">\n```\n\n在编写sqlMapConfig配置文件的时候，我们需要写下面的DTD\n```xml\n<!DOCTYPE sqlMapConfig PUBLIC \"-//ibatis.apache.org//DTD SQL Map Config 2.0//EN\" \"http://ibatis.apache.org/dtd/sql-map-config-2.dtd\">\n```\n\n在解析XML文件的时候，会按照上面指定的DTD对XML文件进行语法分析，看看XML文件是否有语法错误。目前解析XML文件主要有两种方式DOM和SAX,前者基于DOM树，后者基于事件以及事件的监听来解析XML文件。\n\n注意：\n在写DTD时，为了避免一些诡异问题出现，要么都使用ibatis.apache.org要么都使用ibatis.com，不要二者混合起来使用。\n\n####二.问题\nIBatis框架在解析XML配置的时候会在网上去找DTD文件吗？因为配置文件中写的是一个网络地址。\n\n如果你是实现者，你肯定不会在网上去找DTD,你必须要想办法从本地去找DTD，因为很多生产环境会有网络限制的，同时从网上去找，加载速度取决于网速。那么IBatis是怎么从本地去找的呢？\n\n####三.IBatis把网络地址转换成本地文件路径\nIBatis在解析XML配置的时候，把配置文件中的网络地址会转换成一个classpath中的文件路径，然后从classpath中加载相应的DTD文件。如下图所示\n![IBatis DTD 文件转换](http://bolinyoung.qiniudn.com/IBatisDTD.png)\n\n找找IBatis的源代码，我们就会发现IBatis二方库就中就存在sql-map-2.dtd和sql-map-config-2.dtd这两个DTD文件，同时也会把配置文件中的网络地址转换成本地文件路径。因此IBatis框架本身并不会从网络上去加载相应的DTD文件。","mtime":1400331017000,"source":"source/_posts/ibatis-dtd-convert.md","_id":"11meiqbge30e0jls"},"7i5tbnnsy4tbl51e":{"content":"title: 一台机器上面如何部署3个zookeeper的server\ndate: 2014-04-23 11:40:49\ntags: zookeeper\ncategories: 分布式\n---\n\n今天在自己的电脑上玩了一下zookeeper,这里主要记录一下安装的过程，自己对zookeeper的了解还不够，没法写一些比较深入的东西。\n\n<!-- more -->\n\n* 1.在本地建立三个文件夹，比如server1,server2,server3如下图所示\n  ![建立文件夹](http://bolinyoung.qiniudn.com/zk3files.png)\n\n* 2.在每个文件夹下面建立data,dataLog以及logs这三个文件,进入data文件，建立myid文本文件，如果data在server1下面，则在myid中写1，如果data在server2下面，则在myid中写2，如果data在server3下面，则在myid中写3。\n\n* 3.分别把zookeeper的安装配置包下载到server1,server2,以及server3三个文件夹下面，下载链接，[zookeeper](http://mirrors.hust.edu.cn/apache/zookeeper/stable/zookeeper-3.4.6.tar.gz)。\n\n* 4.解压zookeeper到server1,server2,server3三个文件夹下面，然后分别在zookeeper中conf文件夹下面增加zoo.cfg，如果是server1下面的zookeeper则zoo.cfg中的内容为\n\n```\ntickTime        =2000\ninitLimit       =5\nsyncLimit       =2\n##指定server1下面的data和dataLog文件\ndataDir         =/home/yangbolin/zookeeper/server1/data\ndataLogDir      =/home/yangbolin/zookeeper/server1/dataLog\n\n##指定自己的端口号\nclientPort      =2181\n\n###指定zookeeper集群中的其他机器\nserver.1        =127.0.0.1:2888:3888\nserver.2        =127.0.0.1:2889:3889\nserver.3        =127.0.0.1:2890:3890\n```\n如果是server2下面的zookeeper，则zoo.cfg中的内容为\n```\ntickTime        =2000\ninitLimit       =5\nsyncLimit       =2\n##指定server2下面的data和dataLog文件\ndataDir         =/home/yangbolin/zookeeper/server2/data\ndataLogDir      =/home/yangbolin/zookeeper/server2/dataLog\n\n##指定自己的端口号\nclientPort      =2182\n\n###指定zookeeper集群中的其他机器\nserver.1        =127.0.0.1:2888:3888\nserver.2        =127.0.0.1:2889:3889\nserver.3        =127.0.0.1:2890:3890\n```\n如果是server3下面的zookeeper，则zoo.cfg中的内容为\n```\ntickTime        =2000\ninitLimit       =5\nsyncLimit       =2\n##指定server3下面的data和dataLog文件\ndataDir         =/home/yangbolin/zookeeper/server3/data\ndataLogDir      =/home/yangbolin/zookeeper/server3/dataLog\n\n##指定自己的端口号\nclientPort      =2183\n\n###指定zookeeper集群中的其他机器\nserver.1        =127.0.0.1:2888:3888\nserver.2        =127.0.0.1:2889:3889\nserver.3        =127.0.0.1:2890:3890\n```\n* 5.进入server1，然后进入到zookeeper的目录下面，再进入到bin目录下面，启动zookeeper,执行下面的脚本\n\n```\n./zkServer.sh start\n\n```\n* 6.进入server2,server3把5中的事情都做一遍，这样我们自己搭建的zookeeper集群就启动好了。\n\n* 7.从server1,server2,server3中随便找一个文件夹进入，然后进入到zookeeper所在的文件夹，进入bin目录，执行下面脚本\n\n```\n./zkCli.sh\n```\n此时就可以进入到zookeeper的命令行模式，然后你就可以使用zookeeper的命令读写zk节点上的数据了。关于zookeeper的命令后面再详细介绍。\n\n这样我们就在本地建立一个zookeeper的集群，为后续的深入研究奠定了基础。\n","mtime":1402140194000,"source":"source/_posts/install-zookeeper.md","_id":"7i5tbnnsy4tbl51e"},"kat96pgccdc4li6a":{"content":"title: Java 注解总结\ndate: 2014-05-18 16:51:38\ntags: JAVA\ncategories: 编程语言\n---\n\n####一.概述\n在写JAVA代码的时候，我们经常会使用注解来简化代码，这些注解是需要我们自己定义的，当然JAVA本身也提供了一些标准注解。同时我们也建议大家在自己的代码中定义自己的注解，为了能够在代码中灵活使用注解，这里总结一下注解相关的东西。\n\n<!-- more -->\n\n####二.三种标准注解和四种元注解\n* 三种标准注解\n@Override 标识当前方法必须在父类或者接口中存在，不然会出现编译错误\n@Deprecated 标识当前类，方法或者字段已经被废弃，不建议再使用\n@SuppressWarnings 用来关闭一些警告，比如可以使用@SuppressWarnings{\"unchecked\"}来关闭类型转换的警告\n\n* 四种元注解\n元注解是用来定义注解的。\n@Target\n标识该注解可以用在什么地方，可能的ElementType如下\nCONSTRUCTOR:构造函数声明\nFIELD:字段声明\nLOCAL_VARIABLE:局部变量声明\nMETHOD:方法声明\nPARAMETER:参数声明\nANNOTATION_TYPE:注解类型声明\nTYPE:类，接口或者枚举的声明\nPACKAGE:包声明\n@Retention\n标识需要在什么级别保存注解信息，可能的RetentionPolicy如下\nSOURCE:注解被编译器丢弃\nCLASS:注解在class文件中可用，但是被JVM虚拟机丢弃\nRUNTIME:注解在JVM虚拟机中保留，因此可以通过反射获取到注解信息\n@Documented\n此注解将会包含在javadoc中\n@Inherited\n允许子类继承父类中的注解\n\n####三.注解例子\n\n* 简单注解\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport com.taobao.Constraints;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Constraints {\n    boolean primaryKey() default false;\n    boolean allowNull() default true;\n    boolean unique() default false;\n}\n```\n\n这里看到有三个方法声明，其实这三个方法都是注解的元素，不是什么方法。因此我们使用注解的时候需要指定一下元素的值，比如\n```java\n@Constraints(primaryKey = true, allowNull = false, unique = true)\n```\n* 注解中的注解\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport com.taobao.Constraints;\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n\npublic @interface DBColumn {\n    int value() default 0;\n    Constraints constraints() default @Constraints;\n}\n```\n\n在DBColumn中我们使用了另外一个注解Constraints，即所谓的注解中使用注解。在使用DBColumn这个注解的时候，我们可以这样写\n```java\n@DBColumn(value = 88, constraints=(@Constraints(primaryKey = true, allowNull = false, unique = true)))\n```\n\n在定义注解的时候，为元素提供defaultValue是一个好习惯。\n\n####四.注解的获取\n在JAVA代码中我们一般使用反射来获取注解\n```java\n// 获取类上面的注解\nClass.getAnnotations()\n// 获取字段上面的注解\nField.getAnnotations()\n// 获取方法上面的注解\nMethod.getAnnotations()\n```\n","mtime":1400638568000,"source":"source/_posts/java-annotation-summarize.md","_id":"kat96pgccdc4li6a"},"6e25fq3dayzr0557":{"content":"title: Java并发编程艺术读书笔记一\ndate: 2015-08-02 13:44:15\ntags: JAVA\ncategories: 并发编程\n---\n\n* volatile\n轻量级的同步机制，有volatile修饰的变量在进行写操作的时候会多出一条lock前缀的指令，比如lock addl $0 x 0,(%esp)。lock前缀的指令在多核处理器下面会引发下面两件事情：①将当前处理器缓存行的数据写回到系统内存。②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。③volatile写代表锁的释放，volatile读代表锁的获取。\n\n<!-- more -->\n\n* synchronized\n对于普通方法，锁是当前实例对象。对于静态方法，锁是当前类的Class对象。对于同步方法块，所示synchronized括号里面配置的对象，代码块的同步是基于monitorenter和monitorexit来实现的。\n\n* Java对象头\nsynchronized用的锁是存在JAVA对象头里面的。JAVA对象头里的Mark Word默认存储了对象的HashCode，分代年龄和锁标记。\n\n* 偏向锁\n偏向锁使用了一种等到竞争出现才释放锁的机制。它首先会暂停拥有偏向缩的线程，然后检查持有偏向缩的线程是否活着，如果线程处于不活动状态，则将对象头设置为无锁状态；如果线程仍然活着，持有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。可以通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false。\n\n* 轻量级锁\n使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁。\n\n* 重量级锁\n自旋获取锁失败，轻量级线程就会转换成重量级线程。\n\n* 总线锁\n所谓总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器请求将被阻塞住，那么该处理器可以独占共享内存。\n\n* ABA问题\n如果一个变量的值从A变到B又变到A，此时可以通过版本来感知到这一变化，注意版本思想在实际开发工作中的灵活使用。\n\n* CAS\n在修改一个变量值的时候先判断一下变量当前的值是否和我们期望的值一样，入股一样就修改，不一样就不修改。","mtime":1439092036000,"source":"source/_posts/java-concurrent-note-1.md","_id":"6e25fq3dayzr0557"},"srevj9ugtq2l1cjr":{"content":"title: 接口中使用泛型参数的思考\ndate: 2014-05-27 20:43:57\ntags: JAVA\ncategories: 编程语言\n---\n\n今天在使用一个别人提供的接口时，发现该接口的定义如下：\n```\npublic interface xxxService<T extends BasicModel> {\n    public T getXXX();\n    public T countXXX();\n}\n```\n\n<!-- more -->\n\n看到上面的接口，我们发现这个接口需要一个泛型参数，同时这个泛型参数必须是BasicModel或者BasicModel的派生类型。同时我们也应该想到xxxService可能会有多种实现，因为不同的泛型参数对应不同的实现。比如\n```java\npublic class xxAServiceImpl implements xxxService<A extends BasicModel> {\n    public A getXXX() {\n        A a = xxx;\n        ...\n        return a;\n    }\n    public A countXXX() {\n        A a = xxx;\n        ...\n        return a;\n    }\n}\n```\n\n```java\npublic class xxBServiceImpl implements xxxService<B extends BasicModel> {\n    public B getXXX() {\n        B b = xxx;\n        ...\n        return b;\n    }\n    public B countXXX() {\n        B b = xxx;\n        ...\n        return b;\n    }\n}\n```\n\n这样可以提供不同粒度的服务化接口的实现，但是有一个统一定义的地方，可以说这个泛型的接口是一个高度的抽象。\n\n此时你可能会考虑到Spring的注入，针对这种泛型接口，Spring的注入也没有啥问题，基于上面的实现，我们可以写下面的spring配置文件\n```xml\n\t<bean id=\"xxAService\" class=\"xx.xx.xxAServiceImpl\" />\n\t<bean id=\"xxBService\" class=\"xx.xx.xxBServiceImpl\" />\n```\n此时我们要是在其他类中按照名称注入这两个bean\n```java\npublic class xxxService {\n    private xxxService<A> xxAService;\n    private xxxService<B> xxBService;\n    // 这里省略setter方法，或者你可以使用@Resource(name=\"xxx\")来按照名称注入\n}\n```\n这样注入是没有任何问题的。\n但是要是想按照类型注入，那就出现注入不了的问题\n```java\npublic class xxxService {\n    @Autowired\n    private xxxService<A> xxAService;\n    @Autowired\n    private xxxService<B> xxBService;\n}\n```\n此时xxAService和xxBService在Spring容器中的类型都是xxxService，因此注入的时候会报错，说找不到唯一可注入的bean。\n\n因此带有发泛型参数的bean在Spring中没法按照类型注入，只能按照name注入，泛型参数经过javac后被擦除掉了，因此Spring也没法区分这二者的类型。\n\n看到extends，我们也能想到super, ？ super T也是一个类型，这个类型要么是T要么是T的超类。\n\n","mtime":1401197833000,"source":"source/_posts/java-generic-extends.md","_id":"srevj9ugtq2l1cjr"},"8t3ywoiyejs9ibm4":{"content":"title: JAVA反射调用总结\ndate: 2015-06-08 22:48:54\ntags: JAVA\ncategories: 编程开发\n---\n\n####一.概述\n这几天一直在忙于一个框架的开发，我们的初衷是基于配置产出业务数据，不要让开发工程师去编写JAVA代码来产出账单，一开始觉得这件事情很难，很难做到不开发JAVA代码，事实确实如此，不过数据如果规整的话，基于配置完全可以，一行java代码都不用写。当然这个框架目前还在测试中，核心功能已经开发结束了，开发一个框架和开发一个业务功能要考虑的事情完全不一样，在开发框架之前，需要把所有可能出现的需求都要考虑一下，其实框架就是高度的抽象，我们把平时所做的一些功能逻辑梳理清楚，再上一个高度就能梳理出一个框架。在开发这个框架的过程中用到了反射，感觉JDK的反射写起来代码有点多，于是考虑用Spring框架提供反射工具类，还有木有其他处理反射调用框架或者工具呢？\n\n<!-- more -->\n\n####二.概述\n#####1.利用JDK本身的API来实现反射\n```java\nObject oo = new InnerObject();\nMethod[] methods = oo.getClass().getDeclaredMethods();\nfor (Method method : methods) {\n    if (method.getName().equals(\"test\")) {\n        try {\n            Object retValue = method.invoke(oo, null);\n        } catch (IllegalArgumentException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n一个反射调用要写这么多代码，我也是醉了。。。。\n#####2.利用Spring的工具类来实现反射\n```java\nMethod method = ReflectionUtils.findMethod(oo.getClass(), \"test\", null);\ntry {\n    Object retValue = method.invoke(oo, null);\n} catch (IllegalArgumentException e) {\n    e.printStackTrace();\n} catch (IllegalAccessException e) {\n    e.printStackTrace();\n} catch (InvocationTargetException e) {\n    e.printStackTrace();\n}\n```\n虽然木有了for循环，但是代码还是有些多，不够精简。\n#####3.利用Mirror来做反射\n```xml\n<dependency>\n \t<groupId>net.vidageek</groupId>\n \t<artifactId>mirror</artifactId>\n \t<version>1.6.1</version>\n</dependency>\n```\n```java\nObject oo = new InnerObject();\nObject retValue = new Mirror().on(oo).invoke().method(\"test1\").withoutArgs();\n```\n看看mirror是不是精简了很多呢？还是函数编程思想，这种写法在JDK8中会非常普遍。这里只是举例说明了一下方法调用，其他更多反射调用参考 [mirror](http://projetos.vidageek.net/mirror/mirror/)\n\n####三.总结\n对于一个点，多思考，寻求最简单的写法，你会有更多的收获。\n","mtime":1433776532000,"source":"source/_posts/java-reflect.md","_id":"8t3ywoiyejs9ibm4"},"v7lpw4m3pbr5t8wk":{"content":"title: Java Memory Model抽象\ndate: 2014-06-02 15:54:49\ntags: JVM\ncategories: 编程开发\n---\n\n\n####一.JVM运行时的数据区\n我们写的JAVA代码最终都会编译成字节码，然后在JVM虚拟机上运行。在运行字节码的时候，JVM需要知道要运行的字节码是什么，也就是说JVM本身需要存储字节码，那么字节码存储在JVM的什么地方呢？同时在运行字节码的时候，会产生一些运行时数据，这这些数据都存储在什么地方呢？我们new一个Object的时候，这时候我们就获得了一个对象的引用，那么这个引用指向的内存空间在哪里呢？在C/C++中我们经常使用malloc去给分派一块内存空间，然后返回一个指针，当然在JAVA中内存空间的分派也是少不了的，只不过JVM帮你分派了，你就不需要手动去分派了。\n\n<!-- more -->\n\n下面我们先看一张图，这张图描述了JVM运行时的数据区\n\n![JVM运行时的数据区](http://bolinyoung.qiniudn.com/runtimedataarea.png)\n\n上面这张图很清晰的列出来了JVM运行时数据区的划分。\n\n* 方法区\n又称perm区(永久代)，这里面主要存储一些类本身的信息，比如字节码，字面意义的常量等等，我们经常动态修改类的字节码，或者动态加载一个类，其实都是修改perm区中的内容，或者占用perm区中的空间。\n\n* 虚拟机栈\nJVM在执行字节码的时候，都是基于栈进行，读取栈顶的数据，做相关计算，然后入栈，同时还有局部变量表来配合。\n\n* 本地方方法栈\n主要指native方法的调用，使用jstack -m可以打印出native方法的调用堆栈。\n\n* 堆\n我们经常new一个Object，这个Object所占的内存空间就是从堆上分配来的。堆又被划分为新生代和老年代，这是为了支持GC的分代回收，发生在新生代是YGC,之所以有YGC是因为大数据JAVA对象都是朝生夕死的，YGC的成本低，因此执行一次YGC就能回收到这些朝生夕死对象所占的内存了。发生在老年代是FGC,要是对象在新生代存活到一定时间后，就会被转移到老年代，老年代中对象所占的内存空间要是想被回收，就只能有FGC来回收了。\n\n* 程序计数器\n这个我们经常称为PC,我们需要执行的字节码都会存储在一个数组中，PC指向一个数组下表，表示当前需要执行那个字节码，注意数组中的每个元素都是一个字节码。\n\n####二.JAVA 内存模型的抽象\nJMM是为了解决什么问题呢？\n\n* 1.线程之间的通信\n关于线程之间的通信就是线程A所产生的数据，能够被线程B感知到。\n\n* 2.线程之间的同步\n两个线程之间通常需要同步，当线程A处于某一特殊状态的时候，线程B才能够执行。\n\n下面我们先来看看JMM的抽象示意图，通过这个示意图我们来描述JMM是如何解决上面两个问题的。\n![JMM示意图](http://bolinyoung.qiniudn.com/jvmma.png)\n\n每个线程我们都抽象出一个线程本地内存来，其实这个线程本地内存物理上压根就不存在，这只是一个逻辑上的概念，那么这个线程本地内存到底是什么呢？其实就是缓存，写缓冲区，寄存器以及其他的硬件和编译器优化等。线程A和线程B的共享变量既会在主内存中中保持一份，也会在线程本地内存中保持一份，线程直接从本地内存中读写，JMM控制本地内存中的东西写到主内存。当然JMM也可以控制线程直接读写主内存，主内存中的东西线程A和线程B共享。既然JMM可以控制线程直接读取主内存，这样不管任何情况下主内存中的东西对于其他线程都是可见的，那么为什么不让JMM直接控制线程去读写主内存呢？原因很简单就是为了快，还记得硬件中的二级缓存不，就是这个道理。并不是所有的共享变量都需要在某一时刻被另外一个线程感知到的。\n\n那么上述模型是怎么解决一开始我们提出来的两个问题的呢？\n\n* 线程之间的通信\n关于线程之间的通信，看上图就很明确了，线程A和线程B通过主内存来通信，关键是线程B能否看到线程A对共享变量的真实修改吗？这个是我们写代码的时候需要注意的，比如你可以使用volatile关键字，保证每次线程的写都刷到主内存中，线程的读都从主内存中读取。\n\n* 线程之间的同步\n线程之间的同步也是基于主内存共享来实现的，在主内存中找一个共享变量X，在这个共享变量X上加上一把锁，当线程A要想执行某个同步的方法或者同步代码块的时候，需要先获取到共享变量X上的所，这时候其他线程只能等线程A把所释放后才能进执行相应的代码。线程A执行完相应的代码块后，就释放共享变量X上的锁，保证其他线程可以进入同步方法或者同步代码块。关于同步我们可以使用juc包中提供的一些类，也可以使用synchronized关键字，关于synchronized关键字是最为常见的一种同步方式，这里顺带总结一下这个关键字的作用:\n> 1.互斥，有且只能有一个线程获得锁\n> 2.获取到锁，所有共享变量从主内存中reload\n> 3.释放锁后，所有本地内存的东西flush到主内存\n> 4.静态方法上synchronized锁对象是java.lang.Class类实例，非静态方法上synchronized锁对象是当前类的对象。","mtime":1401702382000,"source":"source/_posts/java-memory-model-abstract.md","_id":"v7lpw4m3pbr5t8wk"},"p5aorgigq31is62j":{"content":"title: JAVA线程模型\ndate: 2014-07-26 19:13:14\ntags: 并发\ncategories: 编程开发\n---\n\n我们在JAVA代码中创建一个线程，这线程在系统中会经历下面5个阶段：\nNew->Runnable->Blocked->Running->Dead\n\n<!-- more -->\n\n这里我们来详细看一下这几个阶段的演变以及转换\n![线程状态转换](http://bolinyoung.qiniudn.com/java-thread-model.png)\n\n* New\n表示这个线程对象刚刚被创建，它具备线程的一些特性，但是系统没有给它分配资源。\n\n* Runnable\n表示这个线程处于就绪状态，要是能获得CPU的话，线程马上就能运行起来。\n\n* Blocked\n一个正在运行的线程由于某些原因不能继续运行，它将进入阻塞状态。比如线程对象执行suspend(),sleep()等阻塞类型的方法后，线程就会进入BlockedPool，当线程调用resume()方法或者自动苏醒后，线程会进入Runnable状态;线程因为要执行synchronized同步代码块需要获取锁，但是当前要获取的锁被其他线程所占有，此时线程会进入LockPool，要是线程获取到这把锁后，线程又会进入到Runnable状态;线程执行了某个对象的wait()方法，此时线程会进入到WaitPool，当相应对象上的notify方法被调用后，线程就会进入Runnable状态。\n\n* Running\n处于Runnable状态的线程要是能获取到CPU的话，马上就变成Running状态\n\n* Dead\n线程运行结束，或者线程被interrupt，或者线程被stop，线程的生命周期也就结束了。\n\nJVM在执行某个方法的时候，会创建一个方法执行栈帧(Frame),这个栈帧包含局部变量区和操作数栈，在局部变量区的第一个位置上存储当前方法所属的实例对象。\n\n","mtime":1406374672000,"source":"source/_posts/java-thread-model.md","_id":"p5aorgigq31is62j"},"cifnqcvgz7du4c9b":{"content":"title: Java 函数参数引用思考\ndate: 2014-04-08 22:05:56\ntags: JAVA\ncategories: 编程语言\n---\n\n###一.概述\nJava是一门纯粹的面向对象语言，除了8种基本类型意外，其他都是对象。函数是编程语言中的一个非常重要的概念，Java中的函数都不是孤立存在的，不像C或者JS你可以定义一个孤立的函数，有函数就有函数调用，在Java中函数参数就两种类型，要么函数参数是基本类型，要么函数参数是引用类型。函数调用就会涉及到的参数的传递，在Java中，参数传递就一种方式，既所谓值传递，其实就是传递变量值的拷贝，如果参数类型是基本类型，那么传递的就是基本类型参数值的一份拷贝，如果参数类型是引用类型，那么传递的就是引用值的一份拷贝，而不是引用对象的一份拷贝，其实用C语言的指针来说，传递的就是指针所指内存空间地址的一份拷贝，正所谓Java中虽然没有指针，但全是指针。\n\n<!-- more -->\n\n###二.代码实例\n```java\npublic class ParamterReference {\n    // 注意这段代码\n    public static void test(Object res) {\n        \tres = new Object();\n        \t// 这个res指向test方法中new出来的Object\n        \tSystem.out.println(res);\n    }\n    public static void main(String[] args) {\n        \tObject res = new Object();\n        \t// 此时此刻res指向main方法中new出来的Object\n        \tSystem.out.println(res);\n        \ttest(res);\n        \t// 此时此刻res指向main方法中new出来的Object\n        \tSystem.out.println(res);\n    }\n}\n```\n上面代码运行的结果如下:\n\n\njava.lang.Object@2e6e1408\njava.lang.Object@3ce53108\njava.lang.Object@2e6e1408\n\n\n我们从结果中发现main函数中两个地方打印出来的的res是一样，但是和test方法中打印的结果不一样，这说明res在main函数和test方法中指向的不是同一个java实例，用C语言的话来说，就是指向不同的内存空间。\n\n在调用test方法的时候,main函数中的res引用值被覆盖了一份保存到test函数栈帧上,此时此刻有两个函数栈帧，一个main函数的栈帧，一个test函数的栈帧，main函数中res的引用值也有两份，一个存在main函数栈帧上，一个存在test函数栈帧上，但是这两个函数对应栈帧上的值是一样的，只是由不同的变量所持有，再套用C语言中的一句话，此时此刻，就是两个不同的指针变量指向了同一块内存区域。\n\n因此，我们在test内部修改了test函数栈帧上的一个局部变量引用的值，这个局部变量在栈帧销毁之后，生命周期就结束了，因此我们在函数内部对这个局部变量值的修改不会被外部调用函数感知到。当然要是我们利用引用修改了引用所指内存空间的值，外部调用函数一定会感知到。\n###三.最后总结\n* 不要在函数内部修改引用类型参数的引用值，这个修改对外部调用者来说完全感知不到，出现这样的代码，很可能就是一个BUG。\n* 通过引用对象对引用对象所指的内存空间进行写入，这个操作一定会被外部调用者感知到。\n","mtime":1397451676000,"source":"source/_posts/java-parameter-reference.md","_id":"cifnqcvgz7du4c9b"},"zwrdwzuwou3bc5ge":{"content":"title: JAVA单元测试mock框架\ndate: 2016-07-17 10:50:10\ntags: JAVA\ncategories: 编程开发\n---\n####一.概述\n最近在做代码重构，发现系统中的UT很少，重构没有UT的话，全部得人工测试，逻辑覆盖不一定全部能覆盖到，因此UT还是很有必要存在的。在写UT的时候，mock是必须要有的，但是现在适用于java代码做单元测试的mock框架很多，我们该如何选择？\n\n<!-- more -->\n\n在做选择之前，我们先看看如何使用每个mock框架，再做决定。\n\n####二.mock框架\n为了方便描述，我们先写一个简单的测试类\n```java\npublic class MockClazz {\n\n    public String run(String name) {\n        System.out.println(name);\n        return name + \" begin run...\";\n    }\n\n    public static String sleep (String name) {\n        System.out.println(name);\n        return name + \" begin sleep...\";\n    }\n\n    private String eat(String name) {\n        System.out.println(name);\n        return name + \" begin eat...\";\n    }\n\n    public String getEatInfo(String name) {\n        return eat(name);\n    }\n\n    public final String create(String name) {\n        return name;\n    }\n}\n```\n####1.easymock\neasymock是比较早的一个mock框架，做一次mock需要先创建一个mock对象，然后录制mock代码，把mock对象切换到播放状态，执行单元测试，最后再验证mock对象是否按照录制的mock行为执行。\n引入easymock的依赖\n```xml\n<dependency>\n    <groupId>org.easymock</groupId>\n    <artifactId>easymock</artifactId>\n    <version>3.4</version>\n</dependency>\n```\n如何编写mock代码，分为五个步骤\n```java\n// ① 创建mock对象\nMockClazz mockClazz = EasyMock.createMock(MockClazz.class);\n// ② 录制mock对象的预期行为和输出\nEasyMock.expect(mockClazz.run(EasyMock.anyString())).andReturn(\"mocked string for run\");\n// ③ 将mock对象切换到播放状态\nEasyMock.replay(mockClazz);\n// ④ 调用mock对象方法进行测试\nString actualString = mockClazz.run(\"name\");\nAssert.assertEquals(\"mocked string for run\", actualString);\n// ⑤ 对mock对象的行为进行验证,验证mock的对象是否按照录制的行为发生\nEasyMock.verify(mockClazz);\n```\n这样我们就使用easymock完成了一个对象的mock测试。\n在上面的例子中，我们只mock了run这个方法，那没有被mock的方法，在调用的时候会出现什么问题？\n```java\nString eatInfo = mockClazz.getEatInfo(\"aa\");\n```\n上述代码执行的时候出现下面的异常\n><font color=\"red\">java.lang.AssertionError: \n  Unexpected method call MockClazz.getEatInfo(\"aa\"):\n  at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:44)\n\t.....\n</font>\n\t\n可见easymock如果其中一个方法没有被mock但是被调用了，就会抛异常。easymock不支持private,final,static等方法的mock\n\n####2.mockito\nmockito是在easymock之后出现的，相对于easymock来说，mockito少了对象状态切换这一步骤。\n引入mockito的依赖\n```xml\n<dependency>\n     <groupId>org.mockito</groupId>\n     <artifactId>mockito-all</artifactId>\n     <version>2.0.2-beta</version>\n</dependency>\n```\n如何编写mockito的mock代码，分四个步骤\n```java\n// ① 创建mock对象\nMockClazz mockClazz = Mockito.mock(MockClazz.class);\n// ② 录制mock代码\nMockito.when(mockClazz.run(\"A\")).thenReturn(\"B\");\n// ③ 执行单元测试\nString actual = mockClazz.run(\"A\");\nAssert.assertEquals(actual,\"B\");\n// ④ 校验mock对象的行为是否按照mock执行\nMockito.verify(mockClazz).run(\"A\");\n```\n和easymock相比，mockito少了一个环节，就是把对象切换到播放状态。\n上面的代码中我们mock了run方法，但是getEatInfo方法没有被mock,调用这个方法会出现什么问题\n```java\nString eatInfo = mockClazz.getEatInfo(\"aa\");\nSystem.out.println(eatInfo);\n```\n此时返回null，按照mockito的官方文档，没有被mock的方法返回默认值，具体可以看mockito的官方文档。\n那么mockito如何保证不被mock的代码按照原来的逻辑输出呢？\n<font color=\"red\">通过doCallRealMethodl来实现</font>\n```java\nMockClazz mockClazz = Mockito.mock(MockClazz.class);\nMockito.doCallRealMethod().when(mockClazz).run(\"A\");\nString actual = mockClazz.run(\"A\");\nSystem.out.println(actual); // A begin run... 原样执行\n\nSystem.out.println(mockClazz.run(\"B\")); // null 返回默认值\n```\n上面的代码显示指定了通过run(\"A\")的时候调用原来的代码执行，输出A返回A begin run...\n<font color=\"red\">通过spy来实现</font>\n```java\nMockClazz mockClazz = Mockito.spy(new MockClazz()); // 注意这里需要new一个\nMockito.when(mockClazz.run(\"A\")).thenReturn(\"B\");\n\nString actual = mockClazz.run(\"C\");\nSystem.out.println(actual); // 输出[C begin run...],原样输出忽略mock逻辑\n```\n此时mockClazz.run(\"C\")直接按照原来的代码执行，忽略mock逻辑。\n在使用spy的时候需要注意一个点，看下面两段代码\n```java\nMockClazz mockClazz = Mockito.spy(new MockClazz());\nMockito.when(mockClazz.run(\"A\")).thenReturn(\"B\");\nSystem.out.println(mockClazz.run(\"A\")); // 实际执行run的代码,只是修改返回值（先输出A,再返回B begin run...)\n```\n这段代码只是修改了返回值，实际代码逻辑被执行了，也就是说这种mock逻辑只是mock了返回值，类似SpringAOP在方法返回的时候拦截一下修改了返回值。\n```java\nMockClazz mockClazz = Mockito.spy(new MockClazz());\nMockito.doReturn(\"B\").when(mockClazz).run(\"C\");\nSystem.out.println(mockClazz.run(\"C\")); // 根本不执行run的代码,直接返回\n```\n这段代码不仅该了返回值，同时也真正的代码一行也不会执行。\n\n> 注意这两种写法的微妙区别哦\n> Mockito.doReturn(\"B\").when(mockClazz).run(\"C\");\n> Mockito.when(mockClazz.run(\"A\")).thenReturn(\"B\");\n\nmockito不支持private,final,static等方法的mock。\n\n####3.powermock\npowermock实在easymock和mockito的基础上扩展而来的，easymock和mockito不能解决private,final,static等方法的mock，powermock为此提供了解决方案。powermock需要和easymock或者mockito配合起来一起使用。\n引入依赖\n```xml\n<dependency>\n    <groupId>org.powermock</groupId>\n    <artifactId>powermock-api-mockito</artifactId>\n    <version>1.5</version>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>org.powermock</groupId>\n    <artifactId>powermock-module-junit4</artifactId>\n    <version>1.5</version>\n    <scope>test</scope>\n</dependency>\n```\n```java\n@RunWith(PowerMockRunner.class)\n@PrepareForTest( { MockClazz.class })\npublic class MockTest {\n\n    @Test\n    public void testMockStatic() {\n        // 静态方法的mock\n        PowerMockito.mockStatic(MockClazz.class);\n        PowerMockito.when(MockClazz.sleep(\"A\")).thenReturn(\"B\");\n        System.out.println(MockClazz.sleep(\"A\"));\n        PowerMockito.verifyStatic();\n    }\n\n    @Test\n    public void testMockPrivate() throws  Exception {\n        // 私有方法的mock,getEatInfo=>eat,eat是私有方法\n        MockClazz mockClazz = PowerMockito.mock(MockClazz.class);\n        PowerMockito.when(mockClazz, \"eat\", \"A\").thenReturn(\"mock\");\n        PowerMockito.doCallRealMethod().when(mockClazz).getEatInfo(\"A\");\n        System.out.println(mockClazz.getEatInfo(\"A\"));\n    }\n\n    @Test\n    public void testMockFinal() {\n        // final方法的mock\n        MockClazz mockClazz = PowerMockito.mock(MockClazz.class);\n        PowerMockito.when(mockClazz.create(\"A\")).thenReturn(\"B\");\n        System.out.println(mockClazz.create(\"A\"));\n    }\n}\n```\n#####4.jmockit\njmockit是一个轻量级的mock框架，内部采用ASM来修改字节码。\n引入依赖\n```xml\n<dependency>\n    <groupId>com.googlecode.jmockit</groupId>\n    <artifactId>jmockit</artifactId>\n    <version>1.0</version>\n</dependency>\n```\n具体mock的代码如下\n```java\n@RunWith(JMockit.class)\npublic class MockTest {\n\n    @Mocked\n    MockClazz mockClazz = new MockClazz();\n\n    @Test\n    public void testExpectations() { // 全局mock抛异常\n        new Expectations() {\n            {\n                mockClazz.getEatInfo(\"A\");\n                returns(\"B\");\n            }\n        };\n\n        // 被mock的方法,返回mock后的值\n        System.out.println(mockClazz.getEatInfo(\"A\"));\n        // 没有被mock的方法,mockit.internal.UnexpectedInvocation,jmocit对run没有进行mock\n        System.out.println(mockClazz.run(\"A\"));\n    }\n\n    @Test\n    public void testNonExpectations() { //全局mock返回缺省值\n\n        new NonStrictExpectations() {\n            {\n                mockClazz.getEatInfo(\"A\");\n                returns(\"B\");\n            }\n        };\n\n        // 被mock的方法,返回mock后的值\n        System.out.println(mockClazz.getEatInfo(\"A\"));\n        // 没有被mock的方法,返回默认值,jmockit对run方法也进行了mock\n        System.out.println(mockClazz.run(\"A\"));\n    }\n\n    @Test\n    public void testMockStatic() {\n        // mock静态方法\n        new NonStrictExpectations() {\n            {\n                MockClazz.sleep(\"A\");\n                result = \"B\";\n            }\n        };\n        System.out.println(MockClazz.sleep(\"A\"));\n    }\n\n    @Test\n    public void testMockPrivate() {\n        // mock静态方法\n        final MockClazz obj = new MockClazz();\n        new NonStrictExpectations(obj) {\n            {\n                // 私有方法mock\n                this.invoke(obj, \"eat\", \"A\");\n                returns(\"B\");\n            }\n        };\n        System.out.println(obj.getEatInfo(\"A\")); // 私有方法被mock了\n        System.out.println(obj.run(\"A\")); // run方法不会被mock,走真实逻辑\n    }\n}\n```\n>  注意：\n>  1.NonStrictExpectations返回缺省值针对没有mock的方法\n>  2.Expectations针对没有mock的方法直接抛异常\n>  3.官网上的jmockito暂时不支持私有方法的mock，google提供的高版本二方库也不支持私有方法的mock\n\n上面例子的代码https://github.com/yangbolin/java-mock-framework\n\n####三.总结\n本文依次对比了easymock,mockito,powermock,jmockito四个java的mock框架，easymock,mockito都存在final,private,static方法没法mock的问题，powermock解决了这个问题，jmockit也没有这个问题，powermock和jmockit的区别就在于API的风格，powermock继承了easymock和mockito的风格，链式的API风格，非常清晰，jmockit有自己的API风格。\n\n","mtime":1468754566000,"source":"source/_posts/java-ut-mock-framework.md","_id":"zwrdwzuwou3bc5ge"},"xjus7jbrtc2sjwm0":{"content":"title: JAVA线程中join,wait,notify&&notifyAll\ndate: 2014-06-03 22:19:16\ntags: [JAVA,并发]\ncategories: 编程语言\n---\n\n####一.概述\n在编写多线程程序的时候，我们经常需要考虑线程之间的同步，比如我们使用join可以让某一线程执行结束，使用wait可以让某一线程在某个地方等待，使用notify或者notifyAll可以唤醒处于等待状态的线程。这里我们来看看这几个线程自带方法的使用以及相关的分析。\n\n<!-- more -->\n\n####二.join()的使用\njoin()方法是Thread类的，在Thread类中提供三种join()方法\n```java\n// 设置毫秒级别的等待\npublic final synchronized void join(long millis) \n    throws InterruptedException {//...}\n// 设置毫秒级别，纳秒级别的等待\npublic final synchronized void join(long millis, int nanos) \n    throws InterruptedException {//...}\n// 持续等待，没有时间限制\npublic final void join() throws InterruptedException {//...}\n```\n\n如果我们写下面的代码\n```java\nThread t1 = new ...\nt1.start();\nt1.join();\nSystem.out.println(\"t1 has finished...\");\n```\n此时控制台的输出一定是在线程t1执行结束后，从这点我们可以利用join来控制多个线程直线的执行顺序，比如要想线程t2在线程t1执行结束后执行，我们在调t2的start方法之前调用t1的join方法即可。\n\n####三.wait()&&notify()&&notifyAll()的使用\nwait(),notify(),notifyAll()这三个方法是任何一个java对象都具有的方法。\n在某一对象上调用wait()方法，当前线程就会在该对象上处于等待状态。\n在某一对象上调用notify()方法，就会唤醒一个在当前对象上处于wait状态的线程，要是当前对象上有N个线程处于wait状态，就会任意选取一个唤醒。\n在某一对象上调用notifyAll()方法，就会唤醒在某一对象上处于wait的所有线程。\n\n注意wait()和notify()的时候要使用相同的Object。\n####四.绿色线程&&本地线程\n最近在搜索的时候发现了一个绿色线程的概念，很好奇，继续搜索了一把，发现绿色线程在jdk1.1的时候存在，后面就给干掉了，绿色线程的意思就是这个线程只是一个JVM可调度运行的任务，不会对应一个OS层面的上的线程。本地线程必须对应一个OS层面的线程。\n####五.总结\n线程的同步我们一般不太会使用join,wait,notify以及notifyAll等来同步，直接使用juc包中的一些类，但是我们需要明白这些方法的具体含义。\n","mtime":1401885098000,"source":"source/_posts/join-wait-notify-notifyall.md","_id":"xjus7jbrtc2sjwm0"},"sa8y8xnaxumbhehu":{"content":"title: 使用jQuery来模拟input的placeholder\ndate: 2014-04-13 17:30:00\ntags: jQuery\ncategories: 前端开发\n---\n\n####一.需求描述\n我们在写HTML代码的时候后，经常遇到input元素，在使用input元素的时候，我们有时需要利用input的placeholder属性来告诉用户在这个输入框中应该输入什么内容，提升用户体验。不幸的是，IE系列的浏览器不支持placeholder属性，那么要想在IE系列的浏览器中提升用户体验，只能利用jquery来模拟了。\n\n<!-- more -->\n\n####二.使用jQuery模拟placeholder代码\n```javascript\nif(!$.support.placeholder) {\n    // 使用选择器，选中所有带有placeholder属性的input元素列表\n\tvar els = $('input[placeholder],textarea[placeholder]');\n\t// 遍历每个带有placeholder属性的元素\n\tels.each(function(i, el) {\n\t\tel = $(el);\n\t\t// 获取placeholder的值以及颜色值\n\t\tvar defValue = el.attr('placeholder'),\n\t\t\tdefColor = el.css('color');\n\t\t// 当输入框获取到焦点后，把placeholder的值清空\n\t\tel.bind('focus',function() {\n\t\t\tif(this.value === '' || this.value === defValue) {\n\t\t\t\t$(this).css('color', defColor);\n\t\t\t\tthis.value = '';\n\t\t\t}\n\t\t});\n\t\t// 当输入框失去焦点后，要是用户没有输入值，或者输入的值和placeholder的值一样，就把placeholder属性再次展示出来\n\t\tel.bind('blur',function() {\n\t\t\tif(this.value === '' || this.value === defValue) {\n\t\t\t\t$(this).css('color','#aaa');\n\t\t\t\tthis.value = defValue;\n\t\t\t}\n\t\t});\n\t\tel.triggerHandler('blur');\n        // 在表单提交时，需要判断用户输入的值是否和placeholder的值一样，要是一样就需要清空\n\t\tel.closest('form').submit(function(){\n\t\t\tvar val = el.val();\n\t\t\tif(val === defValue){\n\t\t\t\tel.val('');\n\t\t\t}\n\t\t});\n\t});\n}\n```","mtime":1397450587000,"source":"source/_posts/jquery-placeholder.md","_id":"sa8y8xnaxumbhehu"},"nyzh7nk58sj94lsj":{"content":"title: javac生成的access$000方法\ndate: 2015-03-21 10:07:34\ntags: JAVA\ncategories: 编程语言\n---\n####一.概述\n最近在做字节码分析的时候，发现字节码中出现了access$000的方法，这个方法不是开发工程师写的，是编译器生成的，那么编译器生成这个方法是为了解决什么问题呢？我们知道编译会为静态代码块生成执行的方法，在类没有构造函数时为类生成缺省构造函数，这个access$000究竟是在什么场景下面用的呢？仔细分析包含access$000的类，发现该类中存在内部类，结合google搜索，原来acess$000是为了解决内部类访问外部类的成员，包括成员变量和成员方法。\n\n<!-- more -->\n\n####二.深入分析\n我们先写个简单的测试例子，一个类中包含一个内部类\n```java\npublic class Outer {\n    private int x = 3;\n    private void f() {\n        \n    }\n    \n    class Inner {\n\n        public void f() {\n            Outer.this.f();\n            System.out.println(Outer.this.x);\n        }\n    }\n    \n    public static void  main(String[] args) {\n        System.out.println(\"Inner Test\");\n    }\n}\n```\n然后我们先看内部类的字节码\n![内部类字节码](http://bolinyoung.qiniudn.com/inner-call.png)\n我们看到内部类的字节码中调用了access$000和access$100这两个方法，这两个方法都是Outer这个类的静态成员方法，同时带有一个Outer类型的参数。那么我们看看Outer这个类的字节码到底是什么样子\n![外部类的字节码](http://bolinyoung.qiniudn.com/outer-code.png)\n果然外部类中存在两个这样的方法，我们先看一下access$000这个方法的实现，该方法先用aload_0把方法参数入栈，然后调用栈顶元素的f方法，即Outer的f方法，因为内部类中有地方通过外部类的this引用调用Outer的f()方法。access$100这个方法，很明显在访问Outer的成员变量x。\n\n至此疑问都清楚了，原来access$xxx是编译器生成的，用来解决内部类访问外部类的成员。\n\n但是你一定有一个疑问，我们自己能否写access$xxx的方法呢？答案是可以的。\n\n####三.自己编写access$xxx\n写个简单的例子\n```java\npublic class Outer {\n    private int x = 3;\n    private void f() {\n        \n    }\n    \n    class Inner {\n\n        public void f() {\n            Outer.this.f();\n            System.out.println(Outer.this.x);\n        }\n    }\n    \n    public static void  main(String[] args) {\n        System.out.println(\"Inner Test\");\n    }\n    \n    // 编写自己的access$xxx方法\n    static int access$888(Outer outer) {\n    \treturn outer.x;\n    }\n}\n```\n\n> 注意:\n\n> * 我们自己编写的access$xxx不能和编译生成的具有相同的方法签名，否则你会得到一个编译错误的。\n> *  access$xxx可以绕过编译器的检查，访问类的私有成员。\n> * 一般不要编写access$xxx方法。\n\n","mtime":1426905661000,"source":"source/_posts/javac-accessbash00.md","_id":"nyzh7nk58sj94lsj"},"uni7jo5ubbke9vxs":{"content":"title: JVM字节码指令相关\ndate: 2014-07-26 19:46:08\ntags: JVM\ncategories: JVM学习\n---\n\nJAVA代码中的每个方法都会被编译成一系列的JVM字节码指令，这些字节码指令会被JVM所执行，从而产生相应的数据，我们通常可以用javap -verbose来查看一个方法的字节码指令。\n\n<!-- more -->\n\n记得自己之前写过一个简单编译器，编译之后生成的相关的指令，这写指令的编号都是连续的，因为这些指令被我存储在一个指令数组中，每次执行指令的时候，程序计数器PC就会加一，指向下一条需要执行的指令，但是我们使用javap -verbose查看方法字节码指令时，你会发现方法字节码指令前面的编号不是连续的\n![方法字节码指令](http://bolinyoung.qiniudn.com/method-byte-code.jpg)\n我们看到Lookup方法有三条字节码指令，为什么这三条字节码指令前面的编号不是0,1,2呢？\n\n这里的编号不是以指令为单位的，而是以字节为单位。\n字节码指令的结构是： \n[ opcode ][ operands ] \n其中opcode一定是1字节的，而operands可能是1字节、2字节、4字节或更多（如switch系指令）。\n此外，方法的字节码指令都是存储在一个字节数组中的，对于aload_0前面的0表示这个字节码指令在字节数组中的偏移量是0,invokespecial前面的指令标识自己在字节数组中的偏移量是1,return表示自己在字节数组中的偏移量是4,从上面的分析可以知道invokespecial在字节数组中占据1,2,3三个下标对应的字节。\n\n这里顺便提一下几个容易混淆的字节码指令：\n\n* load指令表示把局部变量区中的数据加载到操作数栈顶部\n* store指令表示把栈顶的数据存储到局部变量区中\n* invokevirtual表示调用实例的方法\n* invokespecial表示调用类的构造方法，实例初始化方法，私有方法\n* invokestatic表示调用静态方法\n* invokeinterface表示调用接口方法","mtime":1406376667000,"source":"source/_posts/jvm-byte-code-attention.md","_id":"uni7jo5ubbke9vxs"},"ycl5ilndrpx4ced1":{"content":"title: JVM常用命令总结\ndate: 2014-09-17 19:38:19\ntags: JVM\ncategories: JVM学习\n---\n\n#### GC相关\njstat -gcutil pid time\n实时查看JAVA进程PID的垃圾回收情况，PID表示JAVA进程的ID，time表示统计的时间频率，单位是ms，比如jstat -gcutil 8888 1000 表示每隔1000ms统计一次JAVA进程8888的GC回收。\n\n<!-- more -->\n\n#### 内存相关\njmap -dump:format=b,file=/home/admin/xxx.bin PID \n获取JVM的内存的dump文件\n\njinfo -flag +HeapDumpBeforeFullGC PID\njinfo -flag +HeapDumpAfterFullGC PID\n设置这两个标记后，可以让JVM在发生FGC前后自动dump堆内存，等dump完后，执行下面的命令去掉这两个标记\njinfo -flag -HeapDumpBeforeFullGC PID\njinfo -flag -HeapDumpAfterFullGC PID\n在dump结束后，记得去掉这两个标记\n\njmap -histo:live PID\n查看系统中存活的实例数目\n\n\n\n","mtime":1416404204000,"source":"source/_posts/jvm-cmd.md","_id":"ycl5ilndrpx4ced1"},"e69xqrrscntp53n1":{"content":"title: 关于YGC时间变长的记录\ndate: 2016-03-19 18:01:23\ntags: JVM\ncategories: 编程开发\n---\n\n最近看见很多同事都在讨论一个JVM YGC时间变长的问题，在平时业务开发的过程中，我们经常使用\n```java\nXStream xs = new XStream();\n```\n来实现XML和JavaBean之间的相互转换，看看实现就知道在上面的构造函数中不断创建新的classloader出来\n```java\npublic XStream(\n            ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {\n        this(reflectionProvider, driver, new ClassLoaderReference(new CompositeClassLoader()), mapper, new DefaultConverterLookup(), null);\n    }\n```\n不断创建新的classloader会导致YGC的时间变长。JVM的类加载机制都是双亲委派机制。\n假如：AClassLoader->BClassLoader->CClassLoader，现在需要加载X这个类，AClassLoader首先会交给BClassLoader去加载，BClassLoader会交给CClassLoader去加载，如果CClassLoader能加载到，那么X这个类就被加载了。此时在SystemDictionary这个HashTable数据结构中会存储3条记录。\n```java\nX-AClassLoader-X.cls\nX-BClassLoader-X.cls\nX-CClassLoader-X.cls\n\n此时SystemDictionary中有三条关于X的加载记录，如果发现任何一条，就认为X已经加载过了。\n```\n其中AClassLoader和BClassLoader叫做X的出始类加载器。CClassLoader叫做X的定义类加载器。如果不断自定义ClassLoader的话，SystemDictionary中会不断增加K-V记录，这样YGC扫描的范围就越大，YGC耗时就越多。\n\n最后，在使用XStream时，最好别每次都创建一个新的ClassLoader来，减少YGC的时间，提升性能。","mtime":1458383322000,"source":"source/_posts/jvm-systemdictionary.md","_id":"e69xqrrscntp53n1"},"6l579y0f5w8lrrwv":{"content":"title: Linux下面使用C语言写多线程程序\ndate: 2014-04-13 22:49:13\ntags: [并发, Linux, C]\ncategories: 编程语言\n---\n####一.概述\n在Linux系统中编写多线程程序，需要使用Linux系统本身的一个库函数来创建线程\n\n<!-- more -->\n\n```c\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                   void *(*start_routine) (void *), void *arg);\n```\n返回值\n\n* 若线程创建成功，则返回0。若线程创建失败，则返回出错编号\n\n参数\n\n* 第一个参数为指向线程标识符的指针。\n* 第二个参数用来设置线程属性。\n* 第三个参数是线程运行函数的起始地址。\n* 最后一个参数是运行函数的参数。\n\n函数pthread_join用来等待一个线程的结束,创建线程后，可以在创建线程的主线程中使用这个函数来等待创建的线程运行结束\n```c\nint pthread_join(pthread_t thread, void **retval);\n```\n返回值\n\n* 0代表成功。 失败，返回的则是错误号。\n\n参数\n\n* thread: 线程标识符，即线程ID，标识唯一线程。\n* retval: 用户定义的指针，用来存储被等待线程的返回值。\n\n####二.代码\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n\n/** 两个线程函数的说明 **/\nvoid *One(void * no);\nvoid *Two(void * no);\n\nint main(int argc, char **argv)\n{\n    /** 线程变量的定义 **/\n    pthread_t A, B;\n\n    /** 注意函数名One 和Two这里当作函数参数传入 **/\n    pthread_create(&A, NULL, One, NULL);\n    pthread_create(&B, NULL, Two, NULL);\n    \n    /** 主线程等待创建的两个子线程A,B运行结束后才退出，不然主线程退出后，\n     *  创建的子线程执行不完也就退出了，pthread_join()函数，以阻塞的方式\n     *  等待thread指定的线程结束。\n     **/\n    pthread_join(A, NULL);\n    pthread_join(B, NULL);\n\n    return 0;\n}\n\nvoid *One(void *no)\n{\n    int i;\n    for(i = 0; i < 5; ++i)\n    {\n        printf(\"NUAA\\n\");\n        // 等待1秒钟\n        sleep(1);\n    }\n    \n    return NULL;\n}\n\nvoid *Two(void *no)\n{\n    int i;\n    for(i = 0; i < 5; ++i)\n    {\n        printf(\"CS\\n\");\n        sleep(1);\n    }\n    \n    return NULL;\n}\n```\n注意\n\n* 1.编译命令：gcc xx.c -o xx -l pthread，编译的时候必须带上-l pthread，不然编译不过。\n* 2.执行./xx然后看到在控制台交替输出NUAA和CS\n","mtime":1398057349000,"source":"source/_posts/linux-c-thread.md","_id":"6l579y0f5w8lrrwv"},"z8tti36o2urqrzwp":{"content":"title: 关于log4j的additivity\ndate: 2014-10-31 17:10:37\ntags: log4j\ncategories: 编程开发\n---\n\n####一.问题描述\n最近优化了一下一个应用的日志，但是优化后的结果不是自己想要的，简单说指定的log部分输出到了root中的appender中，部分输出到自己指定的log中。\n\n<!-- more -->\n\n```xml\n<appender name=\"BOORT\" class=\"org.apache.log4j.DailyRollingFileAppender\">\n\t<param name=\"file\" value=\"xxx/boort.log\" />\n\t<param name=\"append\" value=\"true\" />\n\t<param name=\"encoding\" value=\"GBK\" />\n\t<layout class=\"org.apache.log4j.PatternLayout\">\n\t\t<param name=\"ConversionPattern\" value=\"%d %-5p %c{2} - %m%n\" />\n\t</layout>\n</appender>\n<appender name=\"OPENAPI\" class=\"org.apache.log4j.DailyRollingFileAppender\">\n        <param name=\"file\" value=\"xxx/service/api.log\"/>\n        <param name=\"append\" value=\"true\"/>\n        <param name=\"encoding\" value=\"GBK\"/>\n        <layout class=\"org.apache.log4j.PatternLayout\">\n            <param name=\"ConversionPattern\" value=\"%d %-5p %c{2} - %m%n\"/>\n        </layout>\n</appender>\n\n<logger name=\"xxxx.Service\" additivity=\"true\">\n        <level value=\"info\"/>\n        <appender-ref ref=\"OPENAPI\"/>\n</logger>\n<root>\n\t<level value=\"info\" />\n\t<appender-ref ref=\"BOORT\" />\n\t<appender-ref ref=\"JmonitorAppender\" />\n</root>\n```\n上述xxxx.Service中的日志部分会出现到boort.log，部分会出现到api.log中。但是我们期望xxxx.Service中日志只出现到api.log中。\n\n####二.解决方案\n上面的问题肯定是日志配置的问题，google后发现additivity=\"true\"在搞鬼\n[log4j的配置](http://wiki.apache.org/logging-log4j/Log4jXmlFormat)\n具体说明如下：\n![log4j的additivity](http://bolinyoung.qiniudn.com/log4j-additivity.png)","mtime":1414748215000,"source":"source/_posts/log4j-additivity.md","_id":"z8tti36o2urqrzwp"},"o876shdewt9rddnh":{"content":"title: maven自己的仲裁机制\ndate: 2014-06-18 22:09:25\ntags: maven\ncategories: 开发工具\n---\n\nmaven现在被广泛用来做项目管理的工具，我们经常在maven的pom文件中指定我们项目依赖的二方库，我们也会经常遇到jar包冲突，类冲突的问题。关于类冲突就是由于maven自己的仲裁机制，把应该引入的jar包给仲裁了，那么maven自己到底是如何仲裁jar包的呢？\n\n<!-- more -->\n\n假设我们在自己的pom.xml中引入下面的jar包\n```xml\n    ...\n    <dependency>\n        <groupId>com.xx.yy</groupId>\n        <artifactId>AA</artifactId>\n        <version>1.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.xx.yy</groupId>\n        <artifactId>BB</artifactId>\n        <version>1.0.0</version>\n    </dependency>\n    ....\n```\nAA间接依赖CC对应maven坐标如下\n```xml\n    <dependency>\n        <groupId>com.xx.yy</groupId>\n        <artifactId>CC</artifactId>\n        <version>1.0.0</version>\n    </dependency>\n```\nBB间接依赖CC对应maven坐标如下\n```xml\n    <dependency>\n        <groupId>com.xx.yy</groupId>\n        <artifactId>CC</artifactId>\n        <version>1.0.1</version>\n    </dependency>\n```\n\n此时maven编译的时候会进行仲裁，首先看依赖的路径，假设当前项目是X，对于CC有两条依赖路径,只是version不同，其他都一样。\n1.X->AA->CC 1.0.0\n2.X->BB->CC 1.0.1\n发现两条路径的长度一样。接下来观察AA和BB在pom中声明的顺序，发现AA在BB的前面，此时CC使用1.0.0的版本。\n\n因此maven自己的仲裁机制是先看路径长度，路径长度一样再看声明顺序。\n\n如果我们书写下面的pom文件\n```xml\n...\n    <dependency>\n        <groupId>com.xx.yy</groupId>\n        <artifactId>AA</artifactId>\n        <version>1.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.xx.yy</groupId>\n        <artifactId>AA</artifactId>\n        <version>1.0.1</version>\n    </dependency>\n...\n```\n\n按照上面的规则，路径相同，看声明顺序，因此1.0.0的版本被使用。\n\n注意:\nmaven仲裁的前置条件是artifactId和groupId一样。","mtime":1403101515000,"source":"source/_posts/maven-default-arbitration.md","_id":"o876shdewt9rddnh"},"q7j6rivsd6ai3s1j":{"content":"title: Linux命令总结\ndate: 2014-06-13 14:30:04\ntags: Linux\ncategories: 开发工具\n---\n\n一些常用Linux命令的总结\n\n<!-- more -->\n\n* lsof -p <pid> | grep xx\n查看当前进程中有没有使用xx相关的东西，比如可以查看当前JVM有加载的某个jar包完整信息 ，包括版本。\n\n* pmap <pid> | grep xx\n查看当前进程中有没有使用xx相关的东西，比如可以查看当前JVM有加载的某个jar包完整信息 ，包括版本。\n\n* df -hl\n查看磁盘占用率\n\n* du -sh 文件目录\n查看当前文件的大小\n\n* grep -R \"xxx\" .\n在当前目录下查看包含xxx字符串的文件\n\n* sudo killall wpa_supplicant\nLinux当无线网络断掉之后，发现重新链接无线网络一直链接不上，此时执行一下上面的命令就可以了，避免每次重启电脑。\n\n* sh -x xx.sh\n调试shell脚本\n\n* jar xvf root.war\n解压war包\n\n* jar cvf root.war\n生成war包\n\n* jar xvf web-deploy.jar\n解压jar包\n\n* jar cvf web-deploy.jar\n生成jar包\n\n* tar zxvf xxx.tgz\n解压tgz的包\n\n* find . -print | xargs fgrep \"xx\"\n在当前文夹夹下面查找包含xx的文件\n\n* iconv -fgbk -tutf8 xxx.log\n查看有乱码的日志文件\n\n* find `pwd` -iname \"*java\" -type f -exec iconv -f UTF-8 -t GBK {} -o {} \\;\n对.java文件进行编码转换。\n\n* find . -iname \"*.svn\" -type d | xargs rm -rf\n删除.svn目录\n\n* netstat -a\n查看机器的所有TCP链接，比如可以看到当前机器链接到哪个数据库上，如果机器上有应用使用了数据库的话。\n\n* shift+$\n通过VI打开文件，把光标移动到行末","mtime":1444394388000,"source":"source/_posts/linux-command.md","_id":"q7j6rivsd6ai3s1j"},"7yjkj66x96w8ih3s":{"content":"title: mac遇到的一个svn的问题\ndate: 2015-10-29 13:34:37\ntags: svn\ncategories: 开发工具\n---\n今天在mac使用svn pe svn:ignore 来设置忽略文件夹时出现了下面的错误\n```\nsvn: E205007: None of the environment variables SVN_EDITOR, VISUAL or EDITOR are set, and no 'editor-cmd' run-time configuration option was found\n```\n解决办法，在.bash_profile中增加下面一行，然后source生效即可\n```\nexport SVN_EDITOR=vim\n```\n注意使用\n```\nsvn pe svn:global-ignores .\n```\n进行全局设置，避免给每个目录执行\n```\nsvn pe svn:ignore .\n```\n来设置\n","mtime":1446168230000,"source":"source/_posts/mac-svn-problem.md","_id":"7yjkj66x96w8ih3s"},"o3qc5pvbeg0shpue":{"content":"title: maven的一些注意点\ndate: 2014-05-17 19:39:59\ntags: maven\ncategories: 开发工具\n---\n\n####一.概述\n目前maven被广泛用于java项目的开发中，统一管理项目依赖，以及项目的打包部署等，我们经常需要编写maven的pom文件，包括顶级pom以及子pom。maven既可以用来构建单工程项目，也可以用来构建多工程项目，子工程和子工程之间有相互依赖。\n\n<!-- more -->\n\n同时maven本身也提供了插件机制，使得工程师可以编写自己的插件，然后在maven的某一阶段执行自己的插件做相关的事情,后面我会开发一个maven的插件，来检查java代码的规范。\n\n####二.一些注意点\n* 顶级pom中注意modules中module的顺序\n在顶级pom中，我们经常写一个modules标签，管理我们当前工程下面有多少个模块例如\n```xml\n<modules>\n    <module>A</module>\n    <module>B</module>\n    <module>C</module>\n</modules>\n```\n上面的modules说明当前工程有A,B,C三个子工程，并且install的顺序是A,B,C，这样要是A依赖B的话，执行mvn clean install必然报错，因为install A的时候，B还没有生成，所以我们在写modules的时候一定要注意顺序的问题。\n\n* 子pom中版本的问题\n在子pom文件中，我们一般会指定顶级pom是谁，以及顶级pom的版本是多少，当然我们也可以去指定子pom的版本，要是你的子pom版本和顶级pom的版本一样，那就别指定了，子pom自动继承顶级pom的版本，再指定pom版本就是多次一举。\n\n####三.命令的灵活使用\n\n* mvn dependency:tree\n这命令在解决jar包冲突的时候经常用到，我们找到发生冲突的jar包，然后做响应的仲裁\n\n* 修改pom中的版本\nmvn versions:set -DnewVersion=1.0.1\n执行完这个命令后，顶级pom中的version,子pom中的version,子pom中父pom的version都会被修改成1.0.1,同时我们每个被修改过的pom文件都会生成一个pom.xml.versionsBackup\n执行mvn versions:revert就会把刚才修改过的version恢复。要是不执行mvn versions:revert执行mvn versions:commit就会把刚才版本的修改提交，这样pom.xml.versionsBackup文件就会被删除，commit之后就没法再回滚了。","mtime":1400328577000,"source":"source/_posts/maven-notice.md","_id":"o3qc5pvbeg0shpue"},"ta5bxd2l81ndn2z3":{"content":"title: 关于ExecutorService的Future的误解\ndate: 2014-05-17 20:54:15\ntags: [JAVA,并发]\ncategories: 编程语言\n---\n\n####一.概述\n在多线程编程中我们经常使用ExecutorService的Future来实现等待多个线程返回的需求。此时需要调用ExecutorService的相关方法来实现，比如\n\n<!-- more -->\n\n```java\n<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n```\n\n调用这个方法后，遍历返回的List就能获取到本次新增tasks的返回值，要是某个task执行时间较长，调用Future的get方法就会阻塞，当然你也可以选择使用能设置超时时间的get方法。\n\nFuture的get方法，一个可以设置超时时间，一个不能设置超时时间。\n```java\nV get() throws InterruptedException, ExecutionException;\nV get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n```\n\n这样我们就能等所有线程都返回后，然后继续做相关的计算逻辑。\n\n####二.常常被误解的地方\n\n我们在一个线程池A上调用下面的方法\n```java\n<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n```\n假设在调用这个方法之前线程池中有M个线程在RUNNING,调用这个方法后又往线程池中增加了N个线程，然后遍历返回的List,此时返回的List中只会包含后面加入的N个线程，而不会包含前面已经存在的M个线程，因此List的大小是N，不是M+N,经常会有人误以为是M+N。因此当遇到需要N个线程都返回后才继续向下的场景时，就放心大胆的使用Future吧。\n","mtime":1400405457000,"source":"source/_posts/misunderstand-for-future-of-executorservice.md","_id":"ta5bxd2l81ndn2z3"},"38teol9xaemwsda4":{"content":"title: maven dependencies 和 dependencyManagement的区别\ndate: 2014-05-17 17:35:04\ntags: maven\ncategories: 开发工具\n---\n\n曾经有人问我maven中dependencies和dependencyManagement的区别，我当时主要从版本控制以及依赖引入这两方面来回答\n\n<!-- more -->\n\n* 版本控制\n我们一般在顶级pom中使用dependencyManagement来管理一组二方库的依赖，如下所示\n\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>com.xxx.xxx</groupId>\n            <artifactId>yyyxxx</artifactId>\n            <version>1.0.6-SNAPSHOT</version>\n        </dependency>\n        ....\n    </dependencies>\n</dependencyManagement>\n```\n我们看到dependencyManagement需要dependencies来管理一组二方库的依赖，写在这里的二方库必须指定groupId,artifactId以及version，但是不一定会被应用真正依赖进来，我们最终会在子pom中写\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.xxx.xxx</groupId>\n        <artifactId>yyyxxx</artifactId>\n    </dependency>\n    ....\n</dependencies>\n```\n来真正引入一个二方库到我们的应用中，同时这个引入二方库的版本就是我们在顶级pom中指定的版本，当然在子pom中也可以指定自己的版本，这样就不会使用dependencyManagement中指定的version了。\n\n* 依赖引入\n写在dependencyManagement中的依赖不一定会引入到应用中，只有在子pom中通过dependencies显式指定后才会真正引入到应用中。\n\n\n> 注：\n> 目前暂时想到这两个点，后续发现其他点后再补充\n","mtime":1400320253000,"source":"source/_posts/mvn-dependencies-and-dependencymanagement-diff.md","_id":"38teol9xaemwsda4"},"bpp8fdj71zkz44af":{"content":"title: mysql相关的注意点\ndate: 2017-02-17 19:20:33\ntags: mysql\ncategories: 数据库\n---\n\n最近一直忙于业务系统的开发，在开发过程中少不了sql语句的使用，我们在分页遍历的时候经常需要排序，就会编写如下的sql\n```sql\nselect x, y, z from tableX where status=#status#\norder by apply_time\nlimit 0,100\n```\n这个分页sql看上去没有什么问题，但是在执行过程中发现有数据被重复遍历出来，然后仔细排查发现上面sql中的order by apply_time是存在问题的，因为多条记录如果apply_time是一样的话，会被重复扫描到，排序字段一样，同一条记录可能会出现在不同的页中。在编写mysql分页遍历语句时，一定要注意排序字段的选择，主要重复筛选的问题。\n\n现在整个业界对于分布式锁暂时还没有一些好的做法，我自己习惯使用mysql的select for update来实现锁，但是在使用select for update时，如果where语句中不带主键id的话，该sql可能会锁表，因为mysql发现where语句匹配到的记录数目比较多，对多行加锁的代价比对单表加锁的代价高，因此mysql会对表加锁。使用select for update最安全的做法是带上主键ID。如果要加锁多行，写个for循环对多条记录按照固定的顺序依次执行select for update。\n\n","mtime":1487331463000,"source":"source/_posts/mysql-notice-1.md","_id":"bpp8fdj71zkz44af"},"3lm9pu8i997mc7kn":{"content":"title: mysql中的null\ndate: 2017-06-22 20:10:25\ntags: mysql\ncategories: 数据库\n---\n最近在优化系统代码的时候，需要修改一下表结构，增加了一个字段D，原来表中A,B,C三字段构成了唯一性约束，现在增加了D字段，D字段是可控的，没有缺省值。同时新的唯一性约束由A,B,C,D四个字段构成，上线后发现唯一性约束失效啦。\na1,b1,c1,null插入数据库后，a1,b1,c1,null还可以插入数据库。也就是说mysql任务[a1,b1,c1,null]和[a1,b1,c1,null]是两条记录，的确是这样，在mysql中null和null是不相等的。\n","mtime":1498133920000,"source":"source/_posts/mysql-null-index.md","_id":"3lm9pu8i997mc7kn"},"nvsukgj6oh5dzp7e":{"content":"title: nginx线上出错\ndate: 2016-10-20 13:01:10\ntags: Nginx\ncategories:   线上运维\n---\n最近在做nginx的升级，很多网站的架构都是代理服务器(Apache/Nginx)加上应用容器(Tomcat/Jetty/Jboss)，Nginx在性能上由于Apache，在升级的过程中出现了下面的错误\n```\nnginx: [emerg] could not build the variables_hash, you should increase either variables_hash_max_size: 512 or variables_hash_bucket_size: 64\n```\n查找Nginx的文档，找到解决方案\n```\nhttp  {\n    ......\n    variables_hash_max_size 51200;\n    variables_hash_bucket_size 6400;\n    ......\n}\n```\n在http的配置中增加上面两个配置即可。\n另外，对于基础软件的升级一定要注意操作上的顺序，本次升级过程中发现之前老的一些配置都不兼容，如果操作不当很容易引发线上故障。\n","mtime":1476940241000,"source":"source/_posts/nginx-error-fix.md","_id":"nvsukgj6oh5dzp7e"},"6uf58tk6uat0hgve":{"content":"title: NoClassDefFoundError VS ClassNotFoundException\ndate: 2014-05-31 23:52:45\ntags: JAVA\ncategories: 编程开发\n---\n\n在开发JAVA项目的时候，我们经常会遇到这样两种异常，一种是java.lang.NoClassDefFoundError,另外一种是java.lang.ClassNotFoundException。\n\n<!-- more -->\n\n对于ClassNotFoundException，意思说是需要加载的类压根在classpath中不存在，我们需要使用一个类的时候，要是类加载器没有加载过这个类，classloader就会在classpath中寻找这个类，然后使用合适的类加载器去加载这个类，要是找不到相应的类文件就会抛ClassNotFoundException异常。出现这个异常一般都是少引入了jar或者jar包冲突导致。\n\n对于NoClassDefFoundError，不是说在classpath中找不到相应的类文件，而是找到了相应的类文件，但是实例化这个类的时候出错了，JVM加载的每个类都会对应一个java.lang.Class类型的实例。此时我们需要检查的是类的static代码块或者static的成员变量，很有可能就是这些static的东东在初始化的发生了问题。例如\n\n```java\nclass xxx {\n    // 静态成员变量也会导致这个问题，比如初始化log的时候可能会出现jar包冲突的问题,这也会抛出NoClassDefFoundError的异常\n    private static Logger LOG = Logger.getLogger(\"xxx\");\n    \n    static {\n        // 加载xxx的时候先会执行这个static代码块，要是这个static代码块执行有问题，那么就会出现NoClassDefFoundError的异常\n    }\n}\n```\n\n出现这个异常的时候，重点关注static相关的代码就会找到问题所在。\n\n下面我们看看java语言规范中关于这两个异常的定义\n\n> java.lang.ClassNotFoundException\n> Thrown when an application tries to load in a class through its string name using: \n> - The forName method in class Class. \n> - The findSystemClass method in class ClassLoader . \n> - The loadClass method in class ClassLoader. \n\n> but no definition for the class with the specified name could be found. \n\n> java.lang.NoClassDefFoundError\n> Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found. \n> The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found. \n\n不翻译了，很简单的英文，看英文更好理解^=^,关于码代码，一定要学会看英文文档，要是什么事情都等中文，那就迟了。","mtime":1401553482000,"source":"source/_posts/noclassdeffounderror-vs-classnotfoundexception.md","_id":"6uf58tk6uat0hgve"},"erl4qif1k4y7l5bl":{"content":"title: 通过开放调用来避免死锁\ndate: 2014-10-25 21:00:45\ntags: Concurrency\ncategories: 并发技术\n---\n\n####一.概述\n在编写并发程序的时候，我们经常会在一次业务逻辑处理过程中获取多个锁，然后做一些操作，如果这多个锁的获取顺序和其他地方的获取顺序不同的话，很容易发生死锁。为了避免这种死锁，我们必须保证获取多个锁的顺序一致，或者方法调用为开放调用，即调用某个方法时不需要持有锁。\n\n<!-- more -->\n\n####二.示例分析\nTaxi表示一个出租车对象，包含位置和目的地两个属性，Dispatcher代表一个出租车队。\n```java\nclass Taxi {\n\t@GuardedBy(\"this\")private Point location, destination;\n\tprivate final Dispatcher dispatcher;\n\tpublic Taxi(Dispatcher dispatcher) {\n\t\tthis.dispatcher = dispatcher;\n\t}\n\t/** 获取出租车的位置 **/\n\tpublic synchronized Point getLocation() {\n\t\treturn location;\n\t}\n\t/** 设置出租车的位置 **/\n\tpublic synchronized void setLocation(Point location) {\n\t\tthis.location = location;\n\t\tif (location.equals(distination)) {\n\t\t\tdispatcher.notifyAvailable(this);\n\t\t}\n\t}\n}\n```\n\n```java\nclass Dispatcher {\n\t@GuardedBy(\"this\") private final Set<Taxi> taxis;\n\t@GuardedBy(\"this\") private final Set<Taxi> availableTaxis;\n\t\n\tpublic Dispatcher() {\n\t\ttaxis = new HashSet<Taxi>();\n\t\tavailableTaxis = new HashSet<Taxi>();\n\t}\n\t\n\tpublic synchronized void notifyAvailable(Taxi taxi) {\n\t\tavailableTaxis.add(taxi);\n\t}\n\t/** 获取某个时刻，整个车队的完整快照 **/\n\tpublic synchronized Image getImage() {\n\t\tImage image = new Image();\n\t\tfor (Taxi t : taxis) {\n\t\t\timage.drawMarker(t.getLocation());\n\t\t}\n\t\treturn image;\n\t}\n}\n```\n\n看看上面的代码，我们就知道setLocation和notifyAvailable方法都是同步方法，调用setLocation的线程首先获取Taxi上的锁，然后获取Dispatcher的锁。getImage方法先获取Dispatcher上的锁，再获取Taxi上的锁，这两个方法被不同的线程调用时容易产生死锁，相信现在的滴滴以及快的绝对不是这么干的。\n\n下面我看看如何通过开放调用来避免这个死锁的问题。\n\n```java\nclass Taxi {\n\t@GuardedBy(\"this\")private Point location, destination;\n\tprivate final Dispatcher dispatcher;\n\tpublic Taxi(Dispatcher dispatcher) {\n\t\tthis.dispatcher = dispatcher;\n\t}\n\t/** 获取出租车的位置 **/\n\tpublic synchronized Point getLocation() {\n\t\treturn location;\n\t}\n\t/** 设置出租车的位置 **/\n\tpublic void setLocation(Point location) {\n\t\tboolean reachedDestination = false;\n\t\t/** 缩小缩的范围 把方法变成开发调用 **/\n\t\tsynchronized(this) {\n\t\t\tthis.location = location;\n\t\t\treachedDestination = location.equals(distination);\n\t\t}\n\t\t\n\t\tif (reachedDestination) {\n\t\t\tdispatcher.notifyAvailable(this);\n\t\t}\n\t}\n}\n```\n\n```java\nclass Dispatcher {\n\t@GuardedBy(\"this\") private final Set<Taxi> taxis;\n\t@GuardedBy(\"this\") private final Set<Taxi> availableTaxis;\n\t\n\tpublic Dispatcher() {\n\t\ttaxis = new HashSet<Taxi>();\n\t\tavailableTaxis = new HashSet<Taxi>();\n\t}\n\t\n\tpublic synchronized void notifyAvailable(Taxi taxi) {\n\t\tavailableTaxis.add(taxi);\n\t}\n\t/** 获取每辆出租车不同时刻的位置 **/\n\tpublic Image getImage() {\n\t\tSet<Taxi> copy;\n\t\tsynchronized(this) {\n\t\t\tcopy = new HashSet<Taxi>(taxis);\n\t\t}\n\t\tImage image = new Image();\n\t\tfor (Taxi t : taxis) {\n\t\t\timage.drawMarker(t.getLocation());\n\t\t}\n\t\treturn image;\n\t}\n}\n```\n\n通过上面的改造，我们把setLocation和getImage都变成了开放调用，与那些持有锁时调用外部方法的程序相比，更容易对依赖的开发调用的程序进行死锁分析。\n\n在编写并发程序的时候，一定要注意一个思想，加锁范围最小化。\n","mtime":1414243890000,"source":"source/_posts/open-call-to-avoid-deadlock.md","_id":"erl4qif1k4y7l5bl"},"49uscxi60e40v57c":{"content":"title: 项目中的点点滴滴\ndate: 2014-10-19 16:21:50\ntags: Experience\ncategories: 编程开发\n---\n####一.概述\n最近一直在忙项目中的事情，不过在整个开发过程中自己也有一些体会，写写这些体会，就当是自己的经验了，这里不会涉及到太深的原理，只是记录一些技巧以及一些值得注意的地方，形成一些编程的思想，理念，可以更好地运用到后续的项目之中。\n\n<!-- more -->\n\n####二.关于Spring定时任务\nSpring定时任务在项目中经常会被使用，我们经常通过限定IP的方式保证我们自己设计的定时任务只会在一台机器上启动，关于Spring定时任务在项目中需要注意一下配置，有时候会漏写一些配置，其实没有必要死记这些配置怎么写，按照正常的思路，你需要指定要运行的任务是什么，其次，既然是定时任务，那就需要指定定时，也就是什么时候运行，最后，任务以及任务要运行的时间都有了，那么如何调度呢？也就是说运行时刻到了，谁来调度这个任务。显然配置Spring定时任务需要把握三个要素，就是上面这三个点，下面我们写一个简单的配置例子来说明一下这三个点\n```xml\n<!-- 1.指定要运行的任务 -->\n<bean id=\"autoAuditFailedTaskJobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\n   <property name=\"concurrent\">\n        <value>false</value>\n   </property>\n   <property name=\"targetObject\">\n       <ref bean=\"autoAuditFailedTask\" />\n   </property>\n   <property name=\"targetMethod\">\n       <value>execute</value>\n   </property>\n</bean>\n <!-- 2.配置触发器 -->\n<bean id=\"autoAuditFailedTaskCronTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerBean\">\n    <!-- 这里不可以直接在属性jobDetail中引用taskJob，因为他要求的是一个jobDetail类型的对象，所以我们得通过MethodInvokingJobDetailFactoryBean来转一下 -->\n   <property name=\"jobDetail\">\n       <ref bean=\"autoAuditFailedTaskJobDetail\" />\n   </property>\n   <!-- 每天晚上23:00点触发  -->\n   <property name=\"cronExpression\">\n       <value>0 0 23 * * ?</value>\n   </property>\n</bean>\n\n<!-- 3. 添加调度器 -->\n<bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n   <property name=\"triggers\">\n       <list>\n          <ref local=\"autoAuditFailedTaskCronTrigger\" />\n       </list>\n   </property>\n</bean>\n```\n在配置的时候注意这三个点，缺一不可。\n\n####三.关于NPE\n我们在写代码的时候经常会考虑NPE的问题，对于参数经常会做NPE校验，在对每一个参数做NPE校验的时候一定要想一下该参数是否一定不为NULL，不要一味地追求NPE。\n\n####四.关于时间的加减以及格式化\n经常有这样的需求，需要把当前时间向前或者向后推算N天，以及对时间做格式化\n```java\nCalendar calendar = Calendar.getInstance();\ncalendar.setTime(new Date());\n// n可以为正数，也可以为负数\ncalendar.add(Calendar.DAY_OF_MONTH, n);\n// 时间格式化\nDateFormat format = new SimpleDateFormat(\"MM/dd\");\nformat.format(calendar.getTime());\n```\n####五.关于xstream\nxstream可以实现XML和Object之间的相互转换\n```xml\n<dependency>\n  <groupId>com.thoughtworks.xstream</groupId>\n  <artifactId>xstream</artifactId>\n  <version>1.4.7</version>\n</dependency>\n```\n```java\npublic class Person {\n\n    private int     age;\n    private SexEnum sex;\n    private String  name;\n\n    public int getAge() {\n        return age;\n    }\n\n    public SexEnum getSex() {\n        return sex;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public void setSex(SexEnum sex) {\n        this.sex = sex;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n```java\npublic enum SexEnum {\n    MALE(\"M\"), FEMALE(\"F\");\n\n    String value;\n\n    SexEnum(String value){\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n\n    public static SexEnum parse(String value) {\n        for (SexEnum sexEnum : SexEnum.values()) {\n            if (value.equals(sexEnum.getValue())) {\n                return sexEnum;\n            }\n        }\n        return null;\n    }\n}\n```\n```java\npublic class XStreamTest {\n    public static void main(String[] args) {\n        // Object TO XML\n        List<Person> personList = new ArrayList<Person>();\n        Person person1 =  new Person();\n        person1.setAge(22);\n        person1.setName(\"nuaa\");\n        person1.setSex(SexEnum.MALE);\n        personList.add(person1);\n        \n        Person person2 =  new Person();\n        person2.setAge(22);\n        person2.setName(\"buaa\");\n        person2.setSex(SexEnum.MALE);\n        personList.add(person2);\n        \n        XStream xstream = new XStream();\n        // 使用别名\n        xstream.alias(\"person\", Person.class);\n        xstream.alias(\"personList\", List.class);\n        // 注册枚举转换器\n        xstream.registerConverter(new AbstractSingleValueConverter(){\n            @Override\n            public boolean canConvert(@SuppressWarnings(\"rawtypes\") Class type) {\n                if (type.equals(SexEnum.class)) {\n                    return true;\n                }\n                return false;\n            }\n            // String转换成对象\n            @Override\n            public Object fromString(String str) {\n                return SexEnum.parse(str);\n            }\n\n            // 对象转换成String\n            @Override\n            public String toString(Object obj) {\n                SexEnum sexEnum = (SexEnum)obj;\n                return sexEnum.getValue();\n            }\n        });\n        \n        String xml = xstream.toXML(personList);\n        System.out.println(xml);\n\n        // XML TO Object\n        @SuppressWarnings(\"unchecked\")\n        List<Person> fromXMLList = (List<Person>)xstream.fromXML(xml);\n        System.out.println(fromXMLList);\n        for(Person person : fromXMLList) {\n            System.out.println(\"#############################\");\n            System.out.println(\"age: \" + person.getAge());\n            System.out.println(\"sex: \" + person.getSex());\n            System.out.println(\"name: \" + person.getName());\n        }\n    }\n}\n```\n使用xtream可以避免自己解析XML文件。\n\n####六.关于fastjson\nfastjson把对象转化成json字符串时会出现$ref，这是由于对象之间有循环引用导致，这有可能导致堆栈溢出，我们可以使用\n```java\nJSON.toJSONString(object,  SerializerFeature.DisableCircularReferenceDetect)\n```\n来避免json串中出现$ref。","mtime":1413713302000,"source":"source/_posts/project-accumulation-1.md","_id":"49uscxi60e40v57c"},"g2ubhxuzjhx73cu5":{"content":"title: 操作系统定时调度\ndate: 2015-05-18 20:13:29\ntags: crontab\ncategories: 编程开发\n---\n####一.概述\n最近需要开发一些定时任务，提到定时任务，我们都会想到quartz，为了让我们的定时任务能够更加灵活的被控制，我们通过shell脚本去执行一个java类，然后定时去执行这个shell脚本即可。如何去定时执行这个shell脚本，我们想到Linux本身提供后台进程去定时执行一些命令，那就是crontab，因此我们编写好自己的shell脚本再写好crontab后就能定时执行我们的任务了。\n\n<!-- more -->\n\n####二.如何配置\n* 查看crontab的配置\ncrontab -l\n* 编辑crontab的配置\ncrontab -e\n* crontab的格式说明\n![crontab格式说明](http://bolinyoung.qiniudn.com/crontab.jpg)\n\n* less  /var/log/cron\n查看crontab运行时的日志\n\n####三.注意点\n```shell\n* 6 * * * sh xx.sh\n```\n表示每天凌晨6点开始没分钟执行一次sh xx.sh脚本\n\n```shell\n0 6 * * * sh xx.sh\n```\n表示每天凌晨6点开始执行一次sh xx.sh脚本，只执行一次\n\n注意上面这两个频率的区别，排查问题的时候注意考虑那些一直被忽略的点，有可能那些点就是解决问题的关键之所在。","mtime":1431997112000,"source":"source/_posts/os-timer-call.md","_id":"g2ubhxuzjhx73cu5"},"2p6yexlmd6la3aff":{"content":"title: 一次关于servlet的扩展\ndate: 2014-11-17 22:43:31\ntags: servlet\ncategories: web开发\n---\n\n####一.需求\n现有一个web框架，从HttpServletRequest中获取调用request.getParameter(\"orderId\")获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。\n\n<!-- more -->\n\n####二.实现思路\n1.直接先解密orderId，然后再修改request中的orderId，你会发现你没法修改，servlet规范不允许修改request。\n2.对HttpServletRequest进行包装，在进入web框架的时候把这个HttpServletRequest包装一下\n```java\npublic class MyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n\n    private Map<String, String> param = new HashMap<String, String>();\n\n    /**\n     * @param request\n     */\n    public MyHttpServletRequestWrapper(HttpServletRequest request) {\n        super(request);\n    }\n\n    // 重写获取参数值的方法\n    @Override\n    public String getParameter(String name) {\n        if (param.containsKey(name)) {\n            return param.get(name);\n        }\n        return super.getParameter(name);\n    }\n\n    public void addParameter(String name, String value) {\n        param.put(name, value);\n    }\n}\n```\n增加解密orderId的filter\n```java\npublic class MyOrderIdFilter implements Filter {\n    @Override\n    public void destroy() {\n    }\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse servletResponse, FilterChain filterChain)                                                                   throws IOException,                                                         ServletException {\n        String orderId = request.getParameter(\"orderId\");\n        // 对orderId解密\n        orderId = WebUtils.decode(orderId);\n        MyHttpServletRequestWrapper myRequestWrapper = new MyHttpServletRequestWrapper(                        (HttpServletRequest) request);\n        myRequestWrapper.addParameter(\"orderId\", orderId);\n        // 把包装后的Request传递给下一个Filter\n        filterChain.doFilter(myRequestWrapper, servletResponse);\n    }\n    @Override\n    public void init(FilterConfig arg0) throws ServletException {\n    }\n}\n```\n","mtime":1416236361000,"source":"source/_posts/servlet-extend.md","_id":"2p6yexlmd6la3aff"},"1qhqwt02dioswg8i":{"content":"title: Short对象的比较\ndate: 2014-12-26 23:02:20\ntags: JAVA\ncategories: 编程开发\n---\n####一.背景\n今天和同事一起分析线下问题，发现代码中有个笔误，对两个Short类型的对象使用==来比较，结果是比较表达式一直为false，导致一个bug的产生。\n\n<!-- more -->\n\n####二.分析\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        Short s = 100;\n        Short s1 = 100;\n        // true\n        System.out.println(s1 == s);\n\n        Short t = 129;\n        Short t1 = 129;\n        // false\n        System.out.println(t1 == t);\n        \n        Short m = new Short(\"100\");\n        Short m1 = new Short(\"100\");\n        // false\n        System.out.println(m1 == m);\n    }\n}\n```\n写了一小段代码，模拟今天遇到的问题。我们看到第一个输出为true，第二个输出为false，第三个输出为false。为什么呢？我们来看一下生成的字节码。\n\n```java\nCode:\n   // Stack表示操作数栈的最大深度\n   // Locals表示局部变量表所需的存储空间，单位是Slot，JVM为局部变量分配内存所使用的最小单位，double和long占用了两个Slot\n   // Args_size 表示方法参数个数，main函数只有一个参数，当然size为1了\n   // 明明main方法中只有6个局部变量，为啥空间大小是7,别忘了第一个存储的是调用方法的实例，如果是静态方法存储的是类实例，如果是非静态方法存储的是this引用。\n   Stack=3, Locals=7, Args_size=1\n\n   0:\tbipush\t100\n   // 这里调用了Short类的静态方法valueOf,待会分析valueOf的实现\n   2:\tinvokestatic\t#16; //Method java/lang/Short.valueOf:(S)Ljava/lang/Short;\n   5:\tastore_1\n   6:\tbipush\t100\n   8:\tinvokestatic\t#16; //Method java/lang/Short.valueOf:(S)Ljava/lang/Short;\n   11:\tastore_2\n   12:\tgetstatic\t#22; //Field java/lang/System.out:Ljava/io/PrintStream;\n   15:\taload_2\n   16:\taload_1\n   17:\tif_acmpne\t24\n   20:\ticonst_1\n   21:\tgoto\t25\n   24:\ticonst_0\n   25:\tinvokevirtual\t#28; //Method java/io/PrintStream.println:(Z)V\n   28:\tsipush\t129\n   31:\tinvokestatic\t#16; //Method java/lang/Short.valueOf:(S)Ljava/lang/Short;\n   34:\tastore_3\n   35:\tsipush\t129\n   38:\tinvokestatic\t#16; //Method java/lang/Short.valueOf:(S)Ljava/lang/Short;\n   41:\tastore\t4\n   43:\tgetstatic\t#22; //Field java/lang/System.out:Ljava/io/PrintStream;\n   46:\taload\t4\n   48:\taload_3\n   49:\tif_acmpne\t56\n   52:\ticonst_1\n   53:\tgoto\t57\n   56:\ticonst_0\n   57:\tinvokevirtual\t#28; //Method java/io/PrintStream.println:(Z)V\n   60:\tnew\t#17; //class java/lang/Short\n   63:\tdup\n   64:\tldc\t#34; //String 100\n   // 这里直接调用了Short的构造函数\n   66:\tinvokespecial\t#36; //Method java/lang/Short.\"<init>\":(Ljava/lang/String;)V\n   69:\tastore\t5\n   71:\tnew\t#17; //class java/lang/Short\n   74:\tdup\n   75:\tldc\t#34; //String 100\n   // 这里直接调用了Short的构造函数\n   77:\tinvokespecial\t#36; //Method java/lang/Short.\"<init>\":(Ljava/lang/String;)V\n   80:\tastore\t6\n   82:\tgetstatic\t#22; //Field java/lang/System.out:Ljava/io/PrintStream;\n   85:\taload\t6\n   87:\taload\t5\n   89:\tif_acmpne\t96\n   92:\ticonst_1\n   93:\tgoto\t97\n   96:\ticonst_0\n   97:\tinvokevirtual\t#28; //Method java/io/PrintStream.println:(Z)V\n   100:\treturn\n```\n\n我们在字节码中看到有调用Short的valueOf方法，那么接下来我们看看valueOf方法的实现。\n\n```java\n...\nprivate static class ShortCache {\n\tprivate ShortCache(){}\n\n\tstatic final Short cache[] = new Short[-(-128) + 127 + 1];\n\n\tstatic {\n\t    // 缓存[-127,128]之间的Short对象\n\t    for(int i = 0; i < cache.length; i++)\n\t\tcache[i] = new Short((short)(i - 128));\n\t}\n}\n...\npublic static Short valueOf(short s) {\n\tfinal int offset = 128;\n\tint sAsInt = s;\n\t// 走缓存\n\tif (sAsInt >= -128 && sAsInt <= 127) { // must cache \n\t    return ShortCache.cache[sAsInt + offset];\n\t}\n        return new Short(s);\n}\n...\n```\n看完valueOf的实现，你就明白这一切了，首先使用=赋值的时候会调用valueOf(S)这个方法，S标识short，在这方法中如果要赋予的值在[-127,128]这个区间内，那么直接取缓存中的值，缓存中缓存了[-127,128]这个区间内的所有Short对象，如果Short的值在这个区间内，你使用=赋值，直接取缓存，至此上面的问题就不言而喻了。\n\n####三.总结\n> 1.写代码的时候最好不要使用==来比较任何类型的引用，除非是基本类型，不然很容易出问题，导致某些场景下面没问题，某些场景下面有问题。\n> 2.Long类型也有类似的机制。\n","mtime":1419647427000,"source":"source/_posts/short-ref-equal.md","_id":"1qhqwt02dioswg8i"},"0ula9ovunoh3lhdn":{"content":"title: 如何不用修改原来的代码呢？\ndate: 2014-04-15 19:58:15\ntags: Spring\ncategories: 编程开发\n---\n\n####一.需求描述\n最近遇到这样一个需求，有个数据计算的方法，我们需要优化一下，因为有些数据在一段时间内计算出的结果总是一样的，为了提高性能，我们把这些数据的计算结果缓存起来，这样下次计算的时候就先去缓存中查一下，要是缓存中存在，就直接把缓存中的数据返回，要是缓存中不存在就走原来的计算逻辑去计算，面对这个需求，我们需要做两件事情，在调用计算方法之前读取一下缓存，在调用方法之后把值写入缓存。这样的计算方法有10多个，相应的类也有10多个。\n\n<!-- more -->\n\n####二.思路分析\n面对这样的需求，绝对不能去修改10多个类，首先这样做有很多工作量，其次你所做的事情都是Repeat Yourself,没意义的。其实这种需求，我们最容易想到的就是AOP理念了，定义两个切面，方法执行前执行一下，方法返回前执行一下就好，为了好描述，我们暂且认为读缓存的切面是A,写缓存的切面是B,仔细分析一下，我们执行完切面A后，可能不需要再继续执行原来的计算方法了，直接返回就完事了，要是我们把读缓存的单独抽象出一个切面来，我们在这个切面中根本没法控制不去执行被拦截的计算方法，因此我们不能把读取缓存这个逻辑单独抽象成一个Spring AOP的切面，所以上面抽象出A,B切面的思路不可行，这时候我们需要正对这些方法定义一个统一的MethodInterceptor去拦截一下这个方法，在执行方法之前去读一下缓存，执行方法之后写一下缓存，这样写出来的伪代码如下：\n```java\npublic class XXXMethodInterceptor implements MethodInterceptor {\n\n    private static final String METHOD_NAME = \"xxxx\";\n\n    @Override\n    public Object invoke(MethodInvocation arg) throws Throwable {\n        // 对xxxx方法做拦截\n        if (METHOD_NAME.equals(arg.getMethod().getName())) {\n                // 读取缓存，要是缓存中有值，直接返回\n                Object cacheResult = readFromCache();\n                if (cacheResult != null) {\n                    return cacheResult;\n                }\n                // 调用原来的方法\n                Object result = arg.proceed();\n                // 写缓存,当然有些计算结果是不用写缓存的\n                writeCache(result);\n                // 返回结果\n                return resultFromDataSource;\n            }\n        }\n        return arg.proceed();\n    }\n}\n```\n\n这样我们的方法拦截器就定义好了，如何把它织入到原来的代码逻辑中，我们使用Spring的ProxyFactoryBean,这是一个代理的工厂bean,它可以返回被代理的bean，同时把我们的拦截逻辑织入到代理bean中，生成代理对象的时候如果我们的类实现了接口，就会使用jdk的动态代理，重新生成一个代理类，要是我们的类没有实现接口，就会使用cglib动态去修改字节码。下面我们来看看如何织入我们的拦截逻辑\n```xml\n<!-- 定义抽象的代理bean -->\n<bean id=\"abstractProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\" abstract=\"true\">\n\t<property name=\"interceptorNames\">\n\t\t<list>\n\t\t\t<value>xXXXMethodInterceptor</value>\n\t\t</list>\n\t</property>\n</bean>\n<!-- 拦截器的定义 -->\n<bean id=\"xXXXMethodInterceptor\" class=\"xxxx.xxx.XXXMethodInterceptor\" />\n<!-- 新定义一个bean 织入我们的拦截器 -->\n<bean id=\"xxxx\" parent=\"abstractProxy\">\n\t<property name=\"target\">\n\t\t<bean class=\"xxxxxxx.xxxxx\" />\n    </property>\n</bean>\n```\n注意:\n\n* 1.我们可以在ProxyFactoryBean中定义多个拦截器，目前只是定义了一个方法的拦截器\n* 2.在写Spring配置文件的时候注意抽象bean的灵活使用\n","mtime":1397566219000,"source":"source/_posts/spring-aop-practice.md","_id":"0ula9ovunoh3lhdn"},"atwwpmgw1q3853f6":{"content":"title: 关于系统架构设计的心得(一)\ndate: 2016-04-17 21:33:06\ntags: 架构\ncategories: 架构设计\n---\n\n####一.概述\n关于系统的架构设计，其实有很多内容，要想设计出足够灵活的软件系统，确实不是一件容易的事情，特别是面对我们日新月异的业务，业务的变动完全可以推翻你之前所做的所有设计，如何在复杂的业务中剥离出一些固定的规律，这大概就是系统架构的主要目的了。要想做好系统架构，你需要对业务有一个宏观层面的认识和理解，需要把你所面对的业务模块化，结构化，然后再针对每个模块每个结构进行详细的设计。当然这些模块的划分以及抽象，也需要你有一定的经验。\n\n<!-- more -->\n\n下面从模块划分，模型，关系，以及系统交互层面写写自己在设计方面的心得体会。\n\n####二.模块划分\n模块的划分，是系统架构的首先要考虑的问题，我们当前的系统有那些模块，首先我们要考虑的是一个核心模块，我们需要对我们的业务作出一个高度的抽象，把一些共性的东西抽取出来，形成我们的核心系统模块，也就是我们的系统内核，基于系统内核，我们再抽象出一些个性化模块支持差异化的业务，但是核心模块在整个业务发证过程中应该保持不变，或者只需要微调就可以了。<font color=red>话虽这么说，但是达到这个目的并不是很容易，需要你有全局观才能保持内核模块的健壮和鲁棒。</font>\n其实做的好的话，你的内核模块是用来驱动你的差异化模块的，执行到某个核心的动作的时候，可以路由到具体的差异化模块中去执行。\n\n####三.模型\n模型，非常重要，一个模型的设计决定了系统的能够支持的功能，如果模型设计的非常灵活，那么系统能支持的功能也就非常多。所以在设计模型的时候要仔细斟酌，模型中的每一个字段都要思考。看看那些东西是必须的，那些东西是毫无规律的，必须的并且毫无规律的东西都需要在模型中体现出来。那些有规律的可以通过配置来解决，有些场景必须有些场景不是必须的可以通过差异化存储来解决，差异化存储就是通过一个JSON字符串来存储，这是我目前经常使用的手段，而且在很多时候都非常有效。\n\n####四.关系\n关系，也就是模型和模型之间的关系，一对多，多对多等等，模型梳理出来后，模型之间的关系其实显而易见。如果你的模型和模型之间的关系非常复杂，那就说明你梳理出来的模型是不合理的，我们之所以做设计，一个根本的目的就是把复杂的事情简单化，而不是把复杂的事情复杂化，把一个PD看来很复杂的业务做成一个开发看来很复杂的系统。\n\n####五.系统交互\n关于系统交互，对于外部的系统，尽量先落库再处理。\n①先落库，马上去处理，处理完后更新数据，这个是资金操作时需要考虑的一个原则。\n②先落库，然后异步处理，直到处理成功或者处理一定次数后挂起，这也是一个简单但是非常重要的原则，因为你可以保证自身系统的稳定性，但是你无法要求你依赖的系统和你一样稳定。\n③重要的操作，不要直接通过消息来交互，虽然消息解耦并且异步，但是你承受不起丢消息给你带来的排查和修复所浪费的时间成本。","mtime":1460985219000,"source":"source/_posts/software-design.md","_id":"atwwpmgw1q3853f6"},"cu0puempmira93aq":{"content":"title: Spring容器的事件机制 \ndate: 2014-07-07 13:08:20 \ntags: Spring \ncategories: 编程开发\n---\n\n\n####一.概述 \nSpring容器暴漏了很多扩展点给框架的使用者，让框架的使用者能够干涉一些容器内部的事情，也让框架的使用能够感知到容器内部发生了什么事情，比如Spring容器在初始化完后，就会广播一个容器初始化完成的事件，然后事件的监听者监听到这个事件后做相应的事情，这也是Spring容器的一个非常有用的扩展点。\n\n<!-- more -->\n\n####二.事件相关的类图 \n\n![Spring事件机制相关的类图](http://bolinyoung.qiniudn.com/Spring-Event.png)\n\n上面这张类图就是Spring事件机制涉及到的一些核心类图。关于事件机制核心的接口有两个ApplicationEventMulticaster和ApplicationListener,前者是事件的广播中心接口，主要负责事件的广播和监听者的注册，后者是事件监听接口,还有一个事件对象ApplicationEvent，定义事件相关的属性，比如事件的类型，事件关联的数据，不过Spring中并没有定义相关的事件类型，不同的事件对应不同的类，比如ContextRefreshedEvent，表示Spring容器上下文初始化结束了。\n\n其实事件这个概念在我们日常的开发中经常会被用到，很多人喜欢设计一个事件模块，要是让你去设计一个事件模块的话，需要考虑三个点，事件本身的定义，包括事件的类型以及事件所包含的数据，其次，需要定义事件的广播机制，一般有同步和异步，最后当然就是事件监听者的定义了，在监听者内部定义如何响应各自感兴趣的事件。\n\n#####三.Spring事件机制的巧妙使用\nSpring容器在初始化完成后，会发广播一个容器初始化OK的事件出来，我们可以在每个bean注册一个监听上下文刷新成功的事件，等上下文刷新成功了，我们在用这个bean去做一些其他事情。\n```java\npublic class XXBean implements InitializingBean, ApplicationContextAware\n    // 把Spring容器注入到这个bean中\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        if (applicationContext instanceof AbstractApplicationContext) {\n            AbstractApplicationContext apc = (AbstractApplicationContext)applicationContext;\n            // 注册新listener\n            apc.addListener(new XXXApplicationListener());\n        }\n    }\n\n    private final class XXXApplicationListener implements ApplicationListener {\n        @Override\n        public void onApplicationEvent(ApplicationEvent event) {\n            if (event instanceof ContextRefreshedEvent) {\n                // 这时候这个bean已经在Spring容器中初始化OK了\n                XXBean.this.xxx.xxx // 使用初始化好的bean中的相关属性做一些事情\n            }\n        }\n    }\n}\n```","mtime":1405006824000,"source":"source/_posts/spring-application-event.md","_id":"cu0puempmira93aq"},"to8b3ss0zpt15tbu":{"content":"title: 谈谈自己对Spring IOC 和 AOP理解\ndate: 2014-04-19 15:56:47\ntags: Spring\ncategories: 编程开发\n---\n\n####一.谈谈自己对IOC的理解\nSpring提供了一个容器，把我们业务代码中需要的一些bean都管理起来，这个Spring容器负责管理这些bean的生命周期，同时保证被依赖的bean能够正确找到自己所属的bean,能够根据代码中的依赖关系正确的实例化一个bean。要是没有Spring容器，我们就需要自己去创建bean，同时设置bean所依赖的bean，Spring容器把这些事情从业务代码中剥\n\n<!-- more -->\n\n离出来，实现解耦。IOC其实就是控制反转，它所要解决的问题就是一个对象如何获取它所依赖的对象，这个问题包含两层含义：假如对象A依赖对象B，A在获取对象B的时候先要创建对象B，然后把对象B设置到A的某个属性，其实这就是两件事情，那么现在的问题就是这两件事情由谁来做的问题了，首先对象A完全可以自己做这两件事情，new一个对象B然后赋值给其中某个字段，IOC的理念是B的创建和设置都不用A亲自去做，由Spring容器来做，这样A从之前自己动手去做变成了让别人去做，自己享用，这样关于对象B的获取A就不用关心了，IOC保证A在使用B的时候，B是现成的，其实完全可以理解为IOC就是把对象创建以及获取的责任托管给Spring容器了，这是一种责任的托管，这样就会有很多创建对象并且赋值的代码从我们的业务逻辑中剥离出来，从而使得我们在编写业务逻辑的时候不用再写对象的创建以及对象复制，只要我们愿意把这两件事情交由Spring容器来做。\n\n####二.谈谈自己对AOP的理解\n在IOC的基础上出现了AOP的编程理念，所谓AOP就是面向切面编程，我们在编写一些业务逻辑代码的时候，经常会出现一个共性的逻辑，为了避免把这些共性的逻辑和一些特性的逻辑耦合在一起，我们可以把这些共性的逻辑抽取出来，变成一个横切逻辑，AOP负责把这些横切逻辑织入到我们指定的一些地方去。AOP最终通过代理或者动态修改字节码的方式来执行我们的横切逻辑，默认情况下，要是类实现了接口，直接走JDK的动态代理，要是类没有实现接口，就基于ASM动态修改类的字节码。要是采用JDK的动态代理，这样每次生成的代理都会增加到perm区，占据一定的内存空间，同样我们需要注意一点，jdk每次生成的代理都会被增加上ACC_FINAL的标志，就是说生成的代理类是一个final类，这个类不允许被继承，也就不允许被再次代理。其实JDK的proxy之所以这么搞，我觉得是出于JVM层次的优化，首先，final类不允许被继承，这样final类中的方法就不会被重写，这样在调用的时候JVM就不会动态去寻找调用方法的地址，其次，我们想假设类A被代理成proxyA，要是proxyA再次被代理成proxyB的话，这时候proxyA其实在系统中已经没啥用了，但是proxyA在perm区还占据了一定内存空间，这会给JVM的GC带来负担。\n","mtime":1397896012000,"source":"source/_posts/spring-ioc-aop-idea.md","_id":"to8b3ss0zpt15tbu"},"sia9d6rkfp1bvk3h":{"content":"title: Spring的一些小事\ndate: 2016-11-12 21:55:20\ntags: Spring\ncategories: 开源框架\n---\n\n最近有同事看到下面的代码\n```java\npublic class A implements IA {\nprivate B b;\npublic void setB(B b){}\n}\npublic class B implements IB {\n}\n```\nSpring的配置文件如下\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns:context=\"http://www.springframework.org/schema/context\"\nxmlns:tx=\"http://www.springframework.org/schema/tx\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans-2.5.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context-2.5.xsd\nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx-2.5.xsd\"\ndefault-autowire=\"byName\">\n<bean id=\"a\" class=\"A\" />\n<bean id=\"b\" class=\"B\" />\n</beans>\n```\n这样的代码在运行时a这个bean中的b能注入吗？因为setter方法的注入需要在配置文件中显示去写属性的\n```xml\n<bean id=\"a\" class=\"A\">\n<property name=\"b\" ref=\"b\"/>\n</bean>\n```\n需要这样写才可以，为啥不写也可以呢？我当时也看了半天，最后发现是XML头部schema中的\n```\ndefault-autowire=\"byName\"\n```\n导致。很简单一个写法，但是一般我们不会直接在XML的头部带上这个的。\n\n另外最近又重温了一遍Spring的源码，发现了下面这个接口中两个方法\n```java\npublic interface ConfigurableListableBeanFactory\nextends ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory {\n\n/**\n* Ignore the given dependency type for autowiring:\n* for example, String. Default is none.\n* @param type the dependency type to ignore\n*/\nvoid ignoreDependencyType(Class type);\n\n/**\n* Ignore the given dependency interface for autowiring.\n* <p>This will typically be used by application contexts to register\n* dependencies that are resolved in other ways, like BeanFactory through\n* BeanFactoryAware or ApplicationContext through ApplicationContextAware.\n* <p>By default, only the BeanFactoryAware interface is ignored.\n* For further types to ignore, invoke this method for each type.\n* @param ifc the dependency interface to ignore\n* @see org.springframework.beans.factory.BeanFactoryAware\n* @see org.springframework.context.ApplicationContextAware\n*/\nvoid ignoreDependencyInterface(Class ifc);\n....\n}\n```\n看上面的注释不是很明白，ignoreDependencyType和ignoreDependencyInterface，从方法名来看一个是忽略某些类的依赖，一个是忽略某些接口的依赖。什么意思呢？在Spring中我们经常使用的是面向接口的编程，也就是在自动注入中，如果发现接口或者类被ignoreDependency了，就不会自动注入了。比如说你不能自动注入BeanFactory和ApplicationContext，它们必须通过BeanFactoryAware和ApplicationContextAware来注入，其实直接看英文注释也非常简单。\n\n\n\n\n","mtime":1478960085000,"source":"source/_posts/spring-work-01.md","_id":"sia9d6rkfp1bvk3h"},"f7gfthyubuy0u015":{"content":"title: 谈谈sql语句中的group by\ndate: 2014-04-13 20:39:50\ntags: sql\ncategories: 数据库\n---\n\n####一.概述\n我们经常使用sql语句来从数据库中查询一批数据出来，有时候我们需要把查询出来的数据分组，然后进行其他操作，比如统计，在实现这个需求的时候我们就会用到group by，从字面来解释按照XX来分组，到底按照什么来分组，需要我们在写sql语句的时候显式地指定，可以指定一个字段，也可以指定多个字段，通常group by和sql的函数结合起来使用。\n\n<!-- more -->\n\n####二.语法\n```sql \nSELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE condition\nGROUP BY column_name1...column_nameN\nHAVING condition\n```\n注意:\n\n* aggregate_function表示sql的一些内聚函数，例如count，sum等\n* WHERE不是必须的\n* GROUP BY后面可以指定多个字段，最后每个分组中，这几个字段的值都是一样的\n* HAVING 可以选出符合某些条件的组，放弃一些不符合条件的组，在HAVING子句中我们也可以使用一些sql的内聚函数\n\n####三.实例\n假如我们有如下的表member_trade_record\ntrade_type表示交易类型，线上or线下\n\nid        | member_id | trade_money | trade_type |\n--------- | --------- | --------- | --------- |\n1         | nuaa_2012 | 1200        | ONLINE     |\n2         | nuaa_2013 | 1201        | OFFLINE    |\n3         | nuaa_2014 | 1202        | ONLINE     |\n4         | nuaa_2012 | 200         | OFFLINE    |\n5         | nuaa_2013 | 300         | OFFLINE    |\n\n现在需要统计每个人的交易总额，可以使用如下语句\n```sql\nselect memer_id, sum(trade_money) from member_trade_record group by member_id\n```\n输出如下：\n\nmember_id | sum(trade_money) |\n--------- | --------- |\nnuaa_2012 | 1400 |\nnuaa_2013 | 1501 |\nnuaa_2014 | 1202 |\n\n现在需要统计每个人线上线下的交易总额分别是多少,这时候就需要制定多个字段了\n```sql\nselect member_id, trade_type, sum(trade_money) from  member_trade_record group by member_id, trade_type\n```\n输出如下：\n\nmember_id | trade_type | sum(trade_money) |\n--------- | --------- | --------- | \nnuaa2012  | ONLINE    | 1200      |\nnuaa2012  | OFFLINE   | 200       |\nnuaa2013  | OFFLINE   | 1501      |\nnuaa2014  | ONLINE    | 1202      |\n\n现在我们需要选出交易总额大于等于1500的会员\n```sql\nselect member_id, sum(trade_money) from member_trade_record group by member_id having sum(trade_money) >= 1500\n```\n输出如下:\n\nmember_id | sum(trade_money) |\n--------- | --------- |\nnuaa_2013 | 1501 |\n\n####四.总结\n我们不使用group by也可以实现上面的需求，但是使用group by我们能更快更优雅的实现上面的需求，要是想对group by后的组进行更细粒度的筛选，就必须使用having子句来实现了。\n\n","mtime":1399781979000,"source":"source/_posts/sql-group-by.md","_id":"f7gfthyubuy0u015"},"g8g059wkv9cdv87s":{"content":"title: 一个sql问题的排查\ndate: 2014-04-21 19:26:01\ntags: sql\ncategories: 数据库\n---\n\n####一.现象\n线上一台任务机对一张mysql表进行全表扫描，当扫描过程中有一行记录读出来做数据转换，发现有很多行被多次读出来，并且多次尝试去做数据转换，同时数据转换也就失败了，因此也就打出了error级别的日志。\n\n<!-- more -->\n\n####二.分析\n由于这个任务是在遍历表，因此我们直接找到相应的sql语句看看，下面就是找到的sql语句\n```xml\n<![CDATA[\n\tselect xxx,xxxx\n\tfrom xxxxyyyyy\n\twhere gmt_create >=  #beginTime#\n    and gmt_create <  #endTime#\n    and id >= #idBegin#\n    limit #pageSize#     \n]]>\n```\n上面的sql在一个循环中会不断被调用，下面我们先来看看调用这个sql的java代码\n```java\n// 找到数据库中最大的主键ID\nlong maxId = findCompanyMaxId(TABLE_NAME);\n// 循环次数\nlong loopTime = 1;\ndo {\n    // 计算开始id\n    long idBegin = maxId - loopTime * SCOPE_OF_EACH_LOOP + 1;\n    long idEnd = maxId - (loopTime - 1) * SCOPE_OF_EACH_LOOP;\n\n    List<Xxxx> currentList = null;\n\n    if (idBegin > 0) {\n        // 调用上面的sql语句获取数据,beginTime和endTime在这个方法中设置，因为这个两个值可以系统当前时间推算出来\n        currentList = xxDAO.getListFromMaxId(days, TABLE_NAME, TABLE_PK, idBegin, idEnd);\n    } else {\n        // 退出循环\n        break;\n    }\n    \n    if (currentList == null || currentList.size() == 0) {\n        // 退出循环\n        break;\n    }\n} while (true);\n```\n\n上面的代码很简单，先找出数据库中表主键的最大ID，select max(id) from ...即可，然后每次把maxId向前推进SCOPE_OF_EACH_LOOP,这样就能不断遍历这张表了。我们假设第一次获取到的maxId为9000,每次向前推进1000，pageSize=1000,这样第一调用sql时的idBegin=9000 - 1000 + 1 = 80001,这时候我们取出满足条件的limit 1000条记录，但是最终结果可能不足1000条，因为有beginTime和endTime的限制，好了第一次调用这个sql没啥问题的，后面我们考虑一次sql的调用，idBegin = 9000 - 2 * 1000 + 1 = 7001,这时候我们指定的idBegin=7001,limit大小为1000，其实这个sql的本质期望是扫描[7001,8000]之间的记录，但是[7001,8000]之间符合条件的记录又不足1000条，这样就会从[80001,9000]之间再去取一些行来补足1000行，谁让你写了1000呢？但是[8001,9000]之间的记录明显已经被扫描过了，以此类推数据的重复扫描就会发生了，悲剧由此而产生，只能说这种sql写的太没水平了。\n\n####三.解决办法\n修改sql，删掉limit，增加idEnd的限制，修改后的sql如下:\n```xml\n<![CDATA[\n\tselect xxx,xxxx\n\tfrom xxxxyyyyy\n\twhere gmt_create >=  #beginTime#\n    and gmt_create <  #endTime#\n    and id >= #idBegin#\n    and id <= #idEnd#\n]]>\n```\n注意:\n\n* 当sql语句中出现了limit并且有比较关系的时候，注意考虑sql语句会不会出现重复扫描数据的逻辑。\n","mtime":1399531695000,"source":"source/_posts/sql-error-analyse.md","_id":"g8g059wkv9cdv87s"},"e8ohmz84f73uufba":{"content":"title: SQL的JOIN总结\ndate: 2014-06-03 19:42:36\ntags: sql\ncategories: 数据库\n---\n\n####一.概述\n关系型数据库最大的优点就是关联查询，既所谓的JOIN，不像HBase这种Nosql的数据库，对于表和表的JOIN不怎么支持，关于SQL中的JOIN比较多，也不太好记忆，为了在后续开发中对SQL中的JOIN灵活使用，这里总结一些SQL中的一些JOIN。\n\n<!-- more -->\n\n####二.假设存在的表以及相关数据\n假设table_a中的数据如下\n![table_a](http://bolinyoung.qiniudn.com/table_a.png)\n假设TableB中的数据如下\n![table_b](http://bolinyoung.qiniudn.com/table_b.png)\n\ntable_a和table_b中有两行的name是一样的，table_a的3,4行和table_b的1,2行\n####三.各种JOIN的示例\n```sql\nSELECT * FROM table_a A  LEFT JOIN table_b B ON A.name = B.name\n```\n![执行结果](http://bolinyoung.qiniudn.com/sql1.png)\n\n上面SQL执行的时候以左表中的数据为基准，左表A中的数据都会出现在最终的结果中，但是右表A中的数据只有匹配到的数据参会出现在左表中。\n\n```sql\nSELECT * FROM table_a A  LEFT JOIN table_b B ON A.name = B.name WHERE B.name IS NULL\n```\n![执行结果](http://bolinyoung.qiniudn.com/sql2.png)\n> 注意:\n> LEFT OUTER JOIN 和 LEFT JOIN 效果一样\n\n上面的执行结果表示只出现在左表A中的数据。\n\n```sql\nSELECT * FROM table_a A FULL OUTER JOIN table_b B ON A.name = B.name \n```\n上述sql的执行结果如下\n\nid      | name      | id        | name      |\n--------|-----------|-----------|-----------|\n1       | xyza      | null      |   null    |\n3       | xyzb      | null      |   null    |\n5       | xyzc      | 1         |   xyzc    |\n7       | xyzd      | 3         |   xyzd    |\nnull    | null      | 5         |   xyze    |\nnull    | null      | 7         |   xyzf    |\n\n注意mysql不支持FULL OUTER JOIN,这里的执行结果其实就是AUB\n\n```sql\nSELECT * FROM table_a A FULL OUTER JOIN table_b B ON A.name = B.name WHERE A.name IS NULL OR B.name IS NULL\n```\n上述sql的执行结果如下\n\nid      | name      | id        | name      |\n--------|-----------|-----------|-----------|\n1       | xyza      | null      |   null    |\n3       | xyzb      | null      |   null    |\nnull    | null      | 5         |   xyze    |\nnull    | null      | 7         |   xyzf    |\n\nA和B的交集不会出现上述结果中。\n\n```sql\nSELECT * FROM table_a A RIGHT JOIN table_b B ON A.name = B.name WHERE A.name IS NULL\n```\n![执行结果](http://bolinyoung.qiniudn.com/sql3.png)\n上述SQL的执行结果包含只出现在B中的记录\n\n```sql\nSELECT * FROM table_a A RIGHT JOIN table_b B ON A.name = B.name \n```\n![执行结果](http://bolinyoung.qiniudn.com/sql4.png)\n\n> 注意:\n> RIGHT OUTER JOIN 和 RIGHT JOIN 效果一样\n\n在执行上述SQL的时候，会以B表的数据为基准，A表匹配不到就输出null,输出结果中一定包含出现在B表中的记录。\n\n\n```sql\nSELECT * FROM table_a A INNER JOIN table_b B ON A.name = B.name \n```\n![执行结果](http://bolinyoung.qiniudn.com/sql5.png)\n上述执行结果类似计算A和B的交集。\n\n####四.各种JOIN的总结\n![各种JOIN的总结](http://bolinyoung.qiniudn.com/SQL-Join.jpg)\n","mtime":1401931445000,"source":"source/_posts/sql-join.md","_id":"e8ohmz84f73uufba"},"i8nd57r0hwuawh0a":{"content":"title: sql语句的大小\ndate: 2014-06-17 21:52:39\ntags: sql\ncategories: 数据库\n---\n\n今天写了下面的sql语句\n```sql\nselect XX,YY from tableXX where XX in ('aa','bb','cc')\n```\n\n<!--more-->\n\n这个sql不是在mysql或者oracle数据库上执行，而是在一个实时计算的数据产品上执行，当in的范围超过400后，发现执行失败，咨询相关同学后，原来这个实时计算的产品中对in的范围大小有限制，缺省的限制是400。\n\n我们平时都在使用mysql，那么mysql本身对in的范围大小是否有限制呢？mysql虽然没有对in的范围直接限制，但是限制了sql语句的长度，我们可以在不同的数据库中使用下面的命令来查看当前数据库server能接受的数据包大小\n```sql\nshow variables like 'max_allowed_packet%'\n```\nsql也是server端需要接收的数据，这个配置如果是Linux系统的化，可以查看my.cnf配置文件中配置的值。\n\nmysql不管你使用InnoDB还是MYISAM,sql的大小都有限制，和使用的数据库引擎没有关系，InnoDB支持事务，MYISAM不支持事务。","mtime":1403100681000,"source":"source/_posts/sql-size.md","_id":"i8nd57r0hwuawh0a"},"3zfd6ghhfoxgbn0q":{"content":"title: sqlmap被Spring容器加载了\ndate: 2014-07-01 20:10:20\ntags: [Spring,IBatis]\ncategories: 编程开发\n---\n\n####一.现象\n最近发布需求升级一个中间件，一个web应用在启动的时候，偶尔会会报下面的错误，报错的规律无法跟踪，导致应用启动失败。\n![ibatis-psring](http://bolinyoung.qiniudn.com/ibatis-spring.png)\n有时候启动应用就会出现上面的异常，有时候启动应用没有异常，在发布的时候要是机器启动失败，我们就不断重启，直到机器重启成功。\n\n<!-- more -->\n\n####二.分析\n首先，从上面的异常看到是由于当前机器上没法访问ibatis.apache.org这个域名导致，一台机器要是没法访问某个域名，要么这台机器本身有问题，要么域名对应的机器有问题，机器本身的问题可以排除，因为ping这个域名能ping的通，那么唯一的问题就是域名对应的机器拒绝访问导致，或许ibatis.apache.org这个服务不稳定。因此，上面的UnkonwHostException:ibatis.apache.org只能解释解释域名提供的服务不稳定了。\n\n其次，我们在所有的配置文件中找ibatis.apache.org这个域名，发现sqlmap的总控文件和每个sqlmap文件中有引用这个域名\n```xml\n<!DOCTYPE sqlMapConfig PUBLIC \"-//ibatis.apache.org//DTD SQL Map Config 2.0//EN\" \"http://ibatis.apache.org/dtd/sql-map-config-2.dtd\">\n```\n```xml\n<!DOCTYPE sqlMap PUBLIC \"-//ibatis.apache.org//DTD SQL Map 2.0//EN\" \"http://ibatis.apache.org/dtd/sql-map-2.dtd\">\n```\n奇怪，ibatis的配置文件怎么会被Spring解析呢？要解析也是有ibatis来解析。为什么说ibatis的配置文件被Spring解析了呢？看上图异常堆栈的开始，箭头所指\n\n\n>at org.apache.xerces.parsers.DOMParser.parse(Unknown Source)\n>at org.apache.xerces.jaxp.DocumentBuilderImpl.parse(Unknown Source)\n>at org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:75)\n>at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:396)\n... 63 more\n\n这行日志很明确地告诉我们Spring在偷偷解析的sqlmap配置文件了，注意核心关键词org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(),Spring这个时候处于bean定义的读取状态。\n\n至此，有两个问题没有解决\n\n1.Spring为什么会解析这份sqlmap的配置文件呢？\n2.Spring解析每份XML的配置文件时，都会从网上找DTD文件吗？\n\n先来回答问题1，Spring之所以会去偷偷解析这份配置文件，因为这份配置文件被Spring容器加载了，这份配置文件能被Spring容器加载，那是因为有人写错了，看了一下应用的总控配置文件，果然被写成这样子\n```\n<?xml version=\"1.0\" encoding=\"GBK\"?>\n<!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\">\n<beans>\n    <import resource=\"classpath*:xxxx/bean/**/*.xml\"/>\n</beans>\n```\n刚好那份sqlmap的总控配置文件也写在这xxx/bean/**/*能匹配到的目录下面，这样这份配置文件必然会被Spring容器所加载了。\n\n再看第2个问题，答案是显然不会从网上去找DTD文件，换做是你，你也不会这么写,Spring那么多DTD文件都是存在于Spring的jar包中，在XML解析的时候会把网络地址转换成classpath中某个DTD文件的路径。关键上面的域名ibatis.apache.org在Spring做XML解析的时候没法转换成自己jar包正某个DTD文件的路径，因此XML解析程序就会从网上去找这个DTD文件，这样ibatis.apache.org这个域名就会被访问了，这个过程可以看XML解析的源代码。\n\n其实只要看看EntityResolver这个接口的注释就明白了。\n\n####三.解决办法\n1.移动sqlmap的位置，保证不会被Spring容器所加载。\n2.把Spring总控配置文件中正则表达式修改一下，不要命中sqlmap即可。\n\n####四.总结\n1.最好避免sqlmap被Spring容器加载，首先这份配置文件有解析它的代码，但是不是Spring，其次Spring解析它，一个bean也解析不到，还有可能在网络不好的时候出现网络访问异常。\n2.关于上面问题的排查，其实不像写的这么顺利，一开始忽略了最重要的问题：Spring为什么会去解析ibatis的配置文件呢？导致自己一直在怀疑XML jar包是不是冲突导致，另外要是有个问题很难定位的时候，注意那些曾经被我们忽略的细节点，或许问题的根源就在哪里。","mtime":1404230131000,"source":"source/_posts/sqlmap-load-by-spring-container.md","_id":"3zfd6ghhfoxgbn0q"},"8r33it1dj87m9rox":{"content":"title: 谈谈几个svn命令\ndate: 2014-05-10 16:20:24\ntags: svn\ncategories: 开发工具\n---\n\n####一.概述\n很多公司目前都在使用svn来管理代码，当然要是你的开发环境不是Linux或许你不知到这几个命令你一样可以开发，但是要是你的开发环境是Linux，那你就需要了解这几个开发命令。关于代码的签出，提交我们就暂时不用考虑了，这些命令太简单。\n\n<!-- more -->\n\n####二.命令\n\n* svn pg svn:ignore 目录\n这个命令可以获取到目录下面那些文件不会被提交到svn服务器上\n\n* svn pe svn:ignore 目录\n这个命令可以设置目录下面的那些文件不会被提交到svn服务器上\n\n* svn pg svn:externals 目录\n这个命令专门用来解决分支A依赖分支B的场景，同时被依赖的分支会部署这里指定的目录下面\n\n* svn pe svn:externals 目录\n这个目录用来设置当前分支需要依赖的分支\n\n* svn revert file\n要是我们add了一个文件，但是还么有ci，此时如果我们不想ci这个文件了，我们就可以使用这个命令把这个文件的add取消掉。\n\n* svn revert --depth=infinity 文件夹\n功能同上，不过带上--depth参数就可以取消对整个文件夹的add\n\n* svn merge\n这个命令也经常会用到，我们在处理代码冲突的时候，经常需要把自己分支上的代码和主干合并\nsvn merge -rM:N svn-branch\nM必须小于N,M和N都是svn-branch的变更版本，通常我们都会写成下面这样\nsvn merge -rVERSION:HEAD svn-branch\n这里的VERSION我们可以选择svn-branch变更记录中的任何一个版本\n\n* svn cleanup\n这个命令从名称上来看是用作清理的，比如当使用svn st查看文件变更时，发现文件前面的标识为L标识当前文件被锁定了，要想解除这个锁定，就得使用svn cleanup这个命令。\n\n* svn propdel svn:externals .\n删除svn分支的externals属性\n\n* svn propedit -r N --revprop svn:log URL \n修改提交日志，N表示提交的版本\n\n* svn propset -r N --revprop svn:log \"new log message\" URL\n修改提交日志，N表示提交的版本","mtime":1446686313000,"source":"source/_posts/svn-command.md","_id":"8r33it1dj87m9rox"},"ip20qdpc7s424imf":{"content":"title: 使用svn merge命令来回滚代码\ndate: 2015-07-02 09:18:16\ntags: svn\ncategories: 开发工具\n---\n####一.问题\n我们经常使用svn来托管代码，svn ci就能把代码提交到svn服务器上，当我们误操作使用了svn ci后，此时想回滚怎么办？如果把本地代码回到执行svn ci之前的状态？\n\n<!-- more -->\n\n####二.解决方案\n* 1.svn up\n查看提交后的版本，假设为M\n* 2.svn log --stop-on-copy \n查看svn提交的日志，选择要回滚到那个版本，假设为N\n* 3.svn diff -r M:N\n查看从版本M到版本N发生了那些变化\n* 4.svn merge -rM:N svn-branch\n从版本M回滚到版本N svn-branch就是当前svn的分支URL\n* 5.修改好本地文件后再次提交\n","mtime":1435800774000,"source":"source/_posts/svn-merge-revert.md","_id":"ip20qdpc7s424imf"},"2xcdfu2j1mh6dpe1":{"content":"title: 拓宽技术视野一\ndate: 2015-10-23 23:55:18\ntags: JAVA\ncategories: 开发杂谈\n---\n利用空闲的时间，随便看看一些新的技术，拓宽自己的技术视野。\n\n* Betamax 利用这个开源二方库能够mock一个http请求。 \n*  cucumber 基于DSL来做单元测试，[具体例子](https://c0deattack.wordpress.com/2012/03/28/cucumber-jvm-with-cucumber-java-cucumber-junit-example/)\n* jOOR 一个简化发射调用的JAVA框架，把反射调用变成一行链式调用，这种框架貌似挺多的，[源码地址](https://c0deattack.wordpress.com/2012/03/28/cucumber-jvm-with-cucumber-java-cucumber-junit-example/)","mtime":1445617756000,"source":"source/_posts/tec-accumulation-1.md","_id":"2xcdfu2j1mh6dpe1"},"ptqalrz1x3e15fed":{"content":"title: JAVA线程本地存储之ThreadLocal的分析\ndate: 2014-10-07 21:01:03\ntags: JAVA \ncategories: 编程开发\n---\n\n#### 一.概述\nThreadLocal是JDK的一个线程本地存储的类，我们可以把一些线程私有的数据写在ThreadLocal中，这样这些数据只有一个线程可见，实现了所谓的栈封闭。这样存储一些线程私有的数据，我们就不用去费心考虑如何保证临界资源的互斥访问了，同时对于一个线程，这些私有数据也只做一次初始化。\n\n<!-- more -->\n\n#### 二.一段ThreadLocal的测试代码\n```java\nclass LocalObject {\n    private String name;\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nclass LocalStoreThread extends Thread {\n    /** 定义了一个线程本地存储的成员变量 **/\n    private ThreadLocal<LocalObject> threadLocal = new ThreadLocal<LocalObject>();\n\n    public LocalStoreThread(LocalObject lo) {\n        threadLocal.set(lo);\n    }\n\n    @Override\n    public void run() {\n        System.out.println(threadLocal.get().getName());\n    }\n}\n\n/**\n * <pre>\n * 创建一个线程实例，这个线程实例中有一个线程本地存储成员变量\n * </pre>\n */\npublic class ThreadLocalTest {\n    public static void main(String[] args) {\n        LocalObject lo = new LocalObject();\n        lo.setName(\"thread-local\");\n        new LocalStoreThread(lo).start();\n    }\n}\n```\n上述代码运行的时候在run方法中抛出了空指针异常，明明在构造函数中调用了threadLocal的set方法，为什么get的时候获取到了null,然后使用了null抛出了NPE呢？\n\n由于ThreadLocal是和线程相关的，我们上面的代码在够在函数中往线程本地存储变量中设置了一个实例对象，在run方法中获取这个实例对象的时候发现拿到是null,所以我们有必要看一下set时对应的线程和get时对应的线程是不是一样的。因此在set之前打印一下Thread.currentThread()，同时在get之前打印一下Thread.currentThread()\n\n```java\nclass LocalObject {\n    private String name;\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nclass LocalStoreThread extends Thread {\n    /** 定义了一个线程本地存储的成员变量 **/\n    private ThreadLocal<LocalObject> threadLocal = new ThreadLocal<LocalObject>();\n\n    public LocalStoreThread(LocalObject lo) {\n        // set之前打印当前线程\n        System.out.println(Thread.currentThread().getName());   // main\n        threadLocal.set(lo);\n    }\n\n    @Override\n    public void run() {\n        // get之前打印当前线程\n        System.out.println(Thread.currentThread().getName()); // Thread-0\n        System.out.println(threadLocal.get().getName());\n    }\n}\n\n/**\n * <pre>\n * 创建一个线程实例，这个线程实例中有一个线程本地存储成员变量\n * </pre>\n */\npublic class ThreadLocalTest {\n    public static void main(String[] args) {\n        LocalObject lo = new LocalObject();\n        lo.setName(\"thread-local\");\n        new LocalStoreThread(lo).start();\n    }\n}\n```\n好，问题出现了，set时的当前线程和get时的当前线程不一样，所以get的结果是null。set是写在线程的构造函数中的，此时当前线程是main线程，因为在main线程中创建线程。但是在run方法中当前线程已经不是main线程了变成了new出来的这个新线程了。\n\n####三.ThreadLocal中get和set方法分析\n```java\npublic T get() {\n        // 获取当前线程实例\n        Thread t = Thread.currentThread();\n        /* 获取当前线程实例的ThreadLocalMap，其实就是一个数组\n         * 这个数组可以扩容，每次空间不够时都拿当前大小*2\n         */\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            /*根据this哈希获取数组中的一个元素*/\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        // 如果当前线程的ThreadLocalMap为null,就创建一个\n        return setInitialValue();\n}\nprivate T setInitialValue() {\n        /* 这里调用了ThreadLocal的initValue方法，一般都会在创建ThreadLocal\n         * 实例的时候重写这个方法，比如说ThreadLocal中要是存放数据库链接对象的\n         * 话，就需要一个初始化方法来初始化这个数据库链接对象\n         */\n        T value = initialValue();\n        /*把初始化好的值保存起来*/\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n}\n/*创建线程的ThreadLocalMap*/\nvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n/*获取线程的ThreadLocalMap*/\nThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n}\n```\n上述代码就是ThreadLocal的get源代码，先根据当前线程获取当前线程的ThreadLocalMap,此时获取到的就是一个table数组，接下来根据ThreadLocal实例的threadLocalHashCode来获取table数组中的一个元素，这个元素是个K-V的键值对，此时V就是本地存储的值。\n\n```java\n/*关于set代码和get代码是对称的*/\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n}\n```\n\n####四.ThreadLocal源代码中提供的一个实例代码\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class UniqueThreadIdGenerator {\n    private static final AtomicInteger uniqueId = new AtomicInteger(0);  \n\n    private static final ThreadLocal < Integer > uniqueNum =   \n            new ThreadLocal < Integer > () {  \n        //定义初始值（副本）  \n        @Override protected Integer initialValue() {  \n            return uniqueId.getAndIncrement();  \n        }  \n    };  \n\n    public static int getCurrentThreadId() {  \n        // 这里应该要把 uniqueId换成uniqueNum，源码应该是写错了   \n        return uniqueNum.get();  \n    }\n\n    static class MyThread extends Thread {\n\n        @Override\n        public void run() {\n            System.out.println(UniqueThreadIdGenerator.getCurrentThreadId());\n        }\n    }\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; ++i) {\n            new MyThread().start();\n        }\n    }\n}\n```\n这里总共创建了5个线程，每个线程在run方法中调用UniqueThreadIdGenerator.getCurrentThreadId()时，发现每个线程的ThreadLocalMap都是null,所以每次初始化的方法initialValue都会被调用。\n\n####五.Thread&&ThreadLocal&&ThreadLocalMap之间的关系\n![图示](http://dl.iteye.com/upload/attachment/0084/5636/079ae373-cc30-3a5e-8890-496018582ca0.bmp)\n\n####六.总结\n一个线程只有一个ThreadLocalMap,其实ThreadLocalMap就是一个table数组，数组中的每个元素都是一个K-V的键值对，其中K就是ThreadLocal实例，在获取本地存储的值的时候根据ThreadLocal实例的threadLocalHashCode来对table进行Hash查找，找到对应的K-V键值对。一个线程可以有多个ThreadLocal实例，那么有多少个ThreadLocal实例就决定了table数组的大小，这个数组是动态增长的，每次要是大小不够，就自动扩充为原来大小的2倍，然后对于原来的元素重新Hash,这个操作的成本还是很大的。\n\n","mtime":1412687233000,"source":"source/_posts/thread-local-analyze.md","_id":"ptqalrz1x3e15fed"},"msojd0syyrc39741":{"content":"title: 使用事务的一个注意点\ndate: 2014-10-31 17:12:19\ntags: Experience\ncategories: 编程开发\n---\n最近在代码中配置了一个事务，事务的意思就是当前这件事情要么全部正常做完，要么全部不做。为了避免数据库中出现脏数据，我给XXX类的ff方法配置了事务。在ff方法主要做下面这几件事情\n\n<!-- more -->\n\n* 1.从数据库中读出一批数据dataList1，此时dataList1已经存在于内存中了。\n* 2.修改这一批数据，此时的修改不会写到数据库，因为事务暂时还没有提交。\n* 3.根据dataList1中的数据进行判断，然后再写数据库。\n\n这么处理有问题，因为dataList1在2结束后，会发生变化，但是内存中的dataList1感知不到，也就是说3处用的dataList1还是老数据，不是2修改后的数据，因此3处的判断条件会出现问题，因为3处用到的dataList1不是事务中最新的数据。\n\n修复后的步骤如下：\n\n* 1.从数据库中读出一批数据dataList1，此时dataList1已经存在于内存中了。\n* 2.修改这一批数据，此时的修改不会写到数据库，因为事务暂时还没有提交。\n* 3.从数据库中再读取一次dataList1。\n* 4.根据dataList1中的数据进行判断，然后再写数据库。\n\n注意：\n事务中对数据库进行读写操作，此时写入的数据不会写到数据库中，但是能从事务中读取到最新的数据，如果要基于某些数据做判断，最好保证判断时这些数据在事务中是最新的，不要沿用一开始就加载到内存中的那批数据，因为一开始的数据不是最新的。\n\n在事务中切忌发消息给其他系统，因为这个逻辑不对，事务可能会回滚，因为数据出错啥的，但是发出去的消息没法回滚，因此一旦在事务中发消息就会破坏事务的一致性。自己在事务中发了一个消息给外部系统，事务还没有提交，外部系统收到消息后找我来查询刚才事务中产生的数据，查询DB当然就查询不到了，因为事务还没有提交，消息就已经出去了，以后在事务中切忌发消息给外部系统。\n","mtime":1420208279000,"source":"source/_posts/transaction-attention.md","_id":"msojd0syyrc39741"},"27238nd8bsvbyeqr":{"content":"title: 两种分布式系统中保持数据一致性的设计方案\ndate: 2017-06-25 17:40:13\ntags: CAP\ncategories: 分布式\n---\nCAP是分布式系统中非常重要的理论依据，任何分布式系统设计的时候都要考虑一下CAP。\n```\nC(一致性)：所有节点上的数据时刻保持同步\nA(可用性)：每个请求都能得到一个响应，不论成功还是失败\nP(分区容错)：系统能够持续提供服务，即使系统内部有消息丢失\n```\nCAP只能满足两条，现在大多数业务系统都是AP without C。\n在平时的业务开发中，业务系统A更新完自己的数据后，还需要业务系统B更新相关的数据，要么系统A发消息给系统B，系统B受到消息后更新自己的数据，要么系统A通过RPC接口更改系统B的数据。那么如何保证系统A,B的数据一致性呢？如果要强一致的话，就需要分布式事务，但是分布式事务本身有一定的开发成本，同时也会影响系统的稳定性。\n不使用分布式事务如何来保证一致性呢？只能放弃强一致性，变成最终一致性。一般会有两种方案，一种是通过消息中间件来实现，一种是利用数据库事务加上异步轮询来处理。\n\n【通过消息中间件来实现】\n![消息中间件](http://7fvbqj.com1.z0.glb.clouddn.com/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%80%E8%87%B4%E6%80%A7.png)\n这种方案需要相应的消息中间件来支持。\n【利用数据库事务+异步轮询】\n![事务轮询](http://7fvbqj.com1.z0.glb.clouddn.com/%E4%BA%8B%E5%8A%A1+%E8%BD%AE%E8%AF%A2.png)\n业务系统A更新完自己的数据后，创建一个事件，创建事件和更新自己业务数据放在一个事务里面，这样业务系统A数据更新和事件创建会一起完成，剩下的就是保证业务事件A一定要处理，要么通过RPC调用业务系统B的接口，要么发消息给业务系统B。\n\n\n","mtime":1498399874000,"source":"source/_posts/two-consistency-design-tech.md","_id":"27238nd8bsvbyeqr"},"dsy26qdkt6mtsptn":{"content":"title: 单元测试Failed的排查\ndate: 2014-07-26 15:47:22\ntags: 单元测试\ncategories: 开发杂谈\n---\n\n最近各种中间件升级的事情，升级中间件可能会出现很多诡异的问题，此时我们需要定位这些问题是自己升级导致还是其他原因导致，升级中间件可能会出现很多JAR包冲突的问题，此时需要一一排查。\n\n<!-- more -->\n\n前两天升级后遇到这样的问题，系统中的单元测试在eclipse中单独跑没有问题，但是使用mvn test一起跑就会出现大部分单元测试PASS不了，此时查看单元测试FAIL的日志发现获取数据库连接超时，由于本次升级出现了很多JAR包冲突的问题，导致自己一直在怀疑是不是某个JAR包又冲突了导致数据库连接获取超时了？因此排查思路一直停留在JAR包冲突的这个范围内，查了好久，问题依然没有解决，由于自己维护的这个服务化应用非常重要，不能不管单元测试就发布，同时自己也不会放过这个问题，一定要追查到底。\n\n是不是自己的陷入了排查误区了呢？于是把整个代码的变更自己又回顾了一遍，发现最多的就是JAR包版本的升级，引入新的JAR包版本。记得之前自己总结过一句话：要是一个问题排查了好久没有眉目的话，记得去看看那些被你忽略过的细节问题，很可能问题就出现这些被忽略的细节上面。\n\n那到底那些细节被忽略了呢？问题的现象是什么？单个跑UT能够PASS,批量跑UT一部分不能PASS,因为数据库连接获取超时，单个和批量就是这里的细节了，此时自己有一种突然醒悟的感觉，问题就这里了，单个跑只获取一个数据库连接，批量跑会获取多个数据库连接，数据库连接池的问题，不是我升级导致，因此找DBA搞定这个问题。\n\n其实这个问题很简单，发现自己有时候很容易被最近刚出现的问题困扰住，思路一直停留如何最近刚出现的问题上，以后需要注意分析问题出现的本质原因，比如数据连接获取不到其实跟JAR包冲突的关系不是很大，可以说几乎没啥关系，不要受一些最近出现的问题的影响，避免思路被困住。","mtime":1406362404000,"source":"source/_posts/ut-failed-problems.md","_id":"dsy26qdkt6mtsptn"},"4d367jcz14d6py0q":{"content":"title: 一次velocity异常的分析\ndate: 2014-08-22 22:05:14\ntags: velocity\ncategories: 编程开发\n---\n\n####一.现象\n最近在使用velocity模板的时候RuntimeInstance的1103行代码出现了NPE,如下图所示\n![velocity-npe](http://bolinyoung.qiniudn.com/velocity-npe.png)\n该行代码一直在抛NPE。\n\n<!-- more -->\n\n####二.分析\nRuntimeInstance的1103行出现NPE原因只有一个，那就是parserPool是NULL，现在我们只要搞清楚parserPool为啥在这里是NULL，我们就知道这个NPE出现的原因了，看上面的图，我们发现在执行1103行代码的时候调用了requireInitialization()，那么此时需要看看requireInitialization()到底做了那些事情。\n![requireInitialization](http://bolinyoung.qiniudn.com/requireInitialization.png)\n我们看到了requireInitialization中调用了init方法，但是这个方法可能抛出异常。关于requireInitialization方法中的代码很有疑问，首先想到的是并发问题，这里怎么没考虑到多个线程并发初始化的问题呢？其次，initialized标识当前实例是否已经被初始化了，能进入到if分支中，说明当前实例肯定没有被初始化，因此initialized值一定是false，initializing标识当前实例正在被初始化,能进入到if分支中，说明当前实例没有被正在初始化，因此initializing的值一定是false。接下来我们看看init的代码\n![init](http://bolinyoung.qiniudn.com/init.png)\n一开始怀疑并发的问题，看了init的代码后，这个点就不用再去怀疑了。init中也有一个if分支，进入if分支的逻辑和requireInitialization进入if分支的逻辑是一样的，这里就不再进行分析了，关键看2处的代码，此时会标记当前实例正在被初始化，加入initializeParserPool()方法中抛出了一个Exception，此时下面的代码就不会被执行，当前方法栈帧直接退出，当前线程获取的锁也会被释放(后面给出验证的例子)，此时initializing值没有机会设置成false了，也就是说3处的代码没法机会执行了，直接回到requireInitialization方法中，该方法中捕获了这个异常，此时问题就出现了，等下次再初始化的时候requireInitialization中的init方法永远就不会被调用了，此时1103行代码就一直NPE了，由于错过了第一次init时的真正异常，后面看到就一直是NPE，不知道NPE的具体原因是啥了，也就是说requireInitialization中catch住的异常后续发现不了。\n\n####三.解决思路\n通过上面的分析，我们只要找到requireInitialization中catch住的异常是啥，问题也就差不多解决了，因为第一次初始化的时候异常已经发生了，后续的初始化都不会进入到requireInitialization中的if分支了，此时要么重启系统去看第一初始化时异常是什么，要么找日志，debug神器中可以动态修改变量的值，那么在requireInitialization的if分支处设置断点，然后动态修改initializing的值为false,此时异常出现了\n\n```\nFailed to initialize an instance of org.apache.velocity.runtime.log.Log4JLogChute with the current runtime configuration.\n```\n 异常信息表明可能log有问题，因为出现Log4J关键词了，这个异常很陌生，不知如何解决，直接去谷歌一下就能解决问题，一般参考stackoverflow上的答案，有人说在velocity引擎初始化的时候增加下面代码即可\n\n```java\nProperties p = new Properties();\np.setProperty(\"runtime.log.logsystem.class\", \"org.apache.velocity.runtime.log.NullLogSystem\");\ntry {\n      INSTANCE.init(p);\n} catch (Exception e) {\n      LOG.error(e);\n}\n```\n索性试一下，发现问题解决啦。\n\n####四.总结\n1.个人认为RuntimeInstance的requireInitialization方法有BUG，应该增加finally分支，在该分支中把initializing设置为false，后续可以考虑修复一下velocity的这个BUG，在开源项目中贡献一些代码。\n2.遇见陌生异常时记得谷歌，记得stackoverflow。\n3.在分析的过程中，自己突然想到一个问题，synchronized修饰的方法内部抛出Exception后当前线程获取到锁会不会释放，答案是会释放，深层次的分析估计要看JVM源码了，这里给出验证的例子\n```java\npublic class SynchronizedTest {\n\n    public synchronized void init() throws Exception {\n        if (true) {\n            throw new Exception(\"test exception\");\n        }\n    }\n    \n    public static void main(String[] args) {\n        SynchronizedTest oo = new SynchronizedTest();\n        \n        new ThreadModel1(oo).start();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        new ThreadModel2(oo).start();\n    }\n}\n\nclass ThreadModel1 extends Thread {\n\n    private SynchronizedTest synchronizedTest;\n    public ThreadModel1(SynchronizedTest synchronizedTest) {\n        this.synchronizedTest = synchronizedTest;\n    }\n    \n    @Override\n    public void run() {\n        try {\n            synchronizedTest.init();\n        } catch (Exception e) {\n            System.out.println(\"ThreadModel1 Exception...\");\n            while(true) {}\n        }\n    }\n}\n\nclass ThreadModel2 extends Thread {\n\n    private SynchronizedTest synchronizedTest;\n    public ThreadModel2(SynchronizedTest synchronizedTest) {\n        this.synchronizedTest = synchronizedTest;\n    }\n    \n    @Override\n    public void run() {\n        try {\n            synchronizedTest.init();\n        } catch (Exception e) {\n            System.out.println(\"ThreadModel2 Exception...\");\n        }\n    }\n}\n```\n\n输出结果:\nThreadModel1 Exception...\nThreadModel2 Exception...\n\nThreadModel2线程能继续运行并且输出结果，说明init上的锁已经被ThreadModel1线程所释放。","mtime":1408725667000,"source":"source/_posts/velocity-exception-analyze.md","_id":"4d367jcz14d6py0q"},"vz6trqqz9mleuqx1":{"content":"title: velocity工具函数以及InputStream到String的转换方法\ndate: 2015-10-15 20:41:33\ntags: JAVA\ncategories: 编程开发\n---\n####一.背景\n最近在做需求的时候，需要在程序中把一个vm文件渲染成一个字符串，同时也需要把一个InputStream流转换成一个字符串，虽然说很简单，但是自己还是翻了翻以前的代码，也在网上找了相关的例子，为了下次使用的是能能够快速找到，专门记录一下。\n<!-- more -->\n####二.实现\n#####velocity渲染的工具类\n```java\nprivate static final Logger LOG = LoggerFactory.getLogger(VelocityUtil.class);\n\npublic static String render(String content, Map<String, String> param) {\n    VelocityEngine ve = new VelocityEngine();\n    VelocityContext context = new VelocityContext(param);\n    try {\n    \t//解决velocity LOG的问题       \n    \tve.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, new NullLogChute());\n        ve.init();\n        StringWriter writer = new StringWriter();\n        ve.evaluate(context, writer, content, content);\n        return writer.toString();\n    } catch (Exception e) {\n        LOG.error(\"velocity render exception...\", e);\n    }\n\n    return null;\n}\n```\n####InputStream到String转换的工具类\n```java\n/**\n * 把流转换成字符串的工具函数\n * \n * @param in\n * @return\n * @throws Exception\n */\npublic static String inputStreamToString(InputStream in) throws Exception {\n    StringBuilder sb = new StringBuilder();\n    String line = null;\n    BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n    try {\n        while ((line = reader.readLine()) != null) {\n            sb.append(line.trim());\n        }\n    } catch (IOException e) {\n        throw e;\n    } finally {\n        try {\n            in.close();\n        } catch (IOException e) {\n            throw e;\n        }\n    }\n    return sb.toString();\n}\n```\n也可以直接使用org.apache.commons.io.IOUtils这个工具函数，注意commons-io包中工具函数的使用。\n","mtime":1445223790000,"source":"source/_posts/velocity-utils-stream-to-string.md","_id":"vz6trqqz9mleuqx1"},"l60o18kgbd8r75t5":{"content":"title: vim 命令\ndate: 2014-06-01 00:39:35\ntags: vim\ncategories: 开发工具\n---\n\nvim的一些命令总结\n\n<!-- more -->\n\n* shift + g\n回到最后一行\n\n* gg\n回到第一行\n\n* dd\n删除某一行\n\n* u\n回复修改\n\n* w\n写入不退出\n\n* wq\n写入并退出\n\n* :%s/^/your_word/\n所有行行首增加内容\n\n* :%s/$/your_word/\n所有行行末尾增加内容","mtime":1451913251000,"source":"source/_posts/vi-command.md","_id":"l60o18kgbd8r75t5"},"8mvyayyue4vca5y8":{"content":"title: 为什么zookeeper集群个需要奇数台机器\ndate: 2014-05-17 15:39:29\ntags: zookeeper\ncategories: 分布式\n---\n\n我们通常使用zookeeper集群来协同管理另外一个集群，比如HBase集群，一个HBase集群必然对应一个zookeeper集群。在部署zookeeper集群的时候，我们为什么选择奇数台机器呢？\n\n<!-- more -->\n\n关于zookeeper集群有下面几点说明\n\n* 1.集群中机器数目越多越稳定\n* 2.集群通过选举的方式来选出集群的leader，要是有一半以上的机器同一某个机器成为leader,那么这个机器就编程集群中的leader\n* 3.要是集群中有一半以上的机器挂掉，整个集群就会挂掉\n\n对于2N和2N+1台机器，选出leader的时候都需要有N+1票，就是说N+1台机器投票给某一台机器，因此2N和2N+1台机器构成的集群在投票过程中所投票数一样，但是2N+1台机器构成的集群稳定。同样2N台机器中挂掉N台的概率是50%，但是2N+1台机器中挂掉N太的概率小于50%，也就是说2N+1台机器构成的集群比较稳定。\n\n综上所述：\nzookeeper集群选择2N+1台机器是比较合理的。\n","mtime":1400313134000,"source":"source/_posts/why-odd-number-machine-for-zookeeper.md","_id":"8mvyayyue4vca5y8"},"s0jn8ugzg1k2axq1":{"content":"title: 关于我自己\ndate: 2014-10-26 20:33:25\n---\n\n* 2005-2008 甘肃省平凉市静宁一中高三16班\n* 2008-2012 南京航空航天大学计算机科学与技术301班\n* 2012-至今 阿里巴巴网络技术有限公司\n\n简单，快乐，自信，因上努力，果上随缘，不忘初心。\n","mtime":1414328687000,"source":"source/about/index.md","_id":"s0jn8ugzg1k2axq1"},"edopqpwu93gqm8lg":{"content":"title: 使用xstream解析utf-8格式的字符串\ndate: 2015-11-18 14:26:04\ntags: JAVA\ncategories: 编程开发\n---\n最近在使用xstream解析一个xml字符串时，出现了解析失败的问题，出错原因很简单，xml字符串中指定了utf-8的编码，此时我们直接构造一个\n```java\nXStream xstream = new XStream();\n```\n这样构造的话，一定会解析失败。\n需要按照下面的方式来构造才能正确解析utf-8格式的xml字符串\n```java\nXStream xstream = new XStream(new DomDriver(\"UTF-8\"));\n```\nxstream是一个比较方便的工具，能够实现xml和object之间的相互转换，注意在平时开发过程中的灵活使用。\n","mtime":1447831732000,"source":"source/_posts/xstream-skills-for-utf8.md","_id":"edopqpwu93gqm8lg"},"no6bhhbaci7ogsz0":{"content":"title: 我的读书单\ndate: 2014-10-26 20:34:06\n---\n\n####一.已经读完\n技术书籍\n* 【Thinking in Java】\n* 【C++ Primer】\n* 【Effective Java】\n* 【深入理解java虚拟机】\n* 【编译原理及实践】 \n* 【HBase权威指南】\n* 【Java并发编程实战】\n\n其他\n* 【少有人走的路】\n* 【人性的弱点】 \n\n####二.正在阅读\n技术书籍\n* 【大型网站系统与Java中间件实践】\n* 【深入分析Java Web技术内幕】\n* 【两周自制脚本语言】\n* 【领域驱动设计】\n* 【Java性能优化权威指南】\n* 【Java并发编程艺术】\n\n非技术书籍 \n\n####三.想读的书\n* 【活着就为改变世界】\n* 【Java虚拟机规范】\n","mtime":1438496443000,"source":"source/reading/index.md","_id":"no6bhhbaci7ogsz0"}}}