<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BolinYoung's Blog]]></title>
  <subtitle><![CDATA[Believe in yourself]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yangbolin.cn/"/>
  <updated>2015-10-09T12:41:58.111Z</updated>
  <id>http://yangbolin.cn/</id>
  
  <author>
    <name><![CDATA[BolinYoung]]></name>
    <email><![CDATA[boris.yangbl@alibaba-inc.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[awk使用总结]]></title>
    <link href="http://yangbolin.cn/2015/09/09/awk-command/"/>
    <id>http://yangbolin.cn/2015/09/09/awk-command/</id>
    <published>2015-09-09T13:12:36.000Z</published>
    <updated>2015-09-10T02:01:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在平时工作中经常会遇到一些文本的处理，awk就是一种文本处理语言，很方便，很轻量，可以说awk也是一种编程语言。</p>
<p>awk的工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，\$0则表示所有域，\$1表示第一个域，\$n表示第n个域。默认域的分隔符是”空白键”或”tab键”。<br><a id="more"></a></p>
<h4 id="二-常用命令">二.常用命令</h4>
<h5 id="1-显示指定分隔符分隔后的第一列">1.显示指定分隔符分隔后的第一列</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">awk</span> -F <span class="string">':'</span> <span class="string">'{print <span class="variable">$1</span>}'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>-F ‘:’ 指定了awk处理行文本的分隔符号<br>{print $1}表示是action，对于文本中的没一行都要执行这个action<br>这个文本处理模式是awk+action</p>
<h5 id="2-搜索文件中包含某一关键字的行">2.搜索文件中包含某一关键字的行</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk -<span class="literal">F</span>: <span class="string">'/root/'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>这里使用的pattern，匹配了pattern的行才会执行后面的action，没有指定action默认输出正行内容。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk -<span class="literal">F</span>: <span class="string">'/^root/'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>匹配所有以root开头的行</p>
<h5 id="3-awk内置变量">3.awk内置变量</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">awk</span> -F <span class="string">':'</span> <span class="string">'{printf("filename:%s,linenumber:%s,linecontents:%s columns:%s\n",FILENAME,NR,NF,<span class="variable">$0</span>)}'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>FILENAME awk浏览的文件名<br>NR 已读出的记录数目<br>NF 浏览记录的域的个数<br>printf用于格式化输出</p>
<h5 id="4-变量和赋值">4.变量和赋值</h5>
<p>统计一个文件中的行数</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk '{count++;print $0} <span class="operator"><span class="keyword">END</span>{print <span class="string">"user count is "</span>, <span class="aggregate">count</span>}<span class="string">' /etc/passwd</span></span>
</pre></td></tr></table></figure>

<p>注意这里的count虽然没有被初始化，但是它的值是0，但是稳妥的做法还是初始化一下</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="aggregate">count</span>=<span class="number">0</span>;</span>print "[<span class="operator"><span class="keyword">start</span>]<span class="keyword">user</span> <span class="aggregate">count</span> <span class="keyword">is</span> <span class="string">", count}' {count=count+1;print $0} END {print "</span>[<span class="keyword">end</span>] <span class="keyword">user</span> <span class="aggregate">count</span> <span class="keyword">is</span> <span class="string">", count}' /etc/passwd</span></span>
</pre></td></tr></table></figure>

<p>BEGIN后面的action只有在开始的时候才会执行，END后面的语句只有结束的时候才会执行</p>
<p>统计某个文件夹下的文件占用的字节数</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ls -l | awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="keyword">size</span>=<span class="number">0</span>} {<span class="keyword">size</span>=<span class="keyword">size</span>+$<span class="number">5</span>} <span class="keyword">END</span>{print <span class="string">"[end]size is "</span>,<span class="keyword">size</span>}<span class="string">'</span></span>
</pre></td></tr></table></figure>

<p>如果以M为单位显示：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ls -l | awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="keyword">size</span>=<span class="number">0</span>} {<span class="keyword">size</span>=<span class="keyword">size</span>+$<span class="number">5</span>} <span class="keyword">END</span>{print <span class="string">"[end] size is "</span>, <span class="keyword">size</span>/<span class="number">1024</span>/<span class="number">1024</span>, <span class="string">"M"</span>}<span class="string">'</span></span>
</pre></td></tr></table></figure>

<p>这个统计命令在排查线上日志超出限制时很有用。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在平时工作中经常会遇到一些文本的处理，awk就是一种文本处理语言，很方便，很轻量，可以说awk也是一种编程语言。</p>
<p>awk的工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，\$0则表示所有域，\$1表示第一个域，\$n表示第n个域。默认域的分隔符是”空白键”或”tab键”。<br>]]></summary>
    
      <category term="awk" scheme="http://yangbolin.cn/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程艺术读书笔记一]]></title>
    <link href="http://yangbolin.cn/2015/08/02/java-concurrent-note-1/"/>
    <id>http://yangbolin.cn/2015/08/02/java-concurrent-note-1/</id>
    <published>2015-08-02T05:44:15.000Z</published>
    <updated>2015-08-09T03:47:16.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>volatile<br>轻量级的同步机制，有volatile修饰的变量在进行写操作的时候会多出一条lock前缀的指令，比如lock addl $0 x 0,(%esp)。lock前缀的指令在多核处理器下面会引发下面两件事情：①将当前处理器缓存行的数据写回到系统内存。②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。③volatile写代表锁的释放，volatile读代表锁的获取。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>synchronized<br>对于普通方法，锁是当前实例对象。对于静态方法，锁是当前类的Class对象。对于同步方法块，所示synchronized括号里面配置的对象，代码块的同步是基于monitorenter和monitorexit来实现的。</p>
</li>
<li><p>Java对象头<br>synchronized用的锁是存在JAVA对象头里面的。JAVA对象头里的Mark Word默认存储了对象的HashCode，分代年龄和锁标记。</p>
</li>
<li><p>偏向锁<br>偏向锁使用了一种等到竞争出现才释放锁的机制。它首先会暂停拥有偏向缩的线程，然后检查持有偏向缩的线程是否活着，如果线程处于不活动状态，则将对象头设置为无锁状态；如果线程仍然活着，持有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。可以通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false。</p>
</li>
<li><p>轻量级锁<br>使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁。</p>
</li>
<li><p>重量级锁<br>自旋获取锁失败，轻量级线程就会转换成重量级线程。</p>
</li>
<li><p>总线锁<br>所谓总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器请求将被阻塞住，那么该处理器可以独占共享内存。</p>
</li>
<li><p>ABA问题<br>如果一个变量的值从A变到B又变到A，此时可以通过版本来感知到这一变化，注意版本思想在实际开发工作中的灵活使用。</p>
</li>
<li><p>CAS<br>在修改一个变量值的时候先判断一下变量当前的值是否和我们期望的值一样，入股一样就修改，不一样就不修改。</p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<ul>
<li>volatile<br>轻量级的同步机制，有volatile修饰的变量在进行写操作的时候会多出一条lock前缀的指令，比如lock addl $0 x 0,(%esp)。lock前缀的指令在多核处理器下面会引发下面两件事情：①将当前处理器缓存行的数据写回到系统内存。②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。③volatile写代表锁的释放，volatile读代表锁的获取。</li>
</ul>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="并发编程" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用svn merge命令来回滚代码]]></title>
    <link href="http://yangbolin.cn/2015/07/02/svn-merge-revert/"/>
    <id>http://yangbolin.cn/2015/07/02/svn-merge-revert/</id>
    <published>2015-07-02T01:18:16.000Z</published>
    <updated>2015-07-02T01:32:54.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-问题">一.问题</h4>
<p>我们经常使用svn来托管代码，svn ci就能把代码提交到svn服务器上，当我们误操作使用了svn ci后，此时想回滚怎么办？如果把本地代码回到执行svn ci之前的状态？</p>
<a id="more"></a>

<h4 id="二-解决方案">二.解决方案</h4>
<ul>
<li>1.svn up<br>查看提交后的版本，假设为M</li>
<li>2.svn log —stop-on-copy<br>查看svn提交的日志，选择要回滚到那个版本，假设为N</li>
<li>3.svn diff -r M:N<br>查看从版本M到版本N发生了那些变化</li>
<li>4.svn merge -rM:N svn-branch<br>从版本M回滚到版本N svn-branch就是当前svn的分支URL</li>
<li>5.修改好本地文件后再次提交</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-问题">一.问题</h4>
<p>我们经常使用svn来托管代码，svn ci就能把代码提交到svn服务器上，当我们误操作使用了svn ci后，此时想回滚怎么办？如果把本地代码回到执行svn ci之前的状态？</p>
]]></summary>
    
      <category term="svn" scheme="http://yangbolin.cn/tags/svn/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA反射调用总结]]></title>
    <link href="http://yangbolin.cn/2015/06/08/java-reflect/"/>
    <id>http://yangbolin.cn/2015/06/08/java-reflect/</id>
    <published>2015-06-08T14:48:54.000Z</published>
    <updated>2015-06-08T15:15:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>这几天一直在忙于一个框架的开发，我们的初衷是基于配置产出业务数据，不要让开发工程师去编写JAVA代码来产出账单，一开始觉得这件事情很难，很难做到不开发JAVA代码，事实确实如此，不过数据如果规整的话，基于配置完全可以，一行java代码都不用写。当然这个框架目前还在测试中，核心功能已经开发结束了，开发一个框架和开发一个业务功能要考虑的事情完全不一样，在开发框架之前，需要把所有可能出现的需求都要考虑一下，其实框架就是高度的抽象，我们把平时所做的一些功能逻辑梳理清楚，再上一个高度就能梳理出一个框架。在开发这个框架的过程中用到了反射，感觉JDK的反射写起来代码有点多，于是考虑用Spring框架提供反射工具类，还有木有其他处理反射调用框架或者工具呢？</p>
<a id="more"></a>

<h4 id="二-概述">二.概述</h4>
<h5 id="1-利用JDK本身的API来实现反射">1.利用JDK本身的API来实现反射</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>Object oo = <span class="keyword">new</span> InnerObject();
Method[] methods = oo.getClass().getDeclaredMethods();
<span class="keyword">for</span> (Method method : methods) {
    <span class="keyword">if</span> (method.getName().equals(<span class="string">"test"</span>)) {
        <span class="keyword">try</span> {
            Object retValue = method.invoke(oo, <span class="keyword">null</span>);
        } <span class="keyword">catch</span> (IllegalArgumentException e) {
            e.printStackTrace();
        } <span class="keyword">catch</span> (IllegalAccessException e) {
            e.printStackTrace();
        } <span class="keyword">catch</span> (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
}
</pre></td></tr></table></figure>

<p>一个反射调用要写这么多代码，我也是醉了。。。。</p>
<h5 id="2-利用Spring的工具类来实现反射">2.利用Spring的工具类来实现反射</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>Method method = ReflectionUtils.findMethod(oo.getClass(), <span class="string">"test"</span>, <span class="keyword">null</span>);
<span class="keyword">try</span> {
    Object retValue = method.invoke(oo, <span class="keyword">null</span>);
} <span class="keyword">catch</span> (IllegalArgumentException e) {
    e.printStackTrace();
} <span class="keyword">catch</span> (IllegalAccessException e) {
    e.printStackTrace();
} <span class="keyword">catch</span> (InvocationTargetException e) {
    e.printStackTrace();
}
</pre></td></tr></table></figure>

<p>虽然木有了for循环，但是代码还是有些多，不够精简。</p>
<h5 id="3-利用Mirror来做反射">3.利用Mirror来做反射</h5>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
 	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>net.vidageek<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
 	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>mirror<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
 	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Object oo = <span class="keyword">new</span> InnerObject();
Object retValue = <span class="keyword">new</span> Mirror().on(oo).invoke().method(<span class="string">"test1"</span>).withoutArgs();
</pre></td></tr></table></figure>

<p>看看mirror是不是精简了很多呢？还是函数编程思想，这种写法在JDK8中会非常普遍。这里只是举例说明了一下方法调用，其他更多反射调用参考 <a href="http://projetos.vidageek.net/mirror/mirror/" target="_blank">mirror</a></p>
<h4 id="三-总结">三.总结</h4>
<p>对于一个点，多思考，寻求最简单的写法，你会有更多的收获。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>这几天一直在忙于一个框架的开发，我们的初衷是基于配置产出业务数据，不要让开发工程师去编写JAVA代码来产出账单，一开始觉得这件事情很难，很难做到不开发JAVA代码，事实确实如此，不过数据如果规整的话，基于配置完全可以，一行java代码都不用写。当然这个框架目前还在测试中，核心功能已经开发结束了，开发一个框架和开发一个业务功能要考虑的事情完全不一样，在开发框架之前，需要把所有可能出现的需求都要考虑一下，其实框架就是高度的抽象，我们把平时所做的一些功能逻辑梳理清楚，再上一个高度就能梳理出一个框架。在开发这个框架的过程中用到了反射，感觉JDK的反射写起来代码有点多，于是考虑用Spring框架提供反射工具类，还有木有其他处理反射调用框架或者工具呢？</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[操作系统定时调度]]></title>
    <link href="http://yangbolin.cn/2015/05/18/os-timer-call/"/>
    <id>http://yangbolin.cn/2015/05/18/os-timer-call/</id>
    <published>2015-05-18T12:13:29.000Z</published>
    <updated>2015-05-19T00:58:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近需要开发一些定时任务，提到定时任务，我们都会想到quartz，为了让我们的定时任务能够更加灵活的被控制，我们通过shell脚本去执行一个java类，然后定时去执行这个shell脚本即可。如何去定时执行这个shell脚本，我们想到Linux本身提供后台进程去定时执行一些命令，那就是crontab，因此我们编写好自己的shell脚本再写好crontab后就能定时执行我们的任务了。</p>
<a id="more"></a>

<h4 id="二-如何配置">二.如何配置</h4>
<ul>
<li>查看crontab的配置<br>crontab -l</li>
<li>编辑crontab的配置<br>crontab -e</li>
<li><p>crontab的格式说明<br><img src="http://bolinyoung.qiniudn.com/crontab.jpg" alt="crontab格式说明"></p>
</li>
<li><p>less  /var/log/cron<br>查看crontab运行时的日志</p>
</li>
</ul>
<h4 id="三-注意点">三.注意点</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="bullet">* </span>6 <span class="bullet">* *</span> * sh xx.sh
</pre></td></tr></table></figure>

<p>表示每天凌晨6点开始没分钟执行一次sh xx.sh脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>0 6 <span class="bullet">* *</span> * sh xx.sh
</pre></td></tr></table></figure>

<p>表示每天凌晨6点开始执行一次sh xx.sh脚本，只执行一次</p>
<p>注意上面这两个频率的区别，排查问题的时候注意考虑那些一直被忽略的点，有可能那些点就是解决问题的关键之所在。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近需要开发一些定时任务，提到定时任务，我们都会想到quartz，为了让我们的定时任务能够更加灵活的被控制，我们通过shell脚本去执行一个java类，然后定时去执行这个shell脚本即可。如何去定时执行这个shell脚本，我们想到Linux本身提供后台进程去定时执行一些命令，那就是crontab，因此我们编写好自己的shell脚本再写好crontab后就能定时执行我们的任务了。</p>
]]></summary>
    
      <category term="crontab" scheme="http://yangbolin.cn/tags/crontab/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[css换行]]></title>
    <link href="http://yangbolin.cn/2015/05/07/css-break-line/"/>
    <id>http://yangbolin.cn/2015/05/07/css-break-line/</id>
    <published>2015-05-07T13:55:59.000Z</published>
    <updated>2015-05-08T01:22:36.000Z</updated>
    <content type="html"><![CDATA[<p>最近在搞一个后台系统的时候，发现table表格的宽度没法调整，找前端大神看了一下，发现是table表格中的全英文内容过长，不会自动换行导致。因此需要用CSS来实现换行，浏览器默认不会对英文内容进行换行的。具体CSS的写法如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">word-break</span>: <span class="tag">break-all</span>;
<span class="tag">word-wrap</span>: <span class="tag">break-word</span>;
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="CSS" scheme="http://yangbolin.cn/tags/CSS/"/>
    
      <category term="前端开发" scheme="http://yangbolin.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT常用命令总结]]></title>
    <link href="http://yangbolin.cn/2015/04/26/git-command/"/>
    <id>http://yangbolin.cn/2015/04/26/git-command/</id>
    <published>2015-04-26T06:27:34.000Z</published>
    <updated>2015-04-26T06:49:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近有个项目分支使用了git托管代码，虽然之前在github上托管过很多代码，但是对git本身的使用以及特性也没有太多的深入的了解，最近使用git出现了一个问题，查到最后是环境问题，很悲摧，为了避免悲剧再次出现，就看了一遍git相关的所有常见命令以及一些git的设计思想，比如工作区，暂存区，本地仓库等等，也算是对平时编写代码思路的一种启发。很多人都说git是分布式的，svn不是分布式的，那么git分布式到底体现在哪里，每个人本地都有一个完整的仓库吗？难道svn每个人本地的代码就不是完善的吗？关于git分布式，我们从下面几个点来解释：</p>
<a id="more"></a>

<ul>
<li>1.每个人都可以在本地管理代码的变更，而不像svn如果svn中心挂了，本地代码的管理就无法实现。</li>
<li>2.使用git人人都可以成为中心，而不像svn中心有且只有1个，中心挂了，只能坐等中心恢复，不然两个开发之间的代码就没法相互感知到。但是git可以在某个中心挂了之后，其他人能快速成为中心。</li>
<li>3.github的fork功能就一个分布式的典型例子，比如作者A拥有一个仓库repo，此时开源爱好者m对这个repo很感兴趣，想贡献一些代码，因此m就去fork了repo仓库，此时开源爱好者n也知道了这个事情，n和m一起基于fork出来的repo1来贡献代码，此时有两个仓库，一个是repo一个是repo1，repo挂掉不影响repo1，repo1挂掉不影响repo，等m和n都开发结束了，就提交分支合并请求到A那边，A觉得没啥问题就合并代码到repo仓库。</li>
</ul>
<h4 id="二-命令">二.命令</h4>
<p>基于命令维度总结了一下git的一些常用命令<br><img src="http://bolinyoung.qiniudn.com/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.bmp" alt="GIT-COMMAND"></p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近有个项目分支使用了git托管代码，虽然之前在github上托管过很多代码，但是对git本身的使用以及特性也没有太多的深入的了解，最近使用git出现了一个问题，查到最后是环境问题，很悲摧，为了避免悲剧再次出现，就看了一遍git相关的所有常见命令以及一些git的设计思想，比如工作区，暂存区，本地仓库等等，也算是对平时编写代码思路的一种启发。很多人都说git是分布式的，svn不是分布式的，那么git分布式到底体现在哪里，每个人本地都有一个完整的仓库吗？难道svn每个人本地的代码就不是完善的吗？关于git分布式，我们从下面几个点来解释：</p>
]]></summary>
    
      <category term="git" scheme="http://yangbolin.cn/tags/git/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[guava中的Multimap]]></title>
    <link href="http://yangbolin.cn/2015/04/12/guava-multimap/"/>
    <id>http://yangbolin.cn/2015/04/12/guava-multimap/</id>
    <published>2015-04-12T06:32:31.000Z</published>
    <updated>2015-04-12T06:58:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>我们在日常开发过程中都会使用Map这个数据结构，使用这个数据结构能够很方便维护一些映射关系，有时候，我们存储的结构是Key-Collection的映射关系，关于这个映射关系调用put方法的时候，我们需要先调用get方法，然后看看对应的Key是否在当前映射关系中已经存在Collection，如果不存在，我们直接忘Collection中增加一个元素，不存在我们需要手动去创建，然后在往我们手工创建的Collection中增加一个元素，最后再把这个Collection写入我们的Map中，很麻烦。对于C++ STL有过了解的人都知道，STL中有一个Multimap这个数据结构，该数据结构能方便地解决上面映射关系的问题。但是JDK本身不存在这样的数据结构。。。好在guava这个开源的二方库中自己定义了这个容器，该容器既能维护好Key-Collection这个数据结构，也能很方便往这个数据结构中写数据。</p>
<a id="more"></a>

<h4 id="二-Multimap数据结构">二.Multimap数据结构</h4>
<p><img src="http://bolinyoung.qiniudn.com/key-collection.png" alt="Multimap"></p>
<h4 id="三-如何使用">三.如何使用</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultimapTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Multimap&lt;String, Integer&gt; multimap = HashMultimap.create();
        multimap.put(<span class="string">"A"</span>, <span class="number">1</span>);
        multimap.put(<span class="string">"A"</span>, <span class="number">2</span>);
        
        System.out.println(multimap.get(<span class="string">"A"</span>));
    }
}
输出结果：
[<span class="number">1</span>, <span class="number">2</span>]
</pre></td></tr></table></figure>

<p>关于上述代码，我们看到我们的操作很简单，并不需要开发工程师自己去创建一个Collection，然后把这个Collection在手工写入Map中去。</p>
<h4 id="四-总结">四.总结</h4>
<p>可能很多工程师自己愿意创建Collection，并且自己写到Map中去，但是这个维护起来很不好维护，其实想想自己创建Collection并且写到Map中，也是一件很麻烦的事情，从此以后对于Key-Collection这种数据结构，直接走Multimap。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>我们在日常开发过程中都会使用Map这个数据结构，使用这个数据结构能够很方便维护一些映射关系，有时候，我们存储的结构是Key-Collection的映射关系，关于这个映射关系调用put方法的时候，我们需要先调用get方法，然后看看对应的Key是否在当前映射关系中已经存在Collection，如果不存在，我们直接忘Collection中增加一个元素，不存在我们需要手动去创建，然后在往我们手工创建的Collection中增加一个元素，最后再把这个Collection写入我们的Map中，很麻烦。对于C++ STL有过了解的人都知道，STL中有一个Multimap这个数据结构，该数据结构能方便地解决上面映射关系的问题。但是JDK本身不存在这样的数据结构。。。好在guava这个开源的二方库中自己定义了这个容器，该容器既能维护好Key-Collection这个数据结构，也能很方便往这个数据结构中写数据。</p>
]]></summary>
    
      <category term="guava" scheme="http://yangbolin.cn/tags/guava/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javac生成的access$000方法]]></title>
    <link href="http://yangbolin.cn/2015/03/21/javac-accessbash00/"/>
    <id>http://yangbolin.cn/2015/03/21/javac-accessbash00/</id>
    <published>2015-03-21T02:07:34.000Z</published>
    <updated>2015-03-21T02:41:01.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做字节码分析的时候，发现字节码中出现了access$000的方法，这个方法不是开发工程师写的，是编译器生成的，那么编译器生成这个方法是为了解决什么问题呢？我们知道编译会为静态代码块生成执行的方法，在类没有构造函数时为类生成缺省构造函数，这个access$000究竟是在什么场景下面用的呢？仔细分析包含access$000的类，发现该类中存在内部类，结合google搜索，原来acess$000是为了解决内部类访问外部类的成员，包括成员变量和成员方法。</p>
<a id="more"></a>

<h4 id="二-深入分析">二.深入分析</h4>
<p>我们先写个简单的测试例子，一个类中包含一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> {</span>
    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">3</span>;
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span>() {
        
    }
    
    class Inner {

        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() {
            Outer.<span class="keyword">this</span>.f();
            System.out.println(Outer.<span class="keyword">this</span>.x);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span>(String[] args) {
        System.out.println(<span class="string">"Inner Test"</span>);
    }
}
</pre></td></tr></table></figure>

<p>然后我们先看内部类的字节码<br><img src="http://bolinyoung.qiniudn.com/inner-call.png" alt="内部类字节码"><br>我们看到内部类的字节码中调用了access$000和access$100这两个方法，这两个方法都是Outer这个类的静态成员方法，同时带有一个Outer类型的参数。那么我们看看Outer这个类的字节码到底是什么样子<br><img src="http://bolinyoung.qiniudn.com/outer-code.png" alt="外部类的字节码"><br>果然外部类中存在两个这样的方法，我们先看一下access$000这个方法的实现，该方法先用aload_0把方法参数入栈，然后调用栈顶元素的f方法，即Outer的f方法，因为内部类中有地方通过外部类的this引用调用Outer的f()方法。access$100这个方法，很明显在访问Outer的成员变量x。</p>
<p>至此疑问都清楚了，原来access$xxx是编译器生成的，用来解决内部类访问外部类的成员。</p>
<p>但是你一定有一个疑问，我们自己能否写access$xxx的方法呢？答案是可以的。</p>
<h4 id="三-自己编写access$xxx">三.自己编写access$xxx</h4>
<p>写个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> {</span>
    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">3</span>;
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span>() {
        
    }
    
    class Inner {

        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() {
            Outer.<span class="keyword">this</span>.f();
            System.out.println(Outer.<span class="keyword">this</span>.x);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span>(String[] args) {
        System.out.println(<span class="string">"Inner Test"</span>);
    }
    
    <span class="comment">// 编写自己的access$xxx方法</span>
    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">888</span>(Outer outer) {
    	<span class="keyword">return</span> outer.x;
    }
}
</pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<ul>
<li>我们自己编写的access$xxx不能和编译生成的具有相同的方法签名，否则你会得到一个编译错误的。</li>
<li>access$xxx可以绕过编译器的检查，访问类的私有成员。</li>
<li>一般不要编写access$xxx方法。</li>
</ul>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做字节码分析的时候，发现字节码中出现了access$000的方法，这个方法不是开发工程师写的，是编译器生成的，那么编译器生成这个方法是为了解决什么问题呢？我们知道编译会为静态代码块生成执行的方法，在类没有构造函数时为类生成缺省构造函数，这个access$000究竟是在什么场景下面用的呢？仔细分析包含access$000的类，发现该类中存在内部类，结合google搜索，原来acess$000是为了解决内部类访问外部类的成员，包括成员变量和成员方法。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程语言" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Short对象的比较]]></title>
    <link href="http://yangbolin.cn/2014/12/26/short-ref-equal/"/>
    <id>http://yangbolin.cn/2014/12/26/short-ref-equal/</id>
    <published>2014-12-26T15:02:20.000Z</published>
    <updated>2014-12-27T02:30:27.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>今天和同事一起分析线下问题，发现代码中有个笔误，对两个Short类型的对象使用==来比较，结果是比较表达式一直为false，导致一个bug的产生。</p>
<a id="more"></a>

<h4 id="二-分析">二.分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Short s = <span class="number">100</span>;
        Short s1 = <span class="number">100</span>;
        <span class="comment">// true</span>
        System.out.println(s1 == s);

        Short t = <span class="number">129</span>;
        Short t1 = <span class="number">129</span>;
        <span class="comment">// false</span>
        System.out.println(t1 == t);
        
        Short m = <span class="keyword">new</span> Short(<span class="string">"100"</span>);
        Short m1 = <span class="keyword">new</span> Short(<span class="string">"100"</span>);
        <span class="comment">// false</span>
        System.out.println(m1 == m);
    }
}
</pre></td></tr></table></figure>

<p>写了一小段代码，模拟今天遇到的问题。我们看到第一个输出为true，第二个输出为false，第三个输出为false。为什么呢？我们来看一下生成的字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre>Code:
   <span class="comment">// Stack表示操作数栈的最大深度</span>
   <span class="comment">// Locals表示局部变量表所需的存储空间，单位是Slot，JVM为局部变量分配内存所使用的最小单位，double和long占用了两个Slot</span>
   <span class="comment">// Args_size 表示方法参数个数，main函数只有一个参数，当然size为1了</span>
   <span class="comment">// 明明main方法中只有6个局部变量，为啥空间大小是7,别忘了第一个存储的是调用方法的实例，如果是静态方法存储的是类实例，如果是非静态方法存储的是this引用。</span>
   Stack=<span class="number">3</span>, Locals=<span class="number">7</span>, Args_size=<span class="number">1</span>

   <span class="number">0</span>:	bipush	<span class="number">100</span>
   <span class="comment">// 这里调用了Short类的静态方法valueOf,待会分析valueOf的实现</span>
   <span class="number">2</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">5</span>:	astore_1
   <span class="number">6</span>:	bipush	<span class="number">100</span>
   <span class="number">8</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">11</span>:	astore_2
   <span class="number">12</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">15</span>:	aload_2
   <span class="number">16</span>:	aload_1
   <span class="number">17</span>:	if_acmpne	<span class="number">24</span>
   <span class="number">20</span>:	iconst_1
   <span class="number">21</span>:	goto	<span class="number">25</span>
   <span class="number">24</span>:	iconst_0
   <span class="number">25</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">28</span>:	sipush	<span class="number">129</span>
   <span class="number">31</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">34</span>:	astore_3
   <span class="number">35</span>:	sipush	<span class="number">129</span>
   <span class="number">38</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">41</span>:	astore	<span class="number">4</span>
   <span class="number">43</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">46</span>:	aload	<span class="number">4</span>
   <span class="number">48</span>:	aload_3
   <span class="number">49</span>:	if_acmpne	<span class="number">56</span>
   <span class="number">52</span>:	iconst_1
   <span class="number">53</span>:	goto	<span class="number">57</span>
   <span class="number">56</span>:	iconst_0
   <span class="number">57</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">60</span>:	<span class="keyword">new</span>	#<span class="number">17</span>; <span class="comment">//class java/lang/Short</span>
   <span class="number">63</span>:	dup
   <span class="number">64</span>:	ldc	#<span class="number">34</span>; <span class="comment">//String 100</span>
   <span class="comment">// 这里直接调用了Short的构造函数</span>
   <span class="number">66</span>:	invokespecial	#<span class="number">36</span>; <span class="comment">//Method java/lang/Short."&lt;init&gt;":(Ljava/lang/String;)V</span>
   <span class="number">69</span>:	astore	<span class="number">5</span>
   <span class="number">71</span>:	<span class="keyword">new</span>	#<span class="number">17</span>; <span class="comment">//class java/lang/Short</span>
   <span class="number">74</span>:	dup
   <span class="number">75</span>:	ldc	#<span class="number">34</span>; <span class="comment">//String 100</span>
   <span class="comment">// 这里直接调用了Short的构造函数</span>
   <span class="number">77</span>:	invokespecial	#<span class="number">36</span>; <span class="comment">//Method java/lang/Short."&lt;init&gt;":(Ljava/lang/String;)V</span>
   <span class="number">80</span>:	astore	<span class="number">6</span>
   <span class="number">82</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">85</span>:	aload	<span class="number">6</span>
   <span class="number">87</span>:	aload	<span class="number">5</span>
   <span class="number">89</span>:	if_acmpne	<span class="number">96</span>
   <span class="number">92</span>:	iconst_1
   <span class="number">93</span>:	goto	<span class="number">97</span>
   <span class="number">96</span>:	iconst_0
   <span class="number">97</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">100</span>:	<span class="keyword">return</span>
</pre></td></tr></table></figure>

<p>我们在字节码中看到有调用Short的valueOf方法，那么接下来我们看看valueOf方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>...
<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> {</span>
	<span class="keyword">private</span> <span class="title">ShortCache</span>(){}

	<span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];

	<span class="keyword">static</span> {
	    <span class="comment">// 缓存[-127,128]之间的Short对象</span>
	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)
		cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));
	}
}
...
<span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span>(<span class="keyword">short</span> s) {
	<span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;
	<span class="keyword">int</span> sAsInt = s;
	<span class="comment">// 走缓存</span>
	<span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> && sAsInt &lt;= <span class="number">127</span>) { <span class="comment">// must cache </span>
	    <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];
	}
        <span class="keyword">return</span> <span class="keyword">new</span> Short(s);
}
...
</pre></td></tr></table></figure>

<p>看完valueOf的实现，你就明白这一切了，首先使用=赋值的时候会调用valueOf(S)这个方法，S标识short，在这方法中如果要赋予的值在[-127,128]这个区间内，那么直接取缓存中的值，缓存中缓存了[-127,128]这个区间内的所有Short对象，如果Short的值在这个区间内，你使用=赋值，直接取缓存，至此上面的问题就不言而喻了。</p>
<h4 id="三-总结">三.总结</h4>
<blockquote>
<p>1.写代码的时候最好不要使用==来比较任何类型的引用，除非是基本类型，不然很容易出问题，导致某些场景下面没问题，某些场景下面有问题。<br>2.Long类型也有类似的机制。</p>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>今天和同事一起分析线下问题，发现代码中有个笔误，对两个Short类型的对象使用==来比较，结果是比较表达式一直为false，导致一个bug的产生。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次关于servlet的扩展]]></title>
    <link href="http://yangbolin.cn/2014/11/17/servlet-extend/"/>
    <id>http://yangbolin.cn/2014/11/17/servlet-extend/</id>
    <published>2014-11-17T14:43:31.000Z</published>
    <updated>2014-11-17T14:59:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>现有一个web框架，从HttpServletRequest中获取调用request.getParameter(“orderId”)获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。</p>
<a id="more"></a>

<h4 id="二-实现思路">二.实现思路</h4>
<p>1.直接先解密orderId，然后再修改request中的orderId，你会发现你没法修改，servlet规范不允许修改request。<br>2.对HttpServletRequest进行包装，在进入web框架的时候把这个HttpServletRequest包装一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> {</span>

    <span class="keyword">private</span> Map&lt;String, String&gt; param = <span class="keyword">new</span> HashMap&lt;String, String&gt;();

    <span class="javadoc">/**
     *<span class="javadoctag"> @param</span> request
     */</span>
    <span class="keyword">public</span> <span class="title">MyHttpServletRequestWrapper</span>(HttpServletRequest request) {
        <span class="keyword">super</span>(request);
    }

    <span class="comment">// 重写获取参数值的方法</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> String <span class="title">getParameter</span>(String name) {
        <span class="keyword">if</span> (param.containsKey(name)) {
            <span class="keyword">return</span> param.get(name);
        }
        <span class="keyword">return</span> <span class="keyword">super</span>.getParameter(name);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParameter</span>(String name, String value) {
        param.put(name, value);
    }
}
</pre></td></tr></table></figure>

<p>增加解密orderId的filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOrderIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>() {
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest request, ServletResponse servletResponse, FilterChain filterChain)                                                                   <span class="keyword">throws</span> IOException,                                                         ServletException {
        String orderId = request.getParameter(<span class="string">"orderId"</span>);
        <span class="comment">// 对orderId解密</span>
        orderId = WebUtils.decode(orderId);
        MyHttpServletRequestWrapper myRequestWrapper = <span class="keyword">new</span> MyHttpServletRequestWrapper(                        (HttpServletRequest) request);
        myRequestWrapper.addParameter(<span class="string">"orderId"</span>, orderId);
        <span class="comment">// 把包装后的Request传递给下一个Filter</span>
        filterChain.doFilter(myRequestWrapper, servletResponse);
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(FilterConfig arg0) <span class="keyword">throws</span> ServletException {
    }
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>现有一个web框架，从HttpServletRequest中获取调用request.getParameter(“orderId”)获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。</p>
]]></summary>
    
      <category term="servlet" scheme="http://yangbolin.cn/tags/servlet/"/>
    
      <category term="web开发" scheme="http://yangbolin.cn/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[akka如何和Spring集成起来]]></title>
    <link href="http://yangbolin.cn/2014/11/17/akka-spring/"/>
    <id>http://yangbolin.cn/2014/11/17/akka-spring/</id>
    <published>2014-11-17T14:08:04.000Z</published>
    <updated>2014-11-17T15:16:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近又重新学习了一下akka，并且在一个web应用中成功使用了akka提升了系统的性能。我们在web应用中一般都会有dao&amp;&amp;service，这些都是spring的bean，我们定义一个actor，这个actor中可能调用dao读写数据库，也可能调用service做业务逻辑，因此我们就希望actor也是从spring容器中获取到的，这样就可以在actor中注入service&amp;&amp;dao了。</p>
<a id="more"></a>

<h4 id="二-如何从Spring容器中获取actor">二.如何从Spring容器中获取actor</h4>
<p>1.用于从Spring容器中获取actor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringActorProducer</span> <span class="keyword">implements</span> <span class="title">IndirectActorProducer</span> {</span>

    <span class="keyword">final</span> ApplicationContext applicationContext;
    <span class="keyword">final</span> String             actorBeanName;

    <span class="keyword">public</span> <span class="title">SpringActorProducer</span>(ApplicationContext applicationContext, String actorBeanName){
        <span class="keyword">this</span>.applicationContext = applicationContext;
        <span class="keyword">this</span>.actorBeanName = actorBeanName;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Actor <span class="title">produce</span>() {
        <span class="keyword">return</span> (Actor) applicationContext.getBean(actorBeanName);
    }

    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Class&lt;? extends Actor&gt; <span class="title">actorClass</span>() {
        <span class="keyword">return</span> (Class&lt;? extends Actor&gt;) applicationContext.getType(actorBeanName);
    }
}
</pre></td></tr></table></figure>

<p>2.扩展actor的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>public class SpringExtension extends AbstractExtensionId&lt;SpringExtension.SpringExt&gt; {

    /**
     * The identifier used to access the SpringExtension.
     */
    public static SpringExtension SpringExtProvider = new SpringExtension();

    /**
     * Is used by Akka to instantiate the Extension identified by this ExtensionId, internal use only.
     */
    @Override
    public SpringExt createExtension(ExtendedActorSystem system) {
        return new SpringExt();
    }

    /**
     * The Extension implementation.
     */
    public static class SpringExt implements Extension {

        private volatile ApplicationContext applicationContext;

        /**
         * Used to initialize the Spring application context for the extension.
         * 
         * @param applicationContext
         */
        public void initialize(ApplicationContext applicationContext) {
            this.applicationContext = applicationContext;
        }

        /**
         * Create a Props for the specified actorBeanName using the SpringActorProducer class.
         * 
         * @param actorBeanName The name of the actor bean to create Props for
         * @return a Props that will create the named actor bean using Spring
         */
        public Props props(String actorBeanName) {
            return Props.create(SpringActorProducer.class, applicationContext, actorBeanName);
        }
    }
}
</pre></td></tr></table></figure>

<p>3.示例actor以及actor依赖的service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingService</span> {</span>
  <span class="javadoc">/**
   * Increment the given number by one.
   */</span>
  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increment</span>(<span class="keyword">int</span> count) {
    <span class="keyword">return</span> count + <span class="number">1</span>;
  }
}
class CountingActor extends UntypedActor {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> {</span>}
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span> {</span>}

    <span class="comment">// the service that will be automatically injected</span>
    <span class="keyword">private</span> CountingService countingService;

    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object message) <span class="keyword">throws</span> Exception {
        System.out.println(countingService);
        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Count) {
            count = countingService.increment(count);
        } <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Get) {
            getSender().tell(count, getSelf());
        } <span class="keyword">else</span> {
            unhandled(message);
        }
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountingService</span>(CountingService countingService) {
        <span class="keyword">this</span>.countingService = countingService;
    }
    
    <span class="keyword">public</span> <span class="title">CountingActor</span>() {
        System.out.println(<span class="string">"CountingActor is Creating..."</span>);
    }
}
</pre></td></tr></table></figure>

<p>CountingActor依赖了CountingService，CountingService到时候会被注入到CountingActor中。</p>
<p>4.配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
	<span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>
	<span class="attribute">default-autowire</span>=<span class="value">"byName"</span>&gt;</span>

	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"countingService"</span> <span class="attribute">class</span>=<span class="value">"com.bolin.young.akka.spring.CountingService"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"countingActor"</span> <span class="attribute">class</span>=<span class="value">"com.bolin.young.akka.spring.CountingActor"</span>  <span class="attribute">scope</span>=<span class="value">"prototype"</span> /&gt;</span>

	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myActorSystem"</span> <span class="attribute">class</span>=<span class="value">"akka.actor.ActorSystem"</span>
		<span class="attribute">factory-method</span>=<span class="value">"create"</span> <span class="attribute">destroy-method</span>=<span class="value">"shutdown"</span> <span class="attribute">scope</span>=<span class="value">"singleton"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"mySpringAkkaSystem"</span> /&gt;</span>
	<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
	
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<p>5.如何使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// create a spring context and scan the classes</span>
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);

    ActorSystem myActorSystem = (ActorSystem)ctx.getBean(<span class="string">"myActorSystem"</span>);
    
    System.out.println(myActorSystem);
    
    SpringExtProvider.get(myActorSystem).initialize(ctx);
    
    <span class="keyword">final</span> ActorRef myActor = myActorSystem.actorOf(
                   SpringExtProvider.get(myActorSystem).props(<span class="string">"countingActor"</span>), <span class="string">"countingActor"</span>);
</pre></td></tr></table></figure>

<h4 id="三-最后总结">三.最后总结</h4>
<p>1.一般actorA发消息给actorB，actorB返回消息给actorA。我们可以自己在代码中发消息给actorA，然后坐等actorA的返回，如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>BootstrapAnalyzeMsg bootstrapAnalyzeMsg = <span class="keyword">new</span> BootstrapAnalyzeMsg();
bootstrapAnalyzeMsg.setFileItem(treeFile);

Timeout timeout = <span class="keyword">new</span> Timeout(Duration.create(TIME_OUT, <span class="string">"seconds"</span>));
Future&lt;Object&gt; future = Patterns.ask(bootstrapAnalyzeActor, bootstrapAnalyzeMsg, timeout);

<span class="keyword">try</span> {
     <span class="comment">// 当前线程会阻塞，直到有当前的Actor有消息过来。</span>
     ProjectAnalyzeResultMsg projectAnalyzeResultMsg = (ProjectAnalyzeResultMsg) Await.result(future,                                            timeout.duration());
     <span class="keyword">return</span> projectAnalyzeResultMsg.getJarConflictInfoList();
} <span class="keyword">catch</span> (Exception e) {
     e.printStackTrace();
} <span class="keyword">finally</span> {
     bootstrapAnalyzeActor.tell(<span class="keyword">new</span> ActorStopMsg(), <span class="keyword">null</span>);
}
</pre></td></tr></table></figure>

<p>该思想类似于java的Future。<br>2.actor也可以终止自己,没用的actor尽量提前终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>getContext().stop(getSelf());
</pre></td></tr></table></figure>

<p>3.actor在系统中的名字必须唯一。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近又重新学习了一下akka，并且在一个web应用中成功使用了akka提升了系统的性能。我们在web应用中一般都会有dao&amp;&amp;service，这些都是spring的bean，我们定义一个actor，这个actor中可能调用dao读写数据库，也可能调用service做业务逻辑，因此我们就希望actor也是从spring容器中获取到的，这样就可以在actor中注入service&amp;&amp;dao了。</p>
]]></summary>
    
      <category term="Akka" scheme="http://yangbolin.cn/tags/Akka/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用事务的一个注意点]]></title>
    <link href="http://yangbolin.cn/2014/10/31/transaction-attention/"/>
    <id>http://yangbolin.cn/2014/10/31/transaction-attention/</id>
    <published>2014-10-31T09:12:19.000Z</published>
    <updated>2015-01-02T14:17:59.000Z</updated>
    <content type="html"><![CDATA[<p>最近在代码中配置了一个事务，事务的意思就是当前这件事情要么全部正常做完，要么全部不做。为了避免数据库中出现脏数据，我给XXX类的ff方法配置了事务。在ff方法主要做下面这几件事情</p>
<a id="more"></a>

<ul>
<li>1.从数据库中读出一批数据dataList1，此时dataList1已经存在于内存中了。</li>
<li>2.修改这一批数据，此时的修改不会写到数据库，因为事务暂时还没有提交。</li>
<li>3.根据dataList1中的数据进行判断，然后再写数据库。</li>
</ul>
<p>这么处理有问题，因为dataList1在2结束后，会发生变化，但是内存中的dataList1感知不到，也就是说3处用的dataList1还是老数据，不是2修改后的数据，因此3处的判断条件会出现问题，因为3处用到的dataList1不是事务中最新的数据。</p>
<p>修复后的步骤如下：</p>
<ul>
<li>1.从数据库中读出一批数据dataList1，此时dataList1已经存在于内存中了。</li>
<li>2.修改这一批数据，此时的修改不会写到数据库，因为事务暂时还没有提交。</li>
<li>3.从数据库中再读取一次dataList1。</li>
<li>4.根据dataList1中的数据进行判断，然后再写数据库。</li>
</ul>
<p>注意：<br>事务中对数据库进行读写操作，此时写入的数据不会写到数据库中，但是能从事务中读取到最新的数据，如果要基于某些数据做判断，最好保证判断时这些数据在事务中是最新的，不要沿用一开始就加载到内存中的那批数据，因为一开始的数据不是最新的。</p>
<p>在事务中切忌发消息给其他系统，因为这个逻辑不对，事务可能会回滚，因为数据出错啥的，但是发出去的消息没法回滚，因此一旦在事务中发消息就会破坏事务的一致性。自己在事务中发了一个消息给外部系统，事务还没有提交，外部系统收到消息后找我来查询刚才事务中产生的数据，查询DB当然就查询不到了，因为事务还没有提交，消息就已经出去了，以后在事务中切忌发消息给外部系统。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在代码中配置了一个事务，事务的意思就是当前这件事情要么全部正常做完，要么全部不做。为了避免数据库中出现脏数据，我给XXX类的ff方法配置了事务。在ff方法主要做下面这几件事情</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于log4j的additivity]]></title>
    <link href="http://yangbolin.cn/2014/10/31/log4j-additivity/"/>
    <id>http://yangbolin.cn/2014/10/31/log4j-additivity/</id>
    <published>2014-10-31T09:10:37.000Z</published>
    <updated>2014-10-31T09:36:55.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-问题描述">一.问题描述</h4>
<p>最近优化了一下一个应用的日志，但是优化后的结果不是自己想要的，简单说指定的log部分输出到了root中的appender中，部分输出到自己指定的log中。</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"BOORT"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"file"</span> <span class="attribute">value</span>=<span class="value">"xxx/boort.log"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"append"</span> <span class="attribute">value</span>=<span class="value">"true"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"encoding"</span> <span class="attribute">value</span>=<span class="value">"GBK"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> <span class="attribute">value</span>=<span class="value">"%d %-5p %c{2} - %m%n"</span> /&gt;</span>
	<span class="tag">&lt;/<span class="title">layout</span>&gt;</span>
<span class="tag">&lt;/<span class="title">appender</span>&gt;</span>
<span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"OPENAPI"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"file"</span> <span class="attribute">value</span>=<span class="value">"xxx/service/api.log"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"append"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"encoding"</span> <span class="attribute">value</span>=<span class="value">"GBK"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> <span class="attribute">value</span>=<span class="value">"%d %-5p %c{2} - %m%n"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>
<span class="tag">&lt;/<span class="title">appender</span>&gt;</span>

<span class="tag">&lt;<span class="title">logger</span> <span class="attribute">name</span>=<span class="value">"xxxx.Service"</span> <span class="attribute">additivity</span>=<span class="value">"true"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"info"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"OPENAPI"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">logger</span>&gt;</span>
<span class="tag">&lt;<span class="title">root</span>&gt;</span>
	<span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"info"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"BOORT"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"JmonitorAppender"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">root</span>&gt;</span>
</pre></td></tr></table></figure>

<p>上述xxxx.Service中的日志部分会出现到boort.log，部分会出现到api.log中。但是我们期望xxxx.Service中日志只出现到api.log中。</p>
<h4 id="二-解决方案">二.解决方案</h4>
<p>上面的问题肯定是日志配置的问题，google后发现additivity=”true”在搞鬼<br><a href="http://wiki.apache.org/logging-log4j/Log4jXmlFormat" target="_blank">log4j的配置</a><br>具体说明如下：<br><img src="http://bolinyoung.qiniudn.com/log4j-additivity.png" alt="log4j的additivity"></p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-问题描述">一.问题描述</h4>
<p>最近优化了一下一个应用的日志，但是优化后的结果不是自己想要的，简单说指定的log部分输出到了root中的appender中，部分输出到自己指定的log中。</p>
]]></summary>
    
      <category term="log4j" scheme="http://yangbolin.cn/tags/log4j/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka入门]]></title>
    <link href="http://yangbolin.cn/2014/10/25/akka-start/"/>
    <id>http://yangbolin.cn/2014/10/25/akka-start/</id>
    <published>2014-10-25T14:35:44.000Z</published>
    <updated>2014-10-25T14:55:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>为了提高一个数据计算平台的吞吐了，最近抽空看了看akka，之前听同事说akka能够提高并发吞吐量，高容错，很稳定，今天抽时间先简单看了相关的文档，写了个简单的例子，主要演示如何使用akka，当然我们也可以搭建一个akka的集群。</p>
<a id="more"></a>

<h4 id="二-快速开始">二.快速开始</h4>
<p>akka相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="comment">&lt;!--  akka starting --&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-actor_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-remote_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-kernel_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-cluster_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-contrib_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-slf4j_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.fusesource<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>sigar<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-cluster_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="comment">&lt;!--  akka ending  --&gt;</span>
</pre></td></tr></table></figure>

<p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> Msg {
    GREET, DONE, WELCOME;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object msg) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (msg == Msg.GREET) {
            System.out.println(<span class="string">"Greeter Messgae!"</span>);
            <span class="comment">// 收到GREET消息后发出一个DONE的应答</span>
            getSender().tell(Msg.DONE, getSelf());
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object arg0) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (arg0 == Msg.WELCOME) {  
            System.out.println(<span class="string">"Welcome Messgae!"</span>);
            <span class="comment">// 收到WELCOME消息后，发出一个WELCOME的应答</span>
            getSender().tell(Msg.WELCOME, getSelf());
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preStart</span>() {
        <span class="comment">// 发送WELCOME消息给welcome这个Actor</span>
        <span class="keyword">final</span> ActorRef welcome = getContext().actorOf(Props.create(Welcome.class), <span class="string">"welcome"</span>);
        welcome.tell(Msg.WELCOME, getSelf());
        
        <span class="comment">// 发送GREET消息给greet这个Actor</span>
        <span class="keyword">final</span> ActorRef greeter = getContext().actorOf(Props.create(Greeter.class), <span class="string">"greeter"</span>);
        greeter.tell(Msg.GREET, getSelf());
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object msg) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (msg == Msg.DONE) {
            System.out.println(<span class="string">"Message DONE"</span>);
            getContext().stop(getSelf());
        } <span class="keyword">else</span> {
            System.out.println(msg);
        }
    }
}
</pre></td></tr></table></figure>

<p>这里的HelloWorld，Welcome，Greeter是三个Actor，在上述代码中HelloWorld向Welcome，Greeter发消息，Welcome，Greeter收到消息后分别向HelloWorld发出回应。<br>HelloWorld在收到DONE消息后会终止自己。通过akka.Main来启动，设置启动参数com.bolin.young.akka.HelloWorld，这样就能看到相关的输出了。</p>
<h4 id="三-总结">三.总结</h4>
<p>通过上面这个小例子，我们发现akka中有一个核心的东西，那就是actor，actor之间通过消息通信，actorA发消息给actorB，actorB收到actorA的消息后，也可以对actorA发送一个回应的消息。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>为了提高一个数据计算平台的吞吐了，最近抽空看了看akka，之前听同事说akka能够提高并发吞吐量，高容错，很稳定，今天抽时间先简单看了相关的文档，写了个简单的例子，主要演示如何使用akka，当然我们也可以搭建一个akka的集群。</p>
]]></summary>
    
      <category term="Akka" scheme="http://yangbolin.cn/tags/Akka/"/>
    
      <category term="并发技术" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过开放调用来避免死锁]]></title>
    <link href="http://yangbolin.cn/2014/10/25/open-call-to-avoid-deadlock/"/>
    <id>http://yangbolin.cn/2014/10/25/open-call-to-avoid-deadlock/</id>
    <published>2014-10-25T13:00:45.000Z</published>
    <updated>2014-10-25T13:31:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在编写并发程序的时候，我们经常会在一次业务逻辑处理过程中获取多个锁，然后做一些操作，如果这多个锁的获取顺序和其他地方的获取顺序不同的话，很容易发生死锁。为了避免这种死锁，我们必须保证获取多个锁的顺序一致，或者方法调用为开放调用，即调用某个方法时不需要持有锁。</p>
<a id="more"></a>

<h4 id="二-示例分析">二.示例分析</h4>
<p>Taxi表示一个出租车对象，包含位置和目的地两个属性，Dispatcher代表一个出租车队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>class Taxi {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>)<span class="keyword">private</span> Point location, destination;
	<span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;
	<span class="keyword">public</span> <span class="title">Taxi</span>(Dispatcher dispatcher) {
		<span class="keyword">this</span>.dispatcher = dispatcher;
	}
	<span class="javadoc">/** 获取出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span>() {
		<span class="keyword">return</span> location;
	}
	<span class="javadoc">/** 设置出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span>(Point location) {
		<span class="keyword">this</span>.location = location;
		<span class="keyword">if</span> (location.equals(distination)) {
			dispatcher.notifyAvailable(<span class="keyword">this</span>);
		}
	}
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>class Dispatcher {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;
	
	<span class="keyword">public</span> <span class="title">Dispatcher</span>() {
		taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
		availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
	}
	
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span>(Taxi taxi) {
		availableTaxis.add(taxi);
	}
	<span class="javadoc">/** 获取某个时刻，整个车队的完整快照 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span>() {
		Image image = <span class="keyword">new</span> Image();
		<span class="keyword">for</span> (Taxi t : taxis) {
			image.drawMarker(t.getLocation());
		}
		<span class="keyword">return</span> image;
	}
}
</pre></td></tr></table></figure>

<p>看看上面的代码，我们就知道setLocation和notifyAvailable方法都是同步方法，调用setLocation的线程首先获取Taxi上的锁，然后获取Dispatcher的锁。getImage方法先获取Dispatcher上的锁，再获取Taxi上的锁，这两个方法被不同的线程调用时容易产生死锁，相信现在的滴滴以及快的绝对不是这么干的。</p>
<p>下面我看看如何通过开放调用来避免这个死锁的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>class Taxi {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>)<span class="keyword">private</span> Point location, destination;
	<span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;
	<span class="keyword">public</span> <span class="title">Taxi</span>(Dispatcher dispatcher) {
		<span class="keyword">this</span>.dispatcher = dispatcher;
	}
	<span class="javadoc">/** 获取出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span>() {
		<span class="keyword">return</span> location;
	}
	<span class="javadoc">/** 设置出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span>(Point location) {
		<span class="keyword">boolean</span> reachedDestination = <span class="keyword">false</span>;
		<span class="javadoc">/** 缩小缩的范围 把方法变成开发调用 **/</span>
		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) {
			<span class="keyword">this</span>.location = location;
			reachedDestination = location.equals(distination);
		}
		
		<span class="keyword">if</span> (reachedDestination) {
			dispatcher.notifyAvailable(<span class="keyword">this</span>);
		}
	}
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>class Dispatcher {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;
	
	<span class="keyword">public</span> <span class="title">Dispatcher</span>() {
		taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
		availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
	}
	
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span>(Taxi taxi) {
		availableTaxis.add(taxi);
	}
	<span class="javadoc">/** 获取每辆出租车不同时刻的位置 **/</span>
	<span class="keyword">public</span> Image <span class="title">getImage</span>() {
		Set&lt;Taxi&gt; copy;
		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) {
			copy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);
		}
		Image image = <span class="keyword">new</span> Image();
		<span class="keyword">for</span> (Taxi t : taxis) {
			image.drawMarker(t.getLocation());
		}
		<span class="keyword">return</span> image;
	}
}
</pre></td></tr></table></figure>

<p>通过上面的改造，我们把setLocation和getImage都变成了开放调用，与那些持有锁时调用外部方法的程序相比，更容易对依赖的开发调用的程序进行死锁分析。</p>
<p>在编写并发程序的时候，一定要注意一个思想，加锁范围最小化。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在编写并发程序的时候，我们经常会在一次业务逻辑处理过程中获取多个锁，然后做一些操作，如果这多个锁的获取顺序和其他地方的获取顺序不同的话，很容易发生死锁。为了避免这种死锁，我们必须保证获取多个锁的顺序一致，或者方法调用为开放调用，即调用某个方法时不需要持有锁。</p>
]]></summary>
    
      <category term="Concurrency" scheme="http://yangbolin.cn/tags/Concurrency/"/>
    
      <category term="并发技术" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[项目中的点点滴滴]]></title>
    <link href="http://yangbolin.cn/2014/10/19/project-accumulation-1/"/>
    <id>http://yangbolin.cn/2014/10/19/project-accumulation-1/</id>
    <published>2014-10-19T08:21:50.000Z</published>
    <updated>2014-10-19T10:08:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近一直在忙项目中的事情，不过在整个开发过程中自己也有一些体会，写写这些体会，就当是自己的经验了，这里不会涉及到太深的原理，只是记录一些技巧以及一些值得注意的地方，形成一些编程的思想，理念，可以更好地运用到后续的项目之中。</p>
<a id="more"></a>

<h4 id="二-关于Spring定时任务">二.关于Spring定时任务</h4>
<p>Spring定时任务在项目中经常会被使用，我们经常通过限定IP的方式保证我们自己设计的定时任务只会在一台机器上启动，关于Spring定时任务在项目中需要注意一下配置，有时候会漏写一些配置，其实没有必要死记这些配置怎么写，按照正常的思路，你需要指定要运行的任务是什么，其次，既然是定时任务，那就需要指定定时，也就是什么时候运行，最后，任务以及任务要运行的时间都有了，那么如何调度呢？也就是说运行时刻到了，谁来调度这个任务。显然配置Spring定时任务需要把握三个要素，就是上面这三个点，下面我们写一个简单的配置例子来说明一下这三个点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 1.指定要运行的任务 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"autoAuditFailedTaskJobDetail"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"concurrent"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>false<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"autoAuditFailedTask"</span> /&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">value</span>&gt;</span>execute<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
 <span class="comment">&lt;!-- 2.配置触发器 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"autoAuditFailedTaskCronTrigger"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;</span>
    <span class="comment">&lt;!-- 这里不可以直接在属性jobDetail中引用taskJob，因为他要求的是一个jobDetail类型的对象，所以我们得通过MethodInvokingJobDetailFactoryBean来转一下 --&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jobDetail"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"autoAuditFailedTaskJobDetail"</span> /&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="comment">&lt;!-- 每天晚上23:00点触发  --&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cronExpression"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">value</span>&gt;</span>0 0 23 * * ?<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="comment">&lt;!-- 3. 添加调度器 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"triggers"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">list</span>&gt;</span>
          <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"autoAuditFailedTaskCronTrigger"</span> /&gt;</span>
       <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<p>在配置的时候注意这三个点，缺一不可。</p>
<h4 id="三-关于NPE">三.关于NPE</h4>
<p>我们在写代码的时候经常会考虑NPE的问题，对于参数经常会做NPE校验，在对每一个参数做NPE校验的时候一定要想一下该参数是否一定不为NULL，不要一味地追求NPE。</p>
<h4 id="四-关于时间的加减以及格式化">四.关于时间的加减以及格式化</h4>
<p>经常有这样的需求，需要把当前时间向前或者向后推算N天，以及对时间做格式化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Calendar calendar = Calendar.getInstance();
calendar.setTime(<span class="keyword">new</span> Date());
<span class="comment">// n可以为正数，也可以为负数</span>
calendar.add(Calendar.DAY_OF_MONTH, n);
<span class="comment">// 时间格式化</span>
DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"MM/dd"</span>);
format.format(calendar.getTime());
</pre></td></tr></table></figure>

<h4 id="五-关于xstream">五.关于xstream</h4>
<p>xstream可以实现XML和Object之间的相互转换</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span>

    <span class="keyword">private</span> <span class="keyword">int</span>     age;
    <span class="keyword">private</span> SexEnum sex;
    <span class="keyword">private</span> String  name;

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>() {
        <span class="keyword">return</span> age;
    }

    <span class="keyword">public</span> SexEnum <span class="title">getSex</span>() {
        <span class="keyword">return</span> sex;
    }

    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span>(<span class="keyword">int</span> age) {
        <span class="keyword">this</span>.age = age;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span>(SexEnum sex) {
        <span class="keyword">this</span>.sex = sex;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> SexEnum {
    MALE(<span class="string">"M"</span>), FEMALE(<span class="string">"F"</span>);

    String value;

    SexEnum(String value){
        <span class="keyword">this</span>.value = value;
    }

    <span class="keyword">public</span> String <span class="title">getValue</span>() {
        <span class="keyword">return</span> value;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(String value) {
        <span class="keyword">this</span>.value = value;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> SexEnum <span class="title">parse</span>(String value) {
        <span class="keyword">for</span> (SexEnum sexEnum : SexEnum.values()) {
            <span class="keyword">if</span> (value.equals(sexEnum.getValue())) {
                <span class="keyword">return</span> sexEnum;
            }
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XStreamTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="comment">// Object TO XML</span>
        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();
        Person person1 =  <span class="keyword">new</span> Person();
        person1.setAge(<span class="number">22</span>);
        person1.setName(<span class="string">"nuaa"</span>);
        person1.setSex(SexEnum.MALE);
        personList.add(person1);
        
        Person person2 =  <span class="keyword">new</span> Person();
        person2.setAge(<span class="number">22</span>);
        person2.setName(<span class="string">"buaa"</span>);
        person2.setSex(SexEnum.MALE);
        personList.add(person2);
        
        XStream xstream = <span class="keyword">new</span> XStream();
        <span class="comment">// 使用别名</span>
        xstream.alias(<span class="string">"person"</span>, Person.class);
        xstream.alias(<span class="string">"personList"</span>, List.class);
        <span class="comment">// 注册枚举转换器</span>
        xstream.registerConverter(<span class="keyword">new</span> AbstractSingleValueConverter(){
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span>(@<span class="title">SuppressWarnings</span>("rawtypes") Class type) {
                <span class="keyword">if</span> (type.equals(SexEnum.class)) {
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                }
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
            <span class="comment">// String转换成对象</span>
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> Object <span class="title">fromString</span>(String str) {
                <span class="keyword">return</span> SexEnum.parse(str);
            }

            <span class="comment">// 对象转换成String</span>
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> String <span class="title">toString</span>(Object obj) {
                SexEnum sexEnum = (SexEnum)obj;
                <span class="keyword">return</span> sexEnum.getValue();
            }
        });
        
        String xml = xstream.toXML(personList);
        System.out.println(xml);

        <span class="comment">// XML TO Object</span>
        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
        List&lt;Person&gt; fromXMLList = (List&lt;Person&gt;)xstream.fromXML(xml);
        System.out.println(fromXMLList);
        <span class="keyword">for</span>(Person person : fromXMLList) {
            System.out.println(<span class="string">"#############################"</span>);
            System.out.println(<span class="string">"age: "</span> + person.getAge());
            System.out.println(<span class="string">"sex: "</span> + person.getSex());
            System.out.println(<span class="string">"name: "</span> + person.getName());
        }
    }
}
</pre></td></tr></table></figure>

<p>使用xtream可以避免自己解析XML文件。</p>
<h4 id="六-关于fastjson">六.关于fastjson</h4>
<p>fastjson把对象转化成json字符串时会出现$ref，这是由于对象之间有循环引用导致，这有可能导致堆栈溢出，我们可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>JSON.toJSONString(object,  SerializerFeature.DisableCircularReferenceDetect)
</pre></td></tr></table></figure>

<p>来避免json串中出现$ref。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近一直在忙项目中的事情，不过在整个开发过程中自己也有一些体会，写写这些体会，就当是自己的经验了，这里不会涉及到太深的原理，只是记录一些技巧以及一些值得注意的地方，形成一些编程的思想，理念，可以更好地运用到后续的项目之中。</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用BTrace监控方法入参]]></title>
    <link href="http://yangbolin.cn/2014/10/12/btrace-for-exception/"/>
    <id>http://yangbolin.cn/2014/10/12/btrace-for-exception/</id>
    <published>2014-10-12T10:06:18.000Z</published>
    <updated>2014-11-08T07:20:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>昨天在生产环境出现一个类的方法被调用然后出现了异常，这个异常没有被catch而是直接抛给上层的调用，我们想知道抛异常时调用该方法的参数是什么样子的，然后根据这个参数分析问题聚图出现在什么地方。</p>
<a id="more"></a>

<p>为了能够清晰的说明问题，这里大致描述一下昨天出问题的类的代码结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxUtil</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">decodeXxx</span>(String sSrc, String sSkey,String iVParam) <span class="keyword">throws</span> Exception {
	<span class="comment">// 在这里做解码，然后在这里抛异常了</span>
	}
}
</pre></td></tr></table></figure>

<p>静态方法decodeXxx被调用时，在方法内部抛出了没有被catch住的异常，这就是基本现象。</p>
<h4 id="二-排查过程">二.排查过程</h4>
<p>我们需要知道调用decodeXxx方法是参数是什么样子的，生成环境没法DEBUG只能考虑使用BTrace脚本了，使用BTrace动态监控decodeXxx的调用，然后输出方法调用的参数，于是我准备了如下的BTrace脚本，此时所有decodeXxx方法的调用都会被监控到，如何区分有异常的case呢？我们日志中记录的异常以及异常发生的时间，因此我们需要在监控脚本中输出监控时间，然后和日志中异常发生的时间对比，找出最终出现问题的方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;
<span class="keyword">import</span> com.sun.btrace.annotations.*;
<span class="keyword">import</span> com.sun.btrace.AnyType;

<span class="annotation">@BTrace</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceMethodArgsAndReturn</span>{</span>

        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>,
        location=<span class="annotation">@Location</span>(Kind.RETURN)
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"Call xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
                <span class="comment">// 输出时间,这里之所以输出时间就是为了和日志中的时间对比寻找出错时方法调用的入参，日志中记录了异常时间</span>
                println(strcat(<span class="string">"time is:"</span>,str(timeMillis()));
        }
}
</pre></td></tr></table></figure>

<p>脚本准备好了，然后在线上和JVM建立链接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sudo -u admin /home/boris<span class="preprocessor">.yangbl</span>/btrace/bin/btrace -<span class="keyword">cp</span> /home/boris<span class="preprocessor">.yangbl</span>/btrace/build <span class="number">8485</span> TraceMethodArgsAndReturn<span class="preprocessor">.java</span>
</pre></td></tr></table></figure>

<p>其中8485是JVM的PID。<br>执行命令后，监控确实被监控到了，但是方法内部抛异常的case没有被监控到，奇怪，此时子写检查上面的监控脚本，发现location=@Location(Kind.RETURN)，这说明方法返回时才会被监控到，要是方法抛异常了，方法的return字节码压根就不会被调用，要是方法的return字节码不会被调用，那BTrace动态增加的字节码也不会被调用，因此需要修改一下BTrace脚本了，输出的时候不要限制方法返回，现在把BTrace脚本修改如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;
<span class="keyword">import</span> com.sun.btrace.annotations.*;
<span class="keyword">import</span> com.sun.btrace.AnyType;

<span class="annotation">@BTrace</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceMethodArgsAndReturn</span>{</span>

        <span class="comment">// 方法返回时的监控</span>
        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>,
        location=<span class="annotation">@Location</span>(Kind.RETURN)
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"return xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
        }
        <span class="comment">// 进入方法的监控</span>
        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"enter xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
        }
}
</pre></td></tr></table></figure>

<p>修改成上面的监控脚本后，我们都不需要在脚本中输出监控时间了，要是有方法抛异常的化了，必然会出现只有enter(进入方法的监控)没有return(方法返回时的监控)的输出，由于线上有两台机器，因此同时在这两台机器上使用了这个BTrace脚本，最终定位到了decodeXxx方法内部抛出异常时方法的入参是什么。后面的分析和业务有关，这里不做过多解释。</p>
<h4 id="三-最后总结">三.最后总结</h4>
<p>location=@Location(Kind.RETURN)要是方法内部出现异常的话，此时被BTrace修改后的字节码就没法执行了。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>昨天在生产环境出现一个类的方法被调用然后出现了异常，这个异常没有被catch而是直接抛给上层的调用，我们想知道抛异常时调用该方法的参数是什么样子的，然后根据这个参数分析问题聚图出现在什么地方。</p>
]]></summary>
    
      <category term="BTrace" scheme="http://yangbolin.cn/tags/BTrace/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA线程本地存储之ThreadLocal的分析]]></title>
    <link href="http://yangbolin.cn/2014/10/07/thread-local-analyze/"/>
    <id>http://yangbolin.cn/2014/10/07/thread-local-analyze/</id>
    <published>2014-10-07T13:01:03.000Z</published>
    <updated>2014-10-07T13:07:13.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ThreadLocal是JDK的一个线程本地存储的类，我们可以把一些线程私有的数据写在ThreadLocal中，这样这些数据只有一个线程可见，实现了所谓的栈封闭。这样存储一些线程私有的数据，我们就不用去费心考虑如何保证临界资源的互斥访问了，同时对于一个线程，这些私有数据也只做一次初始化。</p>
<a id="more"></a>

<h4 id="二-一段ThreadLocal的测试代码">二.一段ThreadLocal的测试代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>class LocalObject {
    <span class="keyword">private</span> String name;
    
    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}

class LocalStoreThread extends Thread {
    <span class="javadoc">/** 定义了一个线程本地存储的成员变量 **/</span>
    <span class="keyword">private</span> ThreadLocal&lt;LocalObject&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;LocalObject&gt;();

    <span class="keyword">public</span> <span class="title">LocalStoreThread</span>(LocalObject lo) {
        threadLocal.set(lo);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        System.out.println(threadLocal.get().getName());
    }
}

<span class="javadoc">/**
 * &lt;pre&gt;
 * 创建一个线程实例，这个线程实例中有一个线程本地存储成员变量
 * &lt;/pre&gt;
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        LocalObject lo = <span class="keyword">new</span> LocalObject();
        lo.setName(<span class="string">"thread-local"</span>);
        <span class="keyword">new</span> LocalStoreThread(lo).start();
    }
}
</pre></td></tr></table></figure>

<p>上述代码运行的时候在run方法中抛出了空指针异常，明明在构造函数中调用了threadLocal的set方法，为什么get的时候获取到了null,然后使用了null抛出了NPE呢？</p>
<p>由于ThreadLocal是和线程相关的，我们上面的代码在够在函数中往线程本地存储变量中设置了一个实例对象，在run方法中获取这个实例对象的时候发现拿到是null,所以我们有必要看一下set时对应的线程和get时对应的线程是不是一样的。因此在set之前打印一下Thread.currentThread()，同时在get之前打印一下Thread.currentThread()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>class LocalObject {
    <span class="keyword">private</span> String name;
    
    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}

class LocalStoreThread extends Thread {
    <span class="javadoc">/** 定义了一个线程本地存储的成员变量 **/</span>
    <span class="keyword">private</span> ThreadLocal&lt;LocalObject&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;LocalObject&gt;();

    <span class="keyword">public</span> <span class="title">LocalStoreThread</span>(LocalObject lo) {
        <span class="comment">// set之前打印当前线程</span>
        System.out.println(Thread.currentThread().getName());   <span class="comment">// main</span>
        threadLocal.set(lo);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="comment">// get之前打印当前线程</span>
        System.out.println(Thread.currentThread().getName()); <span class="comment">// Thread-0</span>
        System.out.println(threadLocal.get().getName());
    }
}

<span class="javadoc">/**
 * &lt;pre&gt;
 * 创建一个线程实例，这个线程实例中有一个线程本地存储成员变量
 * &lt;/pre&gt;
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        LocalObject lo = <span class="keyword">new</span> LocalObject();
        lo.setName(<span class="string">"thread-local"</span>);
        <span class="keyword">new</span> LocalStoreThread(lo).start();
    }
}
</pre></td></tr></table></figure>

<p>好，问题出现了，set时的当前线程和get时的当前线程不一样，所以get的结果是null。set是写在线程的构造函数中的，此时当前线程是main线程，因为在main线程中创建线程。但是在run方法中当前线程已经不是main线程了变成了new出来的这个新线程了。</p>
<h4 id="三-ThreadLocal中get和set方法分析">三.ThreadLocal中get和set方法分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">public</span> T <span class="title">get</span>() {
        <span class="comment">// 获取当前线程实例</span>
        Thread t = Thread.currentThread();
        <span class="comment">/* 获取当前线程实例的ThreadLocalMap，其实就是一个数组
         * 这个数组可以扩容，每次空间不够时都拿当前大小*2
         */</span>
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {
            <span class="comment">/*根据this哈希获取数组中的一个元素*/</span>
            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);
            <span class="keyword">if</span> (e != <span class="keyword">null</span>)
                <span class="keyword">return</span> (T)e.value;
        }
        <span class="comment">// 如果当前线程的ThreadLocalMap为null,就创建一个</span>
        <span class="keyword">return</span> setInitialValue();
}
<span class="keyword">private</span> T <span class="title">setInitialValue</span>() {
        <span class="comment">/* 这里调用了ThreadLocal的initValue方法，一般都会在创建ThreadLocal
         * 实例的时候重写这个方法，比如说ThreadLocal中要是存放数据库链接对象的
         * 话，就需要一个初始化方法来初始化这个数据库链接对象
         */</span>
        T value = initialValue();
        <span class="comment">/*把初始化好的值保存起来*/</span>
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>)
            map.set(<span class="keyword">this</span>, value);
        <span class="keyword">else</span>
            createMap(t, value);
        <span class="keyword">return</span> value;
}
<span class="comment">/*创建线程的ThreadLocalMap*/</span>
<span class="keyword">void</span> createMap(Thread t, T firstValue) {
        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);
}
<span class="comment">/*获取线程的ThreadLocalMap*/</span>
ThreadLocalMap getMap(Thread t) {
        <span class="keyword">return</span> t.threadLocals;
}
</pre></td></tr></table></figure>

<p>上述代码就是ThreadLocal的get源代码，先根据当前线程获取当前线程的ThreadLocalMap,此时获取到的就是一个table数组，接下来根据ThreadLocal实例的threadLocalHashCode来获取table数组中的一个元素，这个元素是个K-V的键值对，此时V就是本地存储的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">/*关于set代码和get代码是对称的*/</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>)
            map.set(<span class="keyword">this</span>, value);
        <span class="keyword">else</span>
            createMap(t, value);
}
</pre></td></tr></table></figure>

<h4 id="四-ThreadLocal源代码中提供的一个实例代码">四.ThreadLocal源代码中提供的一个实例代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueThreadIdGenerator</span> {</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger uniqueId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);  

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal &lt; Integer &gt; uniqueNum =   
            <span class="keyword">new</span> ThreadLocal &lt; Integer &gt; () {  
        <span class="comment">//定义初始值（副本）  </span>
        <span class="annotation">@Override</span> <span class="keyword">protected</span> Integer <span class="title">initialValue</span>() {  
            <span class="keyword">return</span> uniqueId.getAndIncrement();  
        }  
    };  

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCurrentThreadId</span>() {  
        <span class="comment">// 这里应该要把 uniqueId换成uniqueNum，源码应该是写错了   </span>
        <span class="keyword">return</span> uniqueNum.get();  
    }

    <span class="keyword">static</span> class MyThread extends Thread {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
            System.out.println(UniqueThreadIdGenerator.getCurrentThreadId());
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {
            <span class="keyword">new</span> MyThread().start();
        }
    }
}
</pre></td></tr></table></figure>

<p>这里总共创建了5个线程，每个线程在run方法中调用UniqueThreadIdGenerator.getCurrentThreadId()时，发现每个线程的ThreadLocalMap都是null,所以每次初始化的方法initialValue都会被调用。</p>
<h4 id="五-Thread&amp;&amp;ThreadLocal&amp;&amp;ThreadLocalMap之间的关系">五.Thread&amp;&amp;ThreadLocal&amp;&amp;ThreadLocalMap之间的关系</h4>
<p><img src="http://dl.iteye.com/upload/attachment/0084/5636/079ae373-cc30-3a5e-8890-496018582ca0.bmp" alt="图示"></p>
<h4 id="六-总结">六.总结</h4>
<p>一个线程只有一个ThreadLocalMap,其实ThreadLocalMap就是一个table数组，数组中的每个元素都是一个K-V的键值对，其中K就是ThreadLocal实例，在获取本地存储的值的时候根据ThreadLocal实例的threadLocalHashCode来对table进行Hash查找，找到对应的K-V键值对。一个线程可以有多个ThreadLocal实例，那么有多少个ThreadLocal实例就决定了table数组的大小，这个数组是动态增长的，每次要是大小不够，就自动扩充为原来大小的2倍，然后对于原来的元素重新Hash,这个操作的成本还是很大的。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ThreadLocal是JDK的一个线程本地存储的类，我们可以把一些线程私有的数据写在ThreadLocal中，这样这些数据只有一个线程可见，实现了所谓的栈封闭。这样存储一些线程私有的数据，我们就不用去费心考虑如何保证临界资源的互斥访问了，同时对于一个线程，这些私有数据也只做一次初始化。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[幂等性&&数据库的锁]]></title>
    <link href="http://yangbolin.cn/2014/10/07/idempotency-and-db-lock/"/>
    <id>http://yangbolin.cn/2014/10/07/idempotency-and-db-lock/</id>
    <published>2014-10-07T10:52:48.000Z</published>
    <updated>2014-10-07T11:31:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-幂等性">一.幂等性</h4>
<p>幂等性是高等代数中的概念，这里不是讨论数学上幂等性的概念，而是讨论程序中幂等性。幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的. 声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试.</p>
<a id="more"></a>

<p>比如系统A提供了接口f1给系统B调用，系统B调用了系统A提供的f1接口，发现超时，然后再调用一次，超时可能是由于系统A处理的有点慢导致，此时系统A会感知到接口f1的两次调用，如果f1是给用户的账户增加10000RMB的话，这样的场景可能会导致最终给用户增加了N*10000RMB(N&gt;1)，此时接口f1就需要做幂等性处理，不管这个请求重复调用多少次，最终只会给用户增加10000RMB，首先我们需要从业务层面去思考看能否解决这个问题，一般的业务都会根据业务逻辑推算出那些重复请求的，实在推算不出的话，我们就需要做额外的处理了，要求调用方调用f1的时候传递一个唯一性的请求标识进来，系统A感知到f1的调用后，会先查当前请求标识是否已经被接受，如果被接收的话，先看是处理中还是已经完成，如果是这两个状态中的任何一个，我们都认为是重复调用。要是查不到记当前请求被接受的记录的话，先插入一条当前请求被接受的记录，并且状态记录为处理中，然后再去处理请求，此时如果请求处理成功就把请求被接受的记录状态修改为处理成功，要是处理失败就把请求被接受的记录删除。如果处理成功就把当前请求被接受的记录状态修改为处理成功。</p>
<h4 id="二-数据库锁">二.数据库锁</h4>
<p>我们在写代码的时候经常会遇到这样的场景，从数据库中读取一批数据出来，然后根据一些逻辑条件修改这批数据，修改完后写回到数据库中，我们读出数据进行逻辑处理时，数据库中的这些数据可能已经发生变化了。为了保证上面数据的正确性，我们需要引入数据库的锁来解决这个问题即select for update锁，先对需要修改的记录加锁，等数据库事务提交后再把锁释放，这个过程中其他对数据的修改要先拿到这个锁才能继续做写操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> XXXTable <span class="keyword">WHERE</span> conditions <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span>
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-幂等性">一.幂等性</h4>
<p>幂等性是高等代数中的概念，这里不是讨论数学上幂等性的概念，而是讨论程序中幂等性。幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的. 声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试.</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
