<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BolinYoung's Blog]]></title>
  <subtitle><![CDATA[Believe in yourself]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yangbolin.cn/"/>
  <updated>2019-01-13T09:35:06.595Z</updated>
  <id>http://yangbolin.cn/</id>
  
  <author>
    <name><![CDATA[BolinYoung]]></name>
    <email><![CDATA[boris.yangbl@alibaba-inc.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[关于BeanCopier的使用]]></title>
    <link href="http://yangbolin.cn/2018/05/27/beancopier/"/>
    <id>http://yangbolin.cn/2018/05/27/beancopier/</id>
    <published>2018-05-27T14:31:07.000Z</published>
    <updated>2018-05-27T14:48:03.000Z</updated>
    <content type="html"><![CDATA[<p>在做业务系统开发时，我们通常分为三层，一层时对外的服务接口层，一层时内部业务逻辑层，一层是数据存储层，没层都会定义自己的类，但是这三层需要交互，交互就会涉及到数据传输，数据传输就会涉及到数据转换，因为我们每层都定义自己类来处理相关的逻辑。我们通常会把业务层的对象转换成持久层的对象再去做持久化存储，对象之间的转换我们通常使用BeanCopier来操作，但是在实际项目中发现大家使用BeanCopier的方式也不统一，有些人喜欢用Converter，有些人不喜欢用Converter，其实关于Converter我一般也不会用，都是自己先使用一把BeanCopier然后再把copy不了的字段手工填写一遍。关于BeanCopier如何使用，曾经看到有人写过下面这个Utils，代码简化了很多，避免定义很多BeanCopier。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCopierUtils</span> {</span>  
    <span class="comment">// BeanCopier的内存缓存 </span>
    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, BeanCopier&gt; beanCopierMap = <span class="keyword">new</span> HashMap&lt;String, BeanCopier&gt;();  
        
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span>(Object source,Object target){  
        String beanKey = generateKey(source.getClass(),target.getClass());  
        BeanCopier copier = <span class="keyword">null</span>;  
        <span class="keyword">if</span> (!beanCopierMap.containsKey(beanKey)) {  
            copier = BeanCopier.create(source.getClass(), target.getClass(), <span class="keyword">false</span>);  
            beanCopierMap.put(beanKey, copier);  
        }<span class="keyword">else</span> {  
            copier = beanCopierMap.get(beanKey);  
        }  
        <span class="comment">// 没有使用Converter</span>
        copier.copy(source, target, <span class="keyword">null</span>);  
    }  
    <span class="comment">// BeanCopier缓存的Key</span>
    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">generateKey</span>(Class&lt;?&gt;class1,Class&lt;?&gt;class2){  
        <span class="keyword">return</span> class1.toString() + class2.toString();  
    }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql中select for update锁的问题]]></title>
    <link href="http://yangbolin.cn/2017/12/05/select-for-update-issues/"/>
    <id>http://yangbolin.cn/2017/12/05/select-for-update-issues/</id>
    <published>2017-12-05T11:10:19.000Z</published>
    <updated>2017-12-05T11:36:35.000Z</updated>
    <content type="html"><![CDATA[<p>在日常关于资金业务的开发过程中，涉及到数据库的操作时我们经常按照一查二锁三写的套路，可能在加锁后还需要查询一些数据，因为加锁之前的数据可能已经发生变化了，这里的锁我们一般会采用数据库的select for update锁，使用这个本身也没有问题，在对数据进行操作的时候先加锁，避免其他线程修改后，当前线程看到的数据是错误的。但是在高并发的情况下面，这个select for update锁的等待时间太久导致很多线程都在等待这个锁，这样整个系统的吞吐量严重下降。举个栗子在电商业务中有个系统自动确认收货，确认收货后会更改一些用户的数据，如果同卖家在双11当天同时卖出了上万件商品，生成了上万笔订单，这上万笔订单系统自动确认收货的时间点都是一样的，到点后会爆发非常大的并发流量，如果先select for update的话，很多线程就会排队等待，系统吞吐量下降，数据库链接数耗尽，出现故障。</p>
<p>在高并发系统中，如果出现了获取不到锁的情况，应该尽快返回让上游系统发起重试，而不是一直等直到可以获取到锁，一直的等待绝对会把系统拖死，这种case目前已经经历了好多了。</p>
]]></content>
    
    
      <category term="mysql" scheme="http://yangbolin.cn/tags/mysql/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识EventSourcing和CQRS]]></title>
    <link href="http://yangbolin.cn/2017/06/25/event-sourcing-cqrs/"/>
    <id>http://yangbolin.cn/2017/06/25/event-sourcing-cqrs/</id>
    <published>2017-06-25T14:22:07.000Z</published>
    <updated>2017-06-25T14:52:39.000Z</updated>
    <content type="html"><![CDATA[<p>EventSourcing就是事件溯源的意思，我们平时在设计系统的时候都存储了对象的最终的状态，比如一个交易订单，它当前的状态是等待买家确认收货，这个状态是由于发生了一系列事件所导致的，那么EventSourcing的思想就是存储对象的所有变更事件，根据对象的所有变更事件追溯出对象的状态。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">state </span>=<span class="string"> f(E1,E2,E3....)</span>
</pre></td></tr></table></figure>

<p>函数f就是溯源函数，这种设计思想对于数据一致性也有保证，因为它对所有的变更都是insert，即追加记录，能够很好地避免RaceCondition。不同的对象可能需要定义不同的溯源函数，由于数据库中没有存储对象当前的状态，那么需要根据一些状态来进行遍历的时候就比较麻烦了。</p>
<p>CQRS是一种读写分离的架构设计，CQRS最早来自于Betrand Meyer（Eiffel语言之父，开-闭原则OCP提出者）在 Object-Oriented Software Construction 这本书中提到的一种 命令查询分离 (Command Query Separation,CQS) 的概念。其基本思想在于，任何一个对象的方法可以分为两大类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>命令(Command):不返回任何结果(<span class="keyword">void</span>)，但会改变对象的状态。
查询(Query):返回结果，但是不会改变对象的状态，对系统没有副作用。
</pre></td></tr></table></figure>

<p>先贴一张CQRS的架构图<br><img src="http://7fvbqj.com1.z0.glb.clouddn.com/CQRS.jpg" alt="CRQS"><br>一个Command只能修改一个聚合根，对同一个聚合根的修改需要通过Command Bus来排队。一个聚合根的修改可能会导致多个领域模型状态上的变更，这些状态的变更全部以事件的方式存储，事件通过EventBus找到对应的Handler，然后更新DB中的数据。其实上面这个架构可以理解为为是CQRS和EventSouring的结合。</p>
<p><a href="https://martinfowler.com/bliki/CQRS.html" target="_blank">CQRS参考资料</a></p>
]]></content>
    
    
      <category term="Architecture" scheme="http://yangbolin.cn/tags/Architecture/"/>
    
      <category term="架构设计" scheme="http://yangbolin.cn/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[两种分布式系统中保持数据一致性的设计方案]]></title>
    <link href="http://yangbolin.cn/2017/06/25/two-consistency-design-tech/"/>
    <id>http://yangbolin.cn/2017/06/25/two-consistency-design-tech/</id>
    <published>2017-06-25T09:40:13.000Z</published>
    <updated>2017-06-25T14:11:14.000Z</updated>
    <content type="html"><![CDATA[<p>CAP是分布式系统中非常重要的理论依据，任何分布式系统设计的时候都要考虑一下CAP。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function">C(一致性)</span>：所有节点上的数据时刻保持同步
<span class="function">A(可用性)</span>：每个请求都能得到一个响应，不论成功还是失败
<span class="function">P(分区容错)</span>：系统能够持续提供服务，即使系统内部有消息丢失
</pre></td></tr></table></figure>

<p>CAP只能满足两条，现在大多数业务系统都是AP without C。<br>在平时的业务开发中，业务系统A更新完自己的数据后，还需要业务系统B更新相关的数据，要么系统A发消息给系统B，系统B受到消息后更新自己的数据，要么系统A通过RPC接口更改系统B的数据。那么如何保证系统A,B的数据一致性呢？如果要强一致的话，就需要分布式事务，但是分布式事务本身有一定的开发成本，同时也会影响系统的稳定性。<br>不使用分布式事务如何来保证一致性呢？只能放弃强一致性，变成最终一致性。一般会有两种方案，一种是通过消息中间件来实现，一种是利用数据库事务加上异步轮询来处理。</p>
<p>【通过消息中间件来实现】<br><img src="http://7fvbqj.com1.z0.glb.clouddn.com/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="消息中间件"><br>这种方案需要相应的消息中间件来支持。<br>【利用数据库事务+异步轮询】<br><img src="http://7fvbqj.com1.z0.glb.clouddn.com/%E4%BA%8B%E5%8A%A1+%E8%BD%AE%E8%AF%A2.png" alt="事务轮询"><br>业务系统A更新完自己的数据后，创建一个事件，创建事件和更新自己业务数据放在一个事务里面，这样业务系统A数据更新和事件创建会一起完成，剩下的就是保证业务事件A一定要处理，要么通过RPC调用业务系统B的接口，要么发消息给业务系统B。</p>
]]></content>
    
    
      <category term="CAP" scheme="http://yangbolin.cn/tags/CAP/"/>
    
      <category term="分布式" scheme="http://yangbolin.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql中的null]]></title>
    <link href="http://yangbolin.cn/2017/06/22/mysql-null-index/"/>
    <id>http://yangbolin.cn/2017/06/22/mysql-null-index/</id>
    <published>2017-06-22T12:10:25.000Z</published>
    <updated>2017-06-22T12:18:40.000Z</updated>
    <content type="html"><![CDATA[<p>最近在优化系统代码的时候，需要修改一下表结构，增加了一个字段D，原来表中A,B,C三字段构成了唯一性约束，现在增加了D字段，D字段是可控的，没有缺省值。同时新的唯一性约束由A,B,C,D四个字段构成，上线后发现唯一性约束失效啦。<br>a1,b1,c1,null插入数据库后，a1,b1,c1,null还可以插入数据库。也就是说mysql任务[a1,b1,c1,null]和[a1,b1,c1,null]是两条记录，的确是这样，在mysql中null和null是不相等的。</p>
]]></content>
    
    
      <category term="mysql" scheme="http://yangbolin.cn/tags/mysql/"/>
    
      <category term="数据库" scheme="http://yangbolin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql相关的注意点]]></title>
    <link href="http://yangbolin.cn/2017/02/17/mysql-notice-1/"/>
    <id>http://yangbolin.cn/2017/02/17/mysql-notice-1/</id>
    <published>2017-02-17T11:20:33.000Z</published>
    <updated>2017-02-17T11:37:43.000Z</updated>
    <content type="html"><![CDATA[<p>最近一直忙于业务系统的开发，在开发过程中少不了sql语句的使用，我们在分页遍历的时候经常需要排序，就会编写如下的sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">select</span> x, y, z <span class="keyword">from</span> tableX <span class="keyword">where</span> status=#status#
<span class="keyword">order</span> <span class="keyword">by</span> apply_time
limit <span class="number">0</span>,<span class="number">100</span></span>
</pre></td></tr></table></figure>

<p>这个分页sql看上去没有什么问题，但是在执行过程中发现有数据被重复遍历出来，然后仔细排查发现上面sql中的order by apply_time是存在问题的，因为多条记录如果apply_time是一样的话，会被重复扫描到，排序字段一样，同一条记录可能会出现在不同的页中。在编写mysql分页遍历语句时，一定要注意排序字段的选择，主要重复筛选的问题。</p>
<p>现在整个业界对于分布式锁暂时还没有一些好的做法，我自己习惯使用mysql的select for update来实现锁，但是在使用select for update时，如果where语句中不带主键id的话，该sql可能会锁表，因为mysql发现where语句匹配到的记录数目比较多，对多行加锁的代价比对单表加锁的代价高，因此mysql会对表加锁。使用select for update最安全的做法是带上主键ID。如果要加锁多行，写个for循环对多条记录按照固定的顺序依次执行select for update。</p>
]]></content>
    
    
      <category term="mysql" scheme="http://yangbolin.cn/tags/mysql/"/>
    
      <category term="数据库" scheme="http://yangbolin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring的一些小事]]></title>
    <link href="http://yangbolin.cn/2016/11/12/spring-work-01/"/>
    <id>http://yangbolin.cn/2016/11/12/spring-work-01/</id>
    <published>2016-11-12T13:55:20.000Z</published>
    <updated>2016-11-12T14:14:45.000Z</updated>
    <content type="html"><![CDATA[<p>最近有同事看到下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">IA</span> {</span>
<span class="keyword">private</span> B b;
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span>(B b){}
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">IB</span> {</span>
}
</pre></td></tr></table></figure>

<p>Spring的配置文件如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
<span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>
<span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>
<span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-2.5.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>
<span class="attribute">default-autowire</span>=<span class="value">"byName"</span>&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"a"</span> <span class="attribute">class</span>=<span class="value">"A"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"b"</span> <span class="attribute">class</span>=<span class="value">"B"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<p>这样的代码在运行时a这个bean中的b能注入吗？因为setter方法的注入需要在配置文件中显示去写属性的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"a"</span> <span class="attribute">class</span>=<span class="value">"A"</span>&gt;</span>
<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"b"</span> <span class="attribute">ref</span>=<span class="value">"b"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<p>需要这样写才可以，为啥不写也可以呢？我当时也看了半天，最后发现是XML头部schema中的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">default</span>-autowire=<span class="string">"byName"</span>
</pre></td></tr></table></figure>

<p>导致。很简单一个写法，但是一般我们不会直接在XML的头部带上这个的。</p>
<p>另外最近又重温了一遍Spring的源码，发现了下面这个接口中两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableListableBeanFactory</span>
<span class="keyword">extends</span> <span class="title">ListableBeanFactory</span>, <span class="title">AutowireCapableBeanFactory</span>, <span class="title">ConfigurableBeanFactory</span> {</span>

<span class="javadoc">/**
* Ignore the given dependency type for autowiring:
* for example, String. Default is none.
*<span class="javadoctag"> @param</span> type the dependency type to ignore
*/</span>
<span class="keyword">void</span> ignoreDependencyType(Class type);

<span class="javadoc">/**
* Ignore the given dependency interface for autowiring.
* &lt;p&gt;This will typically be used by application contexts to register
* dependencies that are resolved in other ways, like BeanFactory through
* BeanFactoryAware or ApplicationContext through ApplicationContextAware.
* &lt;p&gt;By default, only the BeanFactoryAware interface is ignored.
* For further types to ignore, invoke this method for each type.
*<span class="javadoctag"> @param</span> ifc the dependency interface to ignore
*<span class="javadoctag"> @see</span> org.springframework.beans.factory.BeanFactoryAware
*<span class="javadoctag"> @see</span> org.springframework.context.ApplicationContextAware
*/</span>
<span class="keyword">void</span> ignoreDependencyInterface(Class ifc);
....
}
</pre></td></tr></table></figure>

<p>看上面的注释不是很明白，ignoreDependencyType和ignoreDependencyInterface，从方法名来看一个是忽略某些类的依赖，一个是忽略某些接口的依赖。什么意思呢？在Spring中我们经常使用的是面向接口的编程，也就是在自动注入中，如果发现接口或者类被ignoreDependency了，就不会自动注入了。比如说你不能自动注入BeanFactory和ApplicationContext，它们必须通过BeanFactoryAware和ApplicationContextAware来注入，其实直接看英文注释也非常简单。</p>
]]></content>
    
    
      <category term="Spring" scheme="http://yangbolin.cn/tags/Spring/"/>
    
      <category term="开源框架" scheme="http://yangbolin.cn/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx线上出错]]></title>
    <link href="http://yangbolin.cn/2016/10/20/nginx-error-fix/"/>
    <id>http://yangbolin.cn/2016/10/20/nginx-error-fix/</id>
    <published>2016-10-20T05:01:10.000Z</published>
    <updated>2016-10-20T05:10:41.000Z</updated>
    <content type="html"><![CDATA[<p>最近在做nginx的升级，很多网站的架构都是代理服务器(Apache/Nginx)加上应用容器(Tomcat/Jetty/Jboss)，Nginx在性能上由于Apache，在升级的过程中出现了下面的错误</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>nginx: [emerg] could not build the variables_<span class="built_in">hash</span>, you should increase either variables_<span class="built_in">hash</span>_max_size: <span class="number">512</span> or variables_<span class="built_in">hash</span>_bucket_size: <span class="number">64</span>
</pre></td></tr></table></figure>

<p>查找Nginx的文档，找到解决方案</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>http  {
    <span class="attribute">...</span><span class="attribute">...</span>
    variables_hash_max_size <span class="number">51200</span>;
    variables_hash_bucket_size <span class="number">6400</span>;
    <span class="attribute">...</span><span class="attribute">...</span>
}
</pre></td></tr></table></figure>

<p>在http的配置中增加上面两个配置即可。<br>另外，对于基础软件的升级一定要注意操作上的顺序，本次升级过程中发现之前老的一些配置都不兼容，如果操作不当很容易引发线上故障。</p>
]]></content>
    
    
      <category term="Nginx" scheme="http://yangbolin.cn/tags/Nginx/"/>
    
      <category term="线上运维" scheme="http://yangbolin.cn/categories/%E7%BA%BF%E4%B8%8A%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA单元测试mock框架]]></title>
    <link href="http://yangbolin.cn/2016/07/17/java-ut-mock-framework/"/>
    <id>http://yangbolin.cn/2016/07/17/java-ut-mock-framework/</id>
    <published>2016-07-17T02:50:10.000Z</published>
    <updated>2016-07-17T11:22:46.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做代码重构，发现系统中的UT很少，重构没有UT的话，全部得人工测试，逻辑覆盖不一定全部能覆盖到，因此UT还是很有必要存在的。在写UT的时候，mock是必须要有的，但是现在适用于java代码做单元测试的mock框架很多，我们该如何选择？</p>
<a id="more"></a>

<p>在做选择之前，我们先看看如何使用每个mock框架，再做决定。</p>
<h4 id="二-mock框架">二.mock框架</h4>
<p>为了方便描述，我们先写一个简单的测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockClazz</span> {</span>

    <span class="keyword">public</span> String <span class="title">run</span>(String name) {
        System.out.println(name);
        <span class="keyword">return</span> name + <span class="string">" begin run..."</span>;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sleep</span> (String name) {
        System.out.println(name);
        <span class="keyword">return</span> name + <span class="string">" begin sleep..."</span>;
    }

    <span class="keyword">private</span> String <span class="title">eat</span>(String name) {
        System.out.println(name);
        <span class="keyword">return</span> name + <span class="string">" begin eat..."</span>;
    }

    <span class="keyword">public</span> String <span class="title">getEatInfo</span>(String name) {
        <span class="keyword">return</span> eat(name);
    }

    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">create</span>(String name) {
        <span class="keyword">return</span> name;
    }
}
</pre></td></tr></table></figure>

<h4 id="1-easymock">1.easymock</h4>
<p>easymock是比较早的一个mock框架，做一次mock需要先创建一个mock对象，然后录制mock代码，把mock对象切换到播放状态，执行单元测试，最后再验证mock对象是否按照录制的mock行为执行。<br>引入easymock的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.easymock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>easymock<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<p>如何编写mock代码，分为五个步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// ① 创建mock对象</span>
MockClazz mockClazz = EasyMock.createMock(MockClazz.class);
<span class="comment">// ② 录制mock对象的预期行为和输出</span>
EasyMock.expect(mockClazz.run(EasyMock.anyString())).andReturn(<span class="string">"mocked string for run"</span>);
<span class="comment">// ③ 将mock对象切换到播放状态</span>
EasyMock.replay(mockClazz);
<span class="comment">// ④ 调用mock对象方法进行测试</span>
String actualString = mockClazz.run(<span class="string">"name"</span>);
Assert.assertEquals(<span class="string">"mocked string for run"</span>, actualString);
<span class="comment">// ⑤ 对mock对象的行为进行验证,验证mock的对象是否按照录制的行为发生</span>
EasyMock.verify(mockClazz);
</pre></td></tr></table></figure>

<p>这样我们就使用easymock完成了一个对象的mock测试。<br>在上面的例子中，我们只mock了run这个方法，那没有被mock的方法，在调用的时候会出现什么问题？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>String eatInfo = mockClazz.getEatInfo(<span class="string">"aa"</span>);
</pre></td></tr></table></figure>

<p>上述代码执行的时候出现下面的异常</p>
<blockquote>
<font color="red">java.lang.AssertionError:<br>  Unexpected method call MockClazz.getEatInfo(“aa”):<br>  at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:44)<br>    …..<br></font>

</blockquote>
<p>可见easymock如果其中一个方法没有被mock但是被调用了，就会抛异常。easymock不支持private,final,static等方法的mock</p>
<h4 id="2-mockito">2.mockito</h4>
<p>mockito是在easymock之后出现的，相对于easymock来说，mockito少了对象状态切换这一步骤。<br>引入mockito的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
     <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
     <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>mockito-all<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
     <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.0.2-beta<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<p>如何编写mockito的mock代码，分四个步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">// ① 创建mock对象</span>
MockClazz mockClazz = Mockito.mock(MockClazz.class);
<span class="comment">// ② 录制mock代码</span>
Mockito.when(mockClazz.run(<span class="string">"A"</span>)).thenReturn(<span class="string">"B"</span>);
<span class="comment">// ③ 执行单元测试</span>
String actual = mockClazz.run(<span class="string">"A"</span>);
Assert.assertEquals(actual,<span class="string">"B"</span>);
<span class="comment">// ④ 校验mock对象的行为是否按照mock执行</span>
Mockito.verify(mockClazz).run(<span class="string">"A"</span>);
</pre></td></tr></table></figure>

<p>和easymock相比，mockito少了一个环节，就是把对象切换到播放状态。<br>上面的代码中我们mock了run方法，但是getEatInfo方法没有被mock,调用这个方法会出现什么问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>String eatInfo = mockClazz.getEatInfo(<span class="string">"aa"</span>);
System.out.println(eatInfo);
</pre></td></tr></table></figure>

<p>此时返回null，按照mockito的官方文档，没有被mock的方法返回默认值，具体可以看mockito的官方文档。<br>那么mockito如何保证不被mock的代码按照原来的逻辑输出呢？</p>
<p><font color="red">通过doCallRealMethodl来实现</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>MockClazz mockClazz = Mockito.mock(MockClazz.class);
Mockito.doCallRealMethod().when(mockClazz).run(<span class="string">"A"</span>);
String actual = mockClazz.run(<span class="string">"A"</span>);
System.out.println(actual); <span class="comment">// A begin run... 原样执行</span>

System.out.println(mockClazz.run(<span class="string">"B"</span>)); <span class="comment">// null 返回默认值</span>
</pre></td></tr></table></figure>

<p>上面的代码显示指定了通过run(“A”)的时候调用原来的代码执行，输出A返回A begin run…</p>
<p><font color="red">通过spy来实现</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>MockClazz mockClazz = Mockito.spy(<span class="keyword">new</span> MockClazz()); <span class="comment">// 注意这里需要new一个</span>
Mockito.when(mockClazz.run(<span class="string">"A"</span>)).thenReturn(<span class="string">"B"</span>);

String actual = mockClazz.run(<span class="string">"C"</span>);
System.out.println(actual); <span class="comment">// 输出[C begin run...],原样输出忽略mock逻辑</span>
</pre></td></tr></table></figure>

<p>此时mockClazz.run(“C”)直接按照原来的代码执行，忽略mock逻辑。<br>在使用spy的时候需要注意一个点，看下面两段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>MockClazz mockClazz = Mockito.spy(<span class="keyword">new</span> MockClazz());
Mockito.when(mockClazz.run(<span class="string">"A"</span>)).thenReturn(<span class="string">"B"</span>);
System.out.println(mockClazz.run(<span class="string">"A"</span>)); <span class="comment">// 实际执行run的代码,只是修改返回值（先输出A,再返回B begin run...)</span>
</pre></td></tr></table></figure>

<p>这段代码只是修改了返回值，实际代码逻辑被执行了，也就是说这种mock逻辑只是mock了返回值，类似SpringAOP在方法返回的时候拦截一下修改了返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>MockClazz mockClazz = Mockito.spy(<span class="keyword">new</span> MockClazz());
Mockito.doReturn(<span class="string">"B"</span>).when(mockClazz).run(<span class="string">"C"</span>);
System.out.println(mockClazz.run(<span class="string">"C"</span>)); <span class="comment">// 根本不执行run的代码,直接返回</span>
</pre></td></tr></table></figure>

<p>这段代码不仅该了返回值，同时也真正的代码一行也不会执行。</p>
<blockquote>
<p>注意这两种写法的微妙区别哦<br>Mockito.doReturn(“B”).when(mockClazz).run(“C”);<br>Mockito.when(mockClazz.run(“A”)).thenReturn(“B”);</p>
</blockquote>
<p>mockito不支持private,final,static等方法的mock。</p>
<h4 id="3-powermock">3.powermock</h4>
<p>powermock实在easymock和mockito的基础上扩展而来的，easymock和mockito不能解决private,final,static等方法的mock，powermock为此提供了解决方案。powermock需要和easymock或者mockito配合起来一起使用。<br>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>powermock-api-mockito<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>powermock-module-junit4<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="annotation">@RunWith</span>(PowerMockRunner.class)
<span class="annotation">@PrepareForTest</span>( { MockClazz.class })
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockTest</span> {</span>

    <span class="annotation">@Test</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMockStatic</span>() {
        <span class="comment">// 静态方法的mock</span>
        PowerMockito.mockStatic(MockClazz.class);
        PowerMockito.when(MockClazz.sleep(<span class="string">"A"</span>)).thenReturn(<span class="string">"B"</span>);
        System.out.println(MockClazz.sleep(<span class="string">"A"</span>));
        PowerMockito.verifyStatic();
    }

    <span class="annotation">@Test</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMockPrivate</span>() <span class="keyword">throws</span>  Exception {
        <span class="comment">// 私有方法的mock,getEatInfo=&gt;eat,eat是私有方法</span>
        MockClazz mockClazz = PowerMockito.mock(MockClazz.class);
        PowerMockito.when(mockClazz, <span class="string">"eat"</span>, <span class="string">"A"</span>).thenReturn(<span class="string">"mock"</span>);
        PowerMockito.doCallRealMethod().when(mockClazz).getEatInfo(<span class="string">"A"</span>);
        System.out.println(mockClazz.getEatInfo(<span class="string">"A"</span>));
    }

    <span class="annotation">@Test</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMockFinal</span>() {
        <span class="comment">// final方法的mock</span>
        MockClazz mockClazz = PowerMockito.mock(MockClazz.class);
        PowerMockito.when(mockClazz.create(<span class="string">"A"</span>)).thenReturn(<span class="string">"B"</span>);
        System.out.println(mockClazz.create(<span class="string">"A"</span>));
    }
}
</pre></td></tr></table></figure>

<h5 id="4-jmockit">4.jmockit</h5>
<p>jmockit是一个轻量级的mock框架，内部采用ASM来修改字节码。<br>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.googlecode.jmockit<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>jmockit<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<p>具体mock的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre></td><td class="code"><pre><span class="annotation">@RunWith</span>(JMockit.class)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockTest</span> {</span>

    <span class="annotation">@Mocked</span>
    MockClazz mockClazz = <span class="keyword">new</span> MockClazz();

    <span class="annotation">@Test</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExpectations</span>() { <span class="comment">// 全局mock抛异常</span>
        <span class="keyword">new</span> Expectations() {
            {
                mockClazz.getEatInfo(<span class="string">"A"</span>);
                returns(<span class="string">"B"</span>);
            }
        };

        <span class="comment">// 被mock的方法,返回mock后的值</span>
        System.out.println(mockClazz.getEatInfo(<span class="string">"A"</span>));
        <span class="comment">// 没有被mock的方法,mockit.internal.UnexpectedInvocation,jmocit对run没有进行mock</span>
        System.out.println(mockClazz.run(<span class="string">"A"</span>));
    }

    <span class="annotation">@Test</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNonExpectations</span>() { <span class="comment">//全局mock返回缺省值</span>

        <span class="keyword">new</span> NonStrictExpectations() {
            {
                mockClazz.getEatInfo(<span class="string">"A"</span>);
                returns(<span class="string">"B"</span>);
            }
        };

        <span class="comment">// 被mock的方法,返回mock后的值</span>
        System.out.println(mockClazz.getEatInfo(<span class="string">"A"</span>));
        <span class="comment">// 没有被mock的方法,返回默认值,jmockit对run方法也进行了mock</span>
        System.out.println(mockClazz.run(<span class="string">"A"</span>));
    }

    <span class="annotation">@Test</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMockStatic</span>() {
        <span class="comment">// mock静态方法</span>
        <span class="keyword">new</span> NonStrictExpectations() {
            {
                MockClazz.sleep(<span class="string">"A"</span>);
                result = <span class="string">"B"</span>;
            }
        };
        System.out.println(MockClazz.sleep(<span class="string">"A"</span>));
    }

    <span class="annotation">@Test</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMockPrivate</span>() {
        <span class="comment">// mock静态方法</span>
        <span class="keyword">final</span> MockClazz obj = <span class="keyword">new</span> MockClazz();
        <span class="keyword">new</span> NonStrictExpectations(obj) {
            {
                <span class="comment">// 私有方法mock</span>
                <span class="keyword">this</span>.invoke(obj, <span class="string">"eat"</span>, <span class="string">"A"</span>);
                returns(<span class="string">"B"</span>);
            }
        };
        System.out.println(obj.getEatInfo(<span class="string">"A"</span>)); <span class="comment">// 私有方法被mock了</span>
        System.out.println(obj.run(<span class="string">"A"</span>)); <span class="comment">// run方法不会被mock,走真实逻辑</span>
    }
}
</pre></td></tr></table></figure>

<blockquote>
<p> 注意：<br> 1.NonStrictExpectations返回缺省值针对没有mock的方法<br> 2.Expectations针对没有mock的方法直接抛异常<br> 3.官网上的jmockito暂时不支持私有方法的mock，google提供的高版本二方库也不支持私有方法的mock</p>
</blockquote>
<p>上面例子的代码<a href="https://github.com/yangbolin/java-mock-framework" target="_blank">https://github.com/yangbolin/java-mock-framework</a></p>
<h4 id="三-总结">三.总结</h4>
<p>本文依次对比了easymock,mockito,powermock,jmockito四个java的mock框架，easymock,mockito都存在final,private,static方法没法mock的问题，powermock解决了这个问题，jmockit也没有这个问题，powermock和jmockit的区别就在于API的风格，powermock继承了easymock和mockito的风格，链式的API风格，非常清晰，jmockit有自己的API风格。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做代码重构，发现系统中的UT很少，重构没有UT的话，全部得人工测试，逻辑覆盖不一定全部能覆盖到，因此UT还是很有必要存在的。在写UT的时候，mock是必须要有的，但是现在适用于java代码做单元测试的mock框架很多，我们该如何选择？</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[枚举在hessian序列化和反序列化中的问题]]></title>
    <link href="http://yangbolin.cn/2016/05/22/enum-probolems-in-hessian/"/>
    <id>http://yangbolin.cn/2016/05/22/enum-probolems-in-hessian/</id>
    <published>2016-05-22T03:03:47.000Z</published>
    <updated>2016-05-29T10:36:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在拆分一个枚举类，但是该枚举类使用在一个RPC接口上，枚举类使用在RPC接口上，必然要考虑序列化和反序列化的问题，需要确保自己对枚举的拆分不会导致序列化和反序列化的问题。</p>
<a id="more"></a>

<p> 原来的代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> xxxEnum {
  X(<span class="string">"a11"</span>,<span class="string">"a22"</span>),
  Y(<span class="string">"a111"</span>,<span class="string">"a222"</span>); 
  <span class="keyword">private</span> String a1;
  <span class="keyword">private</span> String a2;
  <span class="keyword">public</span> String <span class="title">getA1</span>(){ <span class="keyword">return</span> a1;}
  <span class="keyword">public</span> String <span class="title">getA2</span>(){ <span class="keyword">return</span> a2;}
 }
</pre></td></tr></table></figure>

<p>修改后的代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> xxxEnum {
  X(<span class="string">"b11"</span>,<span class="string">"b22"</span>),
  Y(<span class="string">"b111"</span>,<span class="string">"b222"</span>); 
  <span class="keyword">private</span> String b1;
  <span class="keyword">private</span> String b2;
  <span class="keyword">public</span> String <span class="title">getB1</span>(){ <span class="keyword">return</span> b1;}
  <span class="keyword">public</span> String <span class="title">getB2</span>(){ <span class="keyword">return</span> b2;}
 }
</pre></td></tr></table></figure>


<p> 变更了两个成员变量的名字。这样修改反序列化会不会有问题？</p>
<h4 id="二-问题分析">二.问题分析</h4>
<p>要想知道序列化和反序列化会不会有问题，得先看看序列化和反序列化的源码，关于hessian的序列化和反序列化有很内容，这里就拿枚举这一个点来分析。</p>
<font color="#336699">先看看枚举序列化的代码</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSerializer</span> <span class="keyword">extends</span> <span class="title">AbstractSerializer</span> {</span>
    <span class="keyword">private</span> Method _name;

    <span class="keyword">public</span> <span class="title">EnumSerializer</span>(Class cl) {
        <span class="comment">// hessian/32b[12], hessian/3ab[23]</span>
        <span class="keyword">if</span> (!cl.isEnum() && cl.getSuperclass().isEnum())
            cl = cl.getSuperclass();

        <span class="keyword">try</span> {
      <span class="comment">// 通过反射来获取枚举类的name方法</span>
            _name = cl.getMethod(<span class="string">"name"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);
        } <span class="keyword">catch</span> (Exception e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
        }
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span>(Object obj, AbstractHessianOutput out) <span class="keyword">throws</span> IOException {
        <span class="keyword">if</span> (out.addRef(obj))
            <span class="keyword">return</span>;

        Class cl = obj.getClass();

        <span class="keyword">if</span> (!cl.isEnum() && cl.getSuperclass().isEnum())
            cl = cl.getSuperclass();

        String name = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
      <span class="comment">//调用枚举类的name方法来生成枚举序列化的值</span>
            name = (String) _name.invoke(obj, (Object[]) <span class="keyword">null</span>);
        } <span class="keyword">catch</span> (Exception e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
        }

        out.writeMapBegin(cl.getName());
        out.writeString(<span class="string">"name"</span>);
        out.writeString(name);
        out.writeMapEnd();
    }
}
</pre></td></tr></table></figure><br><br><font color="red">关于枚举的序列化可以总结为调用枚举类的name方法来生成序列化的字符串。</font><br><font color="#336699">再看看枚举反序列化的代码</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDeserializer</span> <span class="keyword">extends</span> <span class="title">AbstractDeserializer</span> {</span>
  <span class="keyword">private</span> Class _enumType;
  <span class="keyword">private</span> Method _valueOf;
  
  <span class="keyword">public</span> <span class="title">EnumDeserializer</span>(Class cl)
  {
    <span class="comment">// hessian/33b[34], hessian/3bb[78]</span>
    <span class="keyword">if</span> (cl.isEnum())
      _enumType = cl;
    <span class="keyword">else</span> <span class="keyword">if</span> (cl.getSuperclass().isEnum())
      _enumType = cl.getSuperclass();
    <span class="keyword">else</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Class "</span> + cl.getName() + <span class="string">" is not an enum"</span>);

    <span class="keyword">try</span> {
      <span class="comment">// 反射获取枚举类的valueOf方法</span>
      _valueOf = _enumType.getMethod(<span class="string">"valueOf"</span>,
           <span class="keyword">new</span> Class[] { Class.class, String.class });
    } <span class="keyword">catch</span> (Exception e) {
      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
    }
  }
  
  <span class="keyword">public</span> Class <span class="title">getType</span>()
  {
    <span class="keyword">return</span> _enumType;
  }
  
  <span class="keyword">public</span> Object <span class="title">readMap</span>(AbstractHessianInput in)
    <span class="keyword">throws</span> IOException
  {
    String name = <span class="keyword">null</span>;
    
    <span class="keyword">while</span> (! in.isEnd()) {
      String key = in.readString();

      <span class="keyword">if</span> (key.equals(<span class="string">"name"</span>))
        name = in.readString();
      <span class="keyword">else</span>
  in.readObject();
    }

    in.readMapEnd();

    Object obj = create(name);
    
    in.addRef(obj);

    <span class="keyword">return</span> obj;
  }
  
  <span class="annotation">@Override</span>
  <span class="keyword">public</span> Object <span class="title">readObject</span>(AbstractHessianInput in, Object []fields)
    <span class="keyword">throws</span> IOException
  {
    String []fieldNames = (String []) fields;
    String name = <span class="keyword">null</span>;

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fieldNames.length; i++) {
      <span class="keyword">if</span> (<span class="string">"name"</span>.equals(fieldNames[i]))
        name = in.readString();
      <span class="keyword">else</span>
  in.readObject();
    }

    Object obj = create(name);

    in.addRef(obj);

    <span class="keyword">return</span> obj;
  }

  <span class="keyword">private</span> Object <span class="title">create</span>(String name)
    <span class="keyword">throws</span> IOException
  {
    <span class="keyword">if</span> (name == <span class="keyword">null</span>)
      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(_enumType.getName() + <span class="string">" expects name."</span>);

    <span class="keyword">try</span> {
      <span class="comment">//反射调用枚举类的valueOf方法</span>
      <span class="keyword">return</span> _valueOf.invoke(<span class="keyword">null</span>, _enumType, name);
    } <span class="keyword">catch</span> (Exception e) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IOExceptionWrapper(e);
    }
  }
}
</pre></td></tr></table></figure><br><br><font color="red">枚举的反序列化可以总结为反射调用枚举的valueOf方法来获取最终的的枚举值。</font>

<p>有了上面对枚举序列化反序列化源码的分析，现在我们看看相关的问题。(假定服务端做的序列化，客户端做的是反序列化，方便描述)</p>
<p>1.服务端枚举多了一个枚举值<br>假如服务端的枚举类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> A {
  X,
  Y,
  Z;
}
</pre></td></tr></table></figure>

<p>客户端的枚举类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> A {
  X,
  Y;
}
</pre></td></tr></table></figure>

<p>如果服务端返回一个A.Z给客户端，此时hessian反序列化调用枚举类的valueOf方法来获取反序列化，但是客户端的枚举类中没有Z，<font color="red">那么客户端反序列化直接跑异常。</font></p>
<p>2.服务端枚举ordinal值以及枚举类成员变量值和客户端不一致<br>假设服务端的枚举类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> A {
  X(<span class="string">"aaa"</span>),
  Y(<span class="string">"bbbb"</span>);<span class="comment">//此时Y的ordinal为1，对应的value为bbb</span>
  String value;
  A(String value) {<span class="keyword">this</span>.value=value}
}
</pre></td></tr></table></figure>

<p>客户端的枚举类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> A {
  X(<span class="string">"aaa"</span>),
  Z(<span class="string">"ccc"</span>),
  Y(<span class="string">"ddd"</span>);<span class="comment">// 此时Y的ordinal为2对应的value为ddd</span>
  String value;
  A(String value) {<span class="keyword">this</span>.value=value;}
}
</pre></td></tr></table></figure>

<p><font color="red">假如入服务端传递给客户端的是A.Y，此时客户端拿到的A.Y对应的ordinal为2，对应的value为ddd。</font><br>上面这个点非常重要。<br>3.枚举是单例的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> TestEnum {
    
    XX(<span class="string">"xx"</span>);
    
    TestEnum(String value) {
        <span class="keyword">this</span>.value = value;
    }
    
    String value;

    
    <span class="keyword">public</span> String <span class="title">getValue</span>() {
        <span class="keyword">return</span> value;
    }

    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(String value) {
        <span class="keyword">this</span>.value = value;
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] rgs) {
        TestEnum testEnum1 = TestEnum.XX;
        TestEnum testEnum2 = TestEnum.XX;
        
        testEnum1.setValue(<span class="string">"XX"</span>);
        testEnum2.setValue(<span class="string">"YY"</span>);
        System.out.println(testEnum1.value); <span class="comment">// 输出 YY</span>
        System.out.println(testEnum2.value); <span class="comment">// 输出 YY</span>
    }
}
</pre></td></tr></table></figure>

<p>testEnum1和testEnum2其实指向了同一个枚举引用。每次修改的都是同一个对象，所以前一个set的值被后面的set给覆盖了。</p>
<h4 id="三-总结">三.总结</h4>
<ul>
<li>还是不要在RPC的接口中直接使用枚举类了，直接使用String就行</li>
<li>在枚举类中使用字符串时直接使用name()就行，不要再做过度封装，尽量保持枚举类的简洁</li>
<li>枚举类使用在RPC接口上的时候就一定要小心，重构的时候要注意保持ordinal</li>
<li>枚举在序列化和反序列化的时候，除了name值，其他啥都不带的</li>
<li>禁止给枚举提供set方法，没用的</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在拆分一个枚举类，但是该枚举类使用在一个RPC接口上，枚举类使用在RPC接口上，必然要考虑序列化和反序列化的问题，需要确保自己对枚举的拆分不会导致序列化和反序列化的问题。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于ArrayBlockingQueue的put和offer方法]]></title>
    <link href="http://yangbolin.cn/2016/05/15/arrayblockingqueue-put-offer/"/>
    <id>http://yangbolin.cn/2016/05/15/arrayblockingqueue-put-offer/</id>
    <published>2016-05-15T03:01:06.000Z</published>
    <updated>2016-05-15T03:20:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近线上出现了一个故障，故障的表现就是服务请响应很慢，依赖方获取不到执行结果，查看调用堆栈，发现所有的操作都阻塞在写日志的地方，这个写日志是先写日志到内存，然后再刷新到其他地方。采用了ArrayBlockingQueue，但是调用了ArrayBlockQueue的put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="javadoc">/**
 * Inserts the specified element at the tail of this queue, waiting
 * for space to become available if the queue is full.
 *
 *<span class="javadoctag"> @throws</span> InterruptedException {@inheritDoc}
 *<span class="javadoctag"> @throws</span> NullPointerException {@inheritDoc}
 */</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(E e) <span class="keyword">throws</span> InterruptedException {
    checkNotNull(e);
    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;
    lock.lockInterruptibly();
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (count == items.length)
            notFull.await();
        insert(e);
    } <span class="keyword">finally</span> {
        lock.unlock();
    }
}
</pre></td></tr></table></figure>

<p>这里的put方法会等待一个空的位置出来，然后再执行insert，但是系统的请求量非常大，此时一个请求过来后，前面的请求可能还处于等待空位置这一步，此时当前请求获取lock就等待，这样这个业务操作就一直处于获取锁获取不到的场景中了。这是一个真实出现的case，血一般的教训，当时只能不断重启机器来缓解问题。如何彻底解决这个问题，换个API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="javadoc">/**
 * Inserts the specified element at the tail of this queue, waiting
 * up to the specified wait time for space to become available if
 * the queue is full.
 *
 *<span class="javadoctag"> @throws</span> InterruptedException {@inheritDoc}
 *<span class="javadoctag"> @throws</span> NullPointerException {@inheritDoc}
 */</span>
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span>(E e, <span class="keyword">long</span> timeout, TimeUnit unit)
    <span class="keyword">throws</span> InterruptedException {

    checkNotNull(e);
    <span class="keyword">long</span> nanos = unit.toNanos(timeout);
    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;
    lock.lockInterruptibly();
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (count == items.length) {
            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)
                <span class="keyword">return</span> <span class="keyword">false</span>;
            nanos = notFull.awaitNanos(nanos);
        }
        insert(e);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    } <span class="keyword">finally</span> {
        lock.unlock();
    }
}
</pre></td></tr></table></figure>

<p>换成offer判断返回值为false的情况，不然把业务操作阻塞住。以后在高并发场景下面就不要在使用put这个API了。</p>
]]></content>
    
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于系统架构设计的心得(一)]]></title>
    <link href="http://yangbolin.cn/2016/04/17/software-design/"/>
    <id>http://yangbolin.cn/2016/04/17/software-design/</id>
    <published>2016-04-17T13:33:06.000Z</published>
    <updated>2017-06-25T14:25:04.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>关于系统的架构设计，其实有很多内容，要想设计出足够灵活的软件系统，确实不是一件容易的事情，特别是面对我们日新月异的业务，业务的变动完全可以推翻你之前所做的所有设计，如何在复杂的业务中剥离出一些固定的规律，这大概就是系统架构的主要目的了。要想做好系统架构，你需要对业务有一个宏观层面的认识和理解，需要把你所面对的业务模块化，结构化，然后再针对每个模块每个结构进行详细的设计。当然这些模块的划分以及抽象，也需要你有一定的经验。</p>
<a id="more"></a>

<p>下面从模块划分，模型，关系，以及系统交互层面写写自己在设计方面的心得体会。</p>
<h4 id="二-模块划分">二.模块划分</h4>
<p>模块的划分，是系统架构的首先要考虑的问题，我们当前的系统有那些模块，首先我们要考虑的是一个核心模块，我们需要对我们的业务作出一个高度的抽象，把一些共性的东西抽取出来，形成我们的核心系统模块，也就是我们的系统内核，基于系统内核，我们再抽象出一些个性化模块支持差异化的业务，但是核心模块在整个业务发证过程中应该保持不变，或者只需要微调就可以了。<font color=red>话虽这么说，但是达到这个目的并不是很容易，需要你有全局观才能保持内核模块的健壮和鲁棒。</font><br>其实做的好的话，你的内核模块是用来驱动你的差异化模块的，执行到某个核心的动作的时候，可以路由到具体的差异化模块中去执行。</p>
<h4 id="三-模型">三.模型</h4>
<p>模型，非常重要，一个模型的设计决定了系统的能够支持的功能，如果模型设计的非常灵活，那么系统能支持的功能也就非常多。所以在设计模型的时候要仔细斟酌，模型中的每一个字段都要思考。看看那些东西是必须的，那些东西是毫无规律的，必须的并且毫无规律的东西都需要在模型中体现出来。那些有规律的可以通过配置来解决，有些场景必须有些场景不是必须的可以通过差异化存储来解决，差异化存储就是通过一个JSON字符串来存储，这是我目前经常使用的手段，而且在很多时候都非常有效。</p>
<h4 id="四-关系">四.关系</h4>
<p>关系，也就是模型和模型之间的关系，一对多，多对多等等，模型梳理出来后，模型之间的关系其实显而易见。如果你的模型和模型之间的关系非常复杂，那就说明你梳理出来的模型是不合理的，我们之所以做设计，一个根本的目的就是把复杂的事情简单化，而不是把复杂的事情复杂化，把一个PD看来很复杂的业务做成一个开发看来很复杂的系统。</p>
<h4 id="五-系统交互">五.系统交互</h4>
<p>关于系统交互，对于外部的系统，尽量先落库再处理。<br>①先落库，马上去处理，处理完后更新数据，这个是资金操作时需要考虑的一个原则。<br>②先落库，然后异步处理，直到处理成功或者处理一定次数后挂起，这也是一个简单但是非常重要的原则，因为你可以保证自身系统的稳定性，但是你无法要求你依赖的系统和你一样稳定。<br>③重要的操作，不要直接通过消息来交互，虽然消息解耦并且异步，但是你承受不起丢消息给你带来的排查和修复所浪费的时间成本。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>关于系统的架构设计，其实有很多内容，要想设计出足够灵活的软件系统，确实不是一件容易的事情，特别是面对我们日新月异的业务，业务的变动完全可以推翻你之前所做的所有设计，如何在复杂的业务中剥离出一些固定的规律，这大概就是系统架构的主要目的了。要想做好系统架构，你需要对业务有一个宏观层面的认识和理解，需要把你所面对的业务模块化，结构化，然后再针对每个模块每个结构进行详细的设计。当然这些模块的划分以及抽象，也需要你有一定的经验。</p>
]]></summary>
    
      <category term="Architecture" scheme="http://yangbolin.cn/tags/Architecture/"/>
    
      <category term="架构设计" scheme="http://yangbolin.cn/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于YGC时间变长的记录]]></title>
    <link href="http://yangbolin.cn/2016/03/19/jvm-systemdictionary/"/>
    <id>http://yangbolin.cn/2016/03/19/jvm-systemdictionary/</id>
    <published>2016-03-19T10:01:23.000Z</published>
    <updated>2016-03-19T10:28:42.000Z</updated>
    <content type="html"><![CDATA[<p>最近看见很多同事都在讨论一个JVM YGC时间变长的问题，在平时业务开发的过程中，我们经常使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>XStream xs = <span class="keyword">new</span> XStream();
</pre></td></tr></table></figure>

<p>来实现XML和JavaBean之间的相互转换，看看实现就知道在上面的构造函数中不断创建新的classloader出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="title">XStream</span>(
            ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {
        <span class="keyword">this</span>(reflectionProvider, driver, <span class="keyword">new</span> ClassLoaderReference(<span class="keyword">new</span> CompositeClassLoader()), mapper, <span class="keyword">new</span> DefaultConverterLookup(), <span class="keyword">null</span>);
    }
</pre></td></tr></table></figure>

<p>不断创建新的classloader会导致YGC的时间变长。JVM的类加载机制都是双亲委派机制。<br>假如：AClassLoader-&gt;BClassLoader-&gt;CClassLoader，现在需要加载X这个类，AClassLoader首先会交给BClassLoader去加载，BClassLoader会交给CClassLoader去加载，如果CClassLoader能加载到，那么X这个类就被加载了。此时在SystemDictionary这个HashTable数据结构中会存储3条记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>X-AClassLoader-X.cls
X-BClassLoader-X.cls
X-CClassLoader-X.cls

此时SystemDictionary中有三条关于X的加载记录，如果发现任何一条，就认为X已经加载过了。
</pre></td></tr></table></figure>

<p>其中AClassLoader和BClassLoader叫做X的出始类加载器。CClassLoader叫做X的定义类加载器。如果不断自定义ClassLoader的话，SystemDictionary中会不断增加K-V记录，这样YGC扫描的范围就越大，YGC耗时就越多。</p>
<p>最后，在使用XStream时，最好别每次都创建一个新的ClassLoader来，减少YGC的时间，提升性能。</p>
]]></content>
    
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用xstream解析utf-8格式的字符串]]></title>
    <link href="http://yangbolin.cn/2015/11/18/xstream-skills-for-utf8/"/>
    <id>http://yangbolin.cn/2015/11/18/xstream-skills-for-utf8/</id>
    <published>2015-11-18T06:26:04.000Z</published>
    <updated>2015-11-18T07:28:52.000Z</updated>
    <content type="html"><![CDATA[<p>最近在使用xstream解析一个xml字符串时，出现了解析失败的问题，出错原因很简单，xml字符串中指定了utf-8的编码，此时我们直接构造一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>XStream xstream = <span class="keyword">new</span> XStream();
</pre></td></tr></table></figure>

<p>这样构造的话，一定会解析失败。<br>需要按照下面的方式来构造才能正确解析utf-8格式的xml字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver(<span class="string">"UTF-8"</span>));
</pre></td></tr></table></figure>

<p>xstream是一个比较方便的工具，能够实现xml和object之间的相互转换，注意在平时开发过程中的灵活使用。</p>
]]></content>
    
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac遇到的一个svn的问题]]></title>
    <link href="http://yangbolin.cn/2015/10/29/mac-svn-problem/"/>
    <id>http://yangbolin.cn/2015/10/29/mac-svn-problem/</id>
    <published>2015-10-29T05:34:37.000Z</published>
    <updated>2015-10-30T01:23:50.000Z</updated>
    <content type="html"><![CDATA[<p>今天在mac使用svn pe svn:ignore 来设置忽略文件夹时出现了下面的错误</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>svn: E205007: None of the environment variables SVN_EDITOR, VISUAL or EDITOR are <span class="operator"><span class="keyword">set</span>, <span class="keyword">and</span> <span class="keyword">no</span> <span class="string">'editor-cmd'</span> run-<span class="keyword">time</span> configuration <span class="keyword">option</span> was <span class="keyword">found</span></span>
</pre></td></tr></table></figure>

<p>解决办法，在.bash_profile中增加下面一行，然后source生效即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">export</span> SVN_EDITOR=vim
</pre></td></tr></table></figure>

<p>注意使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>svn pe svn:<span class="built_in">global</span><span class="attribute">-ignores</span> <span class="built_in">.</span>
</pre></td></tr></table></figure>

<p>进行全局设置，避免给每个目录执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">svn</span> <span class="tag">pe</span> <span class="tag">svn</span><span class="pseudo">:ignore</span> .
</pre></td></tr></table></figure>

<p>来设置</p>
]]></content>
    
    
      <category term="svn" scheme="http://yangbolin.cn/tags/svn/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓宽技术视野一]]></title>
    <link href="http://yangbolin.cn/2015/10/23/tec-accumulation-1/"/>
    <id>http://yangbolin.cn/2015/10/23/tec-accumulation-1/</id>
    <published>2015-10-23T15:55:18.000Z</published>
    <updated>2015-10-23T16:29:16.000Z</updated>
    <content type="html"><![CDATA[<p>利用空闲的时间，随便看看一些新的技术，拓宽自己的技术视野。</p>
<ul>
<li>Betamax 利用这个开源二方库能够mock一个http请求。 </li>
<li>cucumber 基于DSL来做单元测试，<a href="https://c0deattack.wordpress.com/2012/03/28/cucumber-jvm-with-cucumber-java-cucumber-junit-example/" target="_blank">具体例子</a></li>
<li>jOOR 一个简化发射调用的JAVA框架，把反射调用变成一行链式调用，这种框架貌似挺多的，<a href="https://c0deattack.wordpress.com/2012/03/28/cucumber-jvm-with-cucumber-java-cucumber-junit-example/" target="_blank">源码地址</a></li>
</ul>
]]></content>
    
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="开发杂谈" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[velocity工具函数以及InputStream到String的转换方法]]></title>
    <link href="http://yangbolin.cn/2015/10/15/velocity-utils-stream-to-string/"/>
    <id>http://yangbolin.cn/2015/10/15/velocity-utils-stream-to-string/</id>
    <published>2015-10-15T12:41:33.000Z</published>
    <updated>2015-10-19T03:03:10.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>最近在做需求的时候，需要在程序中把一个vm文件渲染成一个字符串，同时也需要把一个InputStream流转换成一个字符串，虽然说很简单，但是自己还是翻了翻以前的代码，也在网上找了相关的例子，为了下次使用的是能能够快速找到，专门记录一下。<br><a id="more"></a></p>
<h4 id="二-实现">二.实现</h4>
<h5 id="velocity渲染的工具类">velocity渲染的工具类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(VelocityUtil.class);

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">render</span>(String content, Map&lt;String, String&gt; param) {
    VelocityEngine ve = <span class="keyword">new</span> VelocityEngine();
    VelocityContext context = <span class="keyword">new</span> VelocityContext(param);
    <span class="keyword">try</span> {
    	<span class="comment">//解决velocity LOG的问题       </span>
    	ve.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, <span class="keyword">new</span> NullLogChute());
        ve.init();
        StringWriter writer = <span class="keyword">new</span> StringWriter();
        ve.evaluate(context, writer, content, content);
        <span class="keyword">return</span> writer.toString();
    } <span class="keyword">catch</span> (Exception e) {
        LOG.error(<span class="string">"velocity render exception..."</span>, e);
    }

    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</pre></td></tr></table></figure>

<h4 id="InputStream到String转换的工具类">InputStream到String转换的工具类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="javadoc">/**
 * 把流转换成字符串的工具函数
 * 
 *<span class="javadoctag"> @param</span> in
 *<span class="javadoctag"> @return</span>
 *<span class="javadoctag"> @throws</span> Exception
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">inputStreamToString</span>(InputStream in) <span class="keyword">throws</span> Exception {
    StringBuilder sb = <span class="keyword">new</span> StringBuilder();
    String line = <span class="keyword">null</span>;
    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));
    <span class="keyword">try</span> {
        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {
            sb.append(line.trim());
        }
    } <span class="keyword">catch</span> (IOException e) {
        <span class="keyword">throw</span> e;
    } <span class="keyword">finally</span> {
        <span class="keyword">try</span> {
            in.close();
        } <span class="keyword">catch</span> (IOException e) {
            <span class="keyword">throw</span> e;
        }
    }
    <span class="keyword">return</span> sb.toString();
}
</pre></td></tr></table></figure>

<p>也可以直接使用org.apache.commons.io.IOUtils这个工具函数，注意commons-io包中工具函数的使用。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>最近在做需求的时候，需要在程序中把一个vm文件渲染成一个字符串，同时也需要把一个InputStream流转换成一个字符串，虽然说很简单，但是自己还是翻了翻以前的代码，也在网上找了相关的例子，为了下次使用的是能能够快速找到，专门记录一下。<br>]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何动态修改JVM的字节码]]></title>
    <link href="http://yangbolin.cn/2015/10/13/how-to-modify-jvm-bytecode-dynamic/"/>
    <id>http://yangbolin.cn/2015/10/13/how-to-modify-jvm-bytecode-dynamic/</id>
    <published>2015-10-13T11:13:30.000Z</published>
    <updated>2015-10-13T12:51:40.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做一个需求的时候，需要在JVM启动好之后，能够动态的修改JVM已经加载的一个类的一个方法，把这个方法的返回值直接改成返回true。</p>
<a id="more"></a>

<p>上述需求概括为动态修改JVM字节码，我们需要借助修改字节码的工具，同时也要让启动中的JVM能感知到我们的修改，这个需要借助java的instrument。下面我们就来看一下具体的实现。</p>
<h4 id="二-实现">二.实现</h4>
<h5 id="1-编写修改字节码的agent">1.编写修改字节码的agent</h5>
<p>在JVM已经加载的类中找到要修改的类，然后使用javassist从磁盘上读取到要修改类的字节码，修改指定方法的返回值后，让JVM重新再加载一下我们刚才修改的这个类，具体代码如下：<br>agent的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxmockAgent</span> {</span>
    <span class="comment">// 指定我们要修改字节码的类的全限定名</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASS_NAME = <span class="string">"xxxCommonBO"</span>;
    <span class="annotation">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span>(String agentArgs, Instrumentation inst) <span class="keyword">throws</span> UnmodifiableClassException{
        System.out.println(<span class="string">"loadagent after main..."</span>);
        <span class="comment">//获取当前JVM已经加载过的所有类</span>
        Class[] classes =  inst.getAllLoadedClasses();
        <span class="keyword">for</span> (Class clazz : classes) {
	    <span class="comment">//找到需要修改的类</span>
            <span class="keyword">if</span>(clazz.getName().equals(CLASS_NAME)) {
                System.out.println(<span class="string">"find class "</span> + CLASS_NAME);
                <span class="comment">//按照要求字节吗</span>
                inst.addTransformer(<span class="keyword">new</span> XxxCommonTransformer(), <span class="keyword">true</span>);
                <span class="comment">//让JVM重新加载修改过字节码的类</span>
                inst.retransformClasses(clazz);
            }
        }
        System.out.println(<span class="string">"loadagent after main sucess..."</span>);
    }
}
</pre></td></tr></table></figure>

<p>修改字节码的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxCommonTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">transform</span>(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,
                            ProtectionDomain protectionDomain,
                            <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException {
        String compareClass = className.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);
        System.out.println(<span class="string">"transformer..."</span> + compareClass);
        <span class="keyword">try</span> {
	    <span class="comment">//构建javassist需要ClassPool</span>
            ClassPool classPool = ClassPool.getDefault();
            <span class="comment">//把要修改的类的classpath加入到javassist的ClassPool中</span>
            classPool.appendClassPath(<span class="string">"/xxx/WEB-INF/lib/*"</span>);
            <span class="comment">//从磁盘上读取要修改类的字节码，并且转换成javassit中的CtClass模型</span>
            CtClass ctClass = classPool.get(compareClass);
            <span class="comment">//获取需要修改的字节码的方法</span>
            CtMethod ctMethod = ctClass.getDeclaredMethod(<span class="string">"isFromA"</span>);
            <span class="comment">//修改方法体</span>
            ctMethod.setBody(<span class="string">"return true;"</span>);
            <span class="comment">//写入修改后的字节码</span>
            ctClass.writeFile();
            <span class="keyword">return</span> ctClass.toBytecode();
        } <span class="keyword">catch</span> (Exception e) {
	    e.printStackTrace();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</pre></td></tr></table></figure>

<h5 id="2-编写attach到JVM的client">2.编写attach到JVM的client</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="keyword">if</span> (args.length != <span class="number">2</span>) {
            System.out.println(<span class="string">"[usage:java -jar client-1.0.0.jar pid path] and args.lenght="</span>+args.length);
            <span class="keyword">return</span>;
        }
        <span class="comment">// 第0个参数是要attach的JVM进程ID</span>
        String pid = args[<span class="number">0</span>];
        <span class="comment">// 第1个参数是agent JAR包所在的路径</span>
        String agentPath =args[<span class="number">1</span>];
        System.out.println(<span class="string">"pid:"</span> + pid);
        System.out.println(<span class="string">"agentPath:"</span> + agentPath);
        <span class="keyword">try</span> {
            attach(pid, agentPath);
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach</span>(String pid, String agentPath) <span class="keyword">throws</span> Exception {
        <span class="keyword">try</span> {            
            <span class="comment">//attach到远程JVM上去</span>
            VirtualMachine  vm = VirtualMachine.attach(pid);
            <span class="comment">//加载agent</span>
            vm.loadAgent(agentPath);
        } <span class="keyword">catch</span> (RuntimeException re) {
            <span class="keyword">throw</span> re;
        } <span class="keyword">catch</span> (IOException ioexp) {
            <span class="keyword">throw</span> ioexp;
        } <span class="keyword">catch</span> (Exception exp) {
            exp.printStackTrace();
            <span class="keyword">throw</span> exp;
        }
    }
}
</pre></td></tr></table></figure>

<h4 id="三-注意点">三.注意点</h4>
<p>1.在编写agent的时候我们需要指定要修改的类所在的classpath，此时的类加载器是AppClassLoader，如果你要attach的JVM进程是用jetty&amp;&amp;tomcat等容器启动起来的，必须要指定要修改的类所在的classpath。<br>2.在agent中我们使用到javassit这个开源的操作字节码的二方库，加载javassit中类的类加载器也是AppClassLoader，同样如果你的JVM进程是用jetty或者tomcat启动的话，而且你的应用中已经包含了javassit这个二方库，AppClassLoader也加载不了，会出现ClassPool加载失败的异常，此时需要我们显式地把javassit包含到agent中去，如果你的agent是使用maven构建的话，你可以使用maven-shade-plugin这个maven插件，该插件既能把依赖的jar聚合起来，也能在jar包中自动生成MANIFEST.MF。<br>3.在编写client的时候我们用到了VirtualMachine这个类，这个类在tools.jar中，这个jar是jdk自己携带的。如果你是用maven来构建你的client的话，你可以用下面方式把tools.jar自动引入到你的project中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>					
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.sun<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
	<span class="tag">&lt;<span class="title">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
	<span class="tag">&lt;<span class="title">systemPath</span>&gt;</span>${JAVA_HOME}/lib/tools.jar<span class="tag">&lt;/<span class="title">systemPath</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<p>4.在运行client的方式，我们通过java -jar来运行，此时需要tools.jar，如果你不想把tools.jar打包的client中，你需要在运行client JAR的时候带上tools.jar.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>java -Xbootclasspath/a:tools.jar  -jar /home/xxx/client-<span class="number">1.0</span><span class="number">.0</span>.jar <span class="number">22410</span> /home/xxx/agent-<span class="number">1.0</span><span class="number">.0</span>.jar
</pre></td></tr></table></figure>

<p>22410是进程PID</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做一个需求的时候，需要在JVM启动好之后，能够动态的修改JVM已经加载的一个类的一个方法，把这个方法的返回值直接改成返回true。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[awk使用总结]]></title>
    <link href="http://yangbolin.cn/2015/09/09/awk-command/"/>
    <id>http://yangbolin.cn/2015/09/09/awk-command/</id>
    <published>2015-09-09T13:12:36.000Z</published>
    <updated>2015-09-10T02:01:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在平时工作中经常会遇到一些文本的处理，awk就是一种文本处理语言，很方便，很轻量，可以说awk也是一种编程语言。</p>
<p>awk的工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，\$0则表示所有域，\$1表示第一个域，\$n表示第n个域。默认域的分隔符是”空白键”或”tab键”。<br><a id="more"></a></p>
<h4 id="二-常用命令">二.常用命令</h4>
<h5 id="1-显示指定分隔符分隔后的第一列">1.显示指定分隔符分隔后的第一列</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">awk</span> -F <span class="string">':'</span> <span class="string">'{print <span class="variable">$1</span>}'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>-F ‘:’ 指定了awk处理行文本的分隔符号<br>{print $1}表示是action，对于文本中的没一行都要执行这个action<br>这个文本处理模式是awk+action</p>
<h5 id="2-搜索文件中包含某一关键字的行">2.搜索文件中包含某一关键字的行</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk -<span class="literal">F</span>: <span class="string">'/root/'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>这里使用的pattern，匹配了pattern的行才会执行后面的action，没有指定action默认输出正行内容。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk -<span class="literal">F</span>: <span class="string">'/^root/'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>匹配所有以root开头的行</p>
<h5 id="3-awk内置变量">3.awk内置变量</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">awk</span> -F <span class="string">':'</span> <span class="string">'{printf("filename:%s,linenumber:%s,linecontents:%s columns:%s\n",FILENAME,NR,NF,<span class="variable">$0</span>)}'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>FILENAME awk浏览的文件名<br>NR 已读出的记录数目<br>NF 浏览记录的域的个数<br>printf用于格式化输出</p>
<h5 id="4-变量和赋值">4.变量和赋值</h5>
<p>统计一个文件中的行数</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk '{count++;print $0} <span class="operator"><span class="keyword">END</span>{print <span class="string">"user count is "</span>, <span class="aggregate">count</span>}<span class="string">' /etc/passwd</span></span>
</pre></td></tr></table></figure>

<p>注意这里的count虽然没有被初始化，但是它的值是0，但是稳妥的做法还是初始化一下</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="aggregate">count</span>=<span class="number">0</span>;</span>print "[<span class="operator"><span class="keyword">start</span>]<span class="keyword">user</span> <span class="aggregate">count</span> <span class="keyword">is</span> <span class="string">", count}' {count=count+1;print $0} END {print "</span>[<span class="keyword">end</span>] <span class="keyword">user</span> <span class="aggregate">count</span> <span class="keyword">is</span> <span class="string">", count}' /etc/passwd</span></span>
</pre></td></tr></table></figure>

<p>BEGIN后面的action只有在开始的时候才会执行，END后面的语句只有结束的时候才会执行</p>
<p>统计某个文件夹下的文件占用的字节数</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ls -l | awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="keyword">size</span>=<span class="number">0</span>} {<span class="keyword">size</span>=<span class="keyword">size</span>+$<span class="number">5</span>} <span class="keyword">END</span>{print <span class="string">"[end]size is "</span>,<span class="keyword">size</span>}<span class="string">'</span></span>
</pre></td></tr></table></figure>

<p>如果以M为单位显示：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ls -l | awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="keyword">size</span>=<span class="number">0</span>} {<span class="keyword">size</span>=<span class="keyword">size</span>+$<span class="number">5</span>} <span class="keyword">END</span>{print <span class="string">"[end] size is "</span>, <span class="keyword">size</span>/<span class="number">1024</span>/<span class="number">1024</span>, <span class="string">"M"</span>}<span class="string">'</span></span>
</pre></td></tr></table></figure>

<p>这个统计命令在排查线上日志超出限制时很有用。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在平时工作中经常会遇到一些文本的处理，awk就是一种文本处理语言，很方便，很轻量，可以说awk也是一种编程语言。</p>
<p>awk的工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，\$0则表示所有域，\$1表示第一个域，\$n表示第n个域。默认域的分隔符是”空白键”或”tab键”。<br>]]></summary>
    
      <category term="awk" scheme="http://yangbolin.cn/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程艺术读书笔记一]]></title>
    <link href="http://yangbolin.cn/2015/08/02/java-concurrent-note-1/"/>
    <id>http://yangbolin.cn/2015/08/02/java-concurrent-note-1/</id>
    <published>2015-08-02T05:44:15.000Z</published>
    <updated>2015-08-09T03:47:16.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>volatile<br>轻量级的同步机制，有volatile修饰的变量在进行写操作的时候会多出一条lock前缀的指令，比如lock addl $0 x 0,(%esp)。lock前缀的指令在多核处理器下面会引发下面两件事情：①将当前处理器缓存行的数据写回到系统内存。②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。③volatile写代表锁的释放，volatile读代表锁的获取。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>synchronized<br>对于普通方法，锁是当前实例对象。对于静态方法，锁是当前类的Class对象。对于同步方法块，所示synchronized括号里面配置的对象，代码块的同步是基于monitorenter和monitorexit来实现的。</p>
</li>
<li><p>Java对象头<br>synchronized用的锁是存在JAVA对象头里面的。JAVA对象头里的Mark Word默认存储了对象的HashCode，分代年龄和锁标记。</p>
</li>
<li><p>偏向锁<br>偏向锁使用了一种等到竞争出现才释放锁的机制。它首先会暂停拥有偏向缩的线程，然后检查持有偏向缩的线程是否活着，如果线程处于不活动状态，则将对象头设置为无锁状态；如果线程仍然活着，持有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。可以通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false。</p>
</li>
<li><p>轻量级锁<br>使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁。</p>
</li>
<li><p>重量级锁<br>自旋获取锁失败，轻量级线程就会转换成重量级线程。</p>
</li>
<li><p>总线锁<br>所谓总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器请求将被阻塞住，那么该处理器可以独占共享内存。</p>
</li>
<li><p>ABA问题<br>如果一个变量的值从A变到B又变到A，此时可以通过版本来感知到这一变化，注意版本思想在实际开发工作中的灵活使用。</p>
</li>
<li><p>CAS<br>在修改一个变量值的时候先判断一下变量当前的值是否和我们期望的值一样，入股一样就修改，不一样就不修改。</p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<ul>
<li>volatile<br>轻量级的同步机制，有volatile修饰的变量在进行写操作的时候会多出一条lock前缀的指令，比如lock addl $0 x 0,(%esp)。lock前缀的指令在多核处理器下面会引发下面两件事情：①将当前处理器缓存行的数据写回到系统内存。②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。③volatile写代表锁的释放，volatile读代表锁的获取。</li>
</ul>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="并发编程" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
