<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BolinYoung's Blog]]></title>
  <subtitle><![CDATA[Believe in yourself]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yangbolin.cn/"/>
  <updated>2016-05-29T10:39:58.573Z</updated>
  <id>http://yangbolin.cn/</id>
  
  <author>
    <name><![CDATA[BolinYoung]]></name>
    <email><![CDATA[boris.yangbl@alibaba-inc.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[枚举在hessian序列化和反序列化中的问题]]></title>
    <link href="http://yangbolin.cn/2016/05/22/enum-probolems-in-hessian/"/>
    <id>http://yangbolin.cn/2016/05/22/enum-probolems-in-hessian/</id>
    <published>2016-05-22T03:03:47.000Z</published>
    <updated>2016-05-29T10:36:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在拆分一个枚举类，但是该枚举类使用在一个RPC接口上，枚举类使用在RPC接口上，必然要考虑序列化和反序列化的问题，需要确保自己对枚举的拆分不会导致序列化和反序列化的问题。</p>
<a id="more"></a>

<p> 原来的代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> xxxEnum {
  X(<span class="string">"a11"</span>,<span class="string">"a22"</span>),
  Y(<span class="string">"a111"</span>,<span class="string">"a222"</span>); 
  <span class="keyword">private</span> String a1;
  <span class="keyword">private</span> String a2;
  <span class="keyword">public</span> String <span class="title">getA1</span>(){ <span class="keyword">return</span> a1;}
  <span class="keyword">public</span> String <span class="title">getA2</span>(){ <span class="keyword">return</span> a2;}
 }
</pre></td></tr></table></figure>

<p>修改后的代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> xxxEnum {
  X(<span class="string">"b11"</span>,<span class="string">"b22"</span>),
  Y(<span class="string">"b111"</span>,<span class="string">"b222"</span>); 
  <span class="keyword">private</span> String b1;
  <span class="keyword">private</span> String b2;
  <span class="keyword">public</span> String <span class="title">getB1</span>(){ <span class="keyword">return</span> b1;}
  <span class="keyword">public</span> String <span class="title">getB2</span>(){ <span class="keyword">return</span> b2;}
 }
</pre></td></tr></table></figure>


<p> 变更了两个成员变量的名字。这样修改反序列化会不会有问题？</p>
<h4 id="二-问题分析">二.问题分析</h4>
<p>要想知道序列化和反序列化会不会有问题，得先看看序列化和反序列化的源码，关于hessian的序列化和反序列化有很内容，这里就拿枚举这一个点来分析。</p>
<font color="#336699">先看看枚举序列化的代码</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSerializer</span> <span class="keyword">extends</span> <span class="title">AbstractSerializer</span> {</span>
    <span class="keyword">private</span> Method _name;

    <span class="keyword">public</span> <span class="title">EnumSerializer</span>(Class cl) {
        <span class="comment">// hessian/32b[12], hessian/3ab[23]</span>
        <span class="keyword">if</span> (!cl.isEnum() && cl.getSuperclass().isEnum())
            cl = cl.getSuperclass();

        <span class="keyword">try</span> {
      <span class="comment">// 通过反射来获取枚举类的name方法</span>
            _name = cl.getMethod(<span class="string">"name"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);
        } <span class="keyword">catch</span> (Exception e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
        }
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span>(Object obj, AbstractHessianOutput out) <span class="keyword">throws</span> IOException {
        <span class="keyword">if</span> (out.addRef(obj))
            <span class="keyword">return</span>;

        Class cl = obj.getClass();

        <span class="keyword">if</span> (!cl.isEnum() && cl.getSuperclass().isEnum())
            cl = cl.getSuperclass();

        String name = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
      <span class="comment">//调用枚举类的name方法来生成枚举序列化的值</span>
            name = (String) _name.invoke(obj, (Object[]) <span class="keyword">null</span>);
        } <span class="keyword">catch</span> (Exception e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
        }

        out.writeMapBegin(cl.getName());
        out.writeString(<span class="string">"name"</span>);
        out.writeString(name);
        out.writeMapEnd();
    }
}
</pre></td></tr></table></figure><br><br><font color="red">关于枚举的序列化可以总结为调用枚举类的name方法来生成序列化的字符串。</font><br><font color="#336699">再看看枚举反序列化的代码</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDeserializer</span> <span class="keyword">extends</span> <span class="title">AbstractDeserializer</span> {</span>
  <span class="keyword">private</span> Class _enumType;
  <span class="keyword">private</span> Method _valueOf;
  
  <span class="keyword">public</span> <span class="title">EnumDeserializer</span>(Class cl)
  {
    <span class="comment">// hessian/33b[34], hessian/3bb[78]</span>
    <span class="keyword">if</span> (cl.isEnum())
      _enumType = cl;
    <span class="keyword">else</span> <span class="keyword">if</span> (cl.getSuperclass().isEnum())
      _enumType = cl.getSuperclass();
    <span class="keyword">else</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Class "</span> + cl.getName() + <span class="string">" is not an enum"</span>);

    <span class="keyword">try</span> {
      <span class="comment">// 反射获取枚举类的valueOf方法</span>
      _valueOf = _enumType.getMethod(<span class="string">"valueOf"</span>,
           <span class="keyword">new</span> Class[] { Class.class, String.class });
    } <span class="keyword">catch</span> (Exception e) {
      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
    }
  }
  
  <span class="keyword">public</span> Class <span class="title">getType</span>()
  {
    <span class="keyword">return</span> _enumType;
  }
  
  <span class="keyword">public</span> Object <span class="title">readMap</span>(AbstractHessianInput in)
    <span class="keyword">throws</span> IOException
  {
    String name = <span class="keyword">null</span>;
    
    <span class="keyword">while</span> (! in.isEnd()) {
      String key = in.readString();

      <span class="keyword">if</span> (key.equals(<span class="string">"name"</span>))
        name = in.readString();
      <span class="keyword">else</span>
  in.readObject();
    }

    in.readMapEnd();

    Object obj = create(name);
    
    in.addRef(obj);

    <span class="keyword">return</span> obj;
  }
  
  <span class="annotation">@Override</span>
  <span class="keyword">public</span> Object <span class="title">readObject</span>(AbstractHessianInput in, Object []fields)
    <span class="keyword">throws</span> IOException
  {
    String []fieldNames = (String []) fields;
    String name = <span class="keyword">null</span>;

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fieldNames.length; i++) {
      <span class="keyword">if</span> (<span class="string">"name"</span>.equals(fieldNames[i]))
        name = in.readString();
      <span class="keyword">else</span>
  in.readObject();
    }

    Object obj = create(name);

    in.addRef(obj);

    <span class="keyword">return</span> obj;
  }

  <span class="keyword">private</span> Object <span class="title">create</span>(String name)
    <span class="keyword">throws</span> IOException
  {
    <span class="keyword">if</span> (name == <span class="keyword">null</span>)
      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(_enumType.getName() + <span class="string">" expects name."</span>);

    <span class="keyword">try</span> {
      <span class="comment">//反射调用枚举类的valueOf方法</span>
      <span class="keyword">return</span> _valueOf.invoke(<span class="keyword">null</span>, _enumType, name);
    } <span class="keyword">catch</span> (Exception e) {
      <span class="keyword">throw</span> <span class="keyword">new</span> IOExceptionWrapper(e);
    }
  }
}
</pre></td></tr></table></figure><br><br><font color="red">枚举的反序列化可以总结为反射调用枚举的valueOf方法来获取最终的的枚举值。</font>

<p>有了上面对枚举序列化反序列化源码的分析，现在我们看看相关的问题。(假定服务端做的序列化，客户端做的是反序列化，方便描述)</p>
<p>1.服务端枚举多了一个枚举值<br>假如服务端的枚举类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> A {
  X,
  Y,
  Z;
}
</pre></td></tr></table></figure>

<p>客户端的枚举类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> A {
  X,
  Y;
}
</pre></td></tr></table></figure>

<p>如果服务端返回一个A.Z给客户端，此时hessian反序列化调用枚举类的valueOf方法来获取反序列化，但是客户端的枚举类中没有Z，<font color="red">那么客户端反序列化直接跑异常。</font></p>
<p>2.服务端枚举ordinal值以及枚举类成员变量值和客户端不一致<br>假设服务端的枚举类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> A {
  X(<span class="string">"aaa"</span>),
  Y(<span class="string">"bbbb"</span>);<span class="comment">//此时Y的ordinal为1，对应的value为bbb</span>
  String value;
  A(String value) {<span class="keyword">this</span>.value=value}
}
</pre></td></tr></table></figure>

<p>客户端的枚举类为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> A {
  X(<span class="string">"aaa"</span>),
  Z(<span class="string">"ccc"</span>),
  Y(<span class="string">"ddd"</span>);<span class="comment">// 此时Y的ordinal为2对应的value为ddd</span>
  String value;
  A(String value) {<span class="keyword">this</span>.value=value;}
}
</pre></td></tr></table></figure>

<p><font color="red">假如入服务端传递给客户端的是A.Y，此时客户端拿到的A.Y对应的ordinal为2，对应的value为ddd。</font><br>上面这个点非常重要。<br>3.枚举是单例的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> TestEnum {
    
    XX(<span class="string">"xx"</span>);
    
    TestEnum(String value) {
        <span class="keyword">this</span>.value = value;
    }
    
    String value;

    
    <span class="keyword">public</span> String <span class="title">getValue</span>() {
        <span class="keyword">return</span> value;
    }

    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(String value) {
        <span class="keyword">this</span>.value = value;
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] rgs) {
        TestEnum testEnum1 = TestEnum.XX;
        TestEnum testEnum2 = TestEnum.XX;
        
        testEnum1.setValue(<span class="string">"XX"</span>);
        testEnum2.setValue(<span class="string">"YY"</span>);
        System.out.println(testEnum1.value); <span class="comment">// 输出 YY</span>
        System.out.println(testEnum2.value); <span class="comment">// 输出 YY</span>
    }
}
</pre></td></tr></table></figure>

<p>testEnum1和testEnum2其实指向了同一个枚举引用。每次修改的都是同一个对象，所以前一个set的值被后面的set给覆盖了。</p>
<h4 id="三-总结">三.总结</h4>
<ul>
<li>还是不要在RPC的接口中直接使用枚举类了，直接使用String就行</li>
<li>在枚举类中使用字符串时直接使用name()就行，不要再做过度封装，尽量保持枚举类的简洁</li>
<li>枚举类使用在RPC接口上的时候就一定要小心，重构的时候要注意保持ordinal</li>
<li>枚举在序列化和反序列化的时候，除了name值，其他啥都不带的</li>
<li>禁止给枚举提供set方法，没用的</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在拆分一个枚举类，但是该枚举类使用在一个RPC接口上，枚举类使用在RPC接口上，必然要考虑序列化和反序列化的问题，需要确保自己对枚举的拆分不会导致序列化和反序列化的问题。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于ArrayBlockingQueue的put和offer方法]]></title>
    <link href="http://yangbolin.cn/2016/05/15/arrayblockingqueue-put-offer/"/>
    <id>http://yangbolin.cn/2016/05/15/arrayblockingqueue-put-offer/</id>
    <published>2016-05-15T03:01:06.000Z</published>
    <updated>2016-05-15T03:20:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近线上出现了一个故障，故障的表现就是服务请响应很慢，依赖方获取不到执行结果，查看调用堆栈，发现所有的操作都阻塞在写日志的地方，这个写日志是先写日志到内存，然后再刷新到其他地方。采用了ArrayBlockingQueue，但是调用了ArrayBlockQueue的put方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="javadoc">/**
 * Inserts the specified element at the tail of this queue, waiting
 * for space to become available if the queue is full.
 *
 *<span class="javadoctag"> @throws</span> InterruptedException {@inheritDoc}
 *<span class="javadoctag"> @throws</span> NullPointerException {@inheritDoc}
 */</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(E e) <span class="keyword">throws</span> InterruptedException {
    checkNotNull(e);
    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;
    lock.lockInterruptibly();
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (count == items.length)
            notFull.await();
        insert(e);
    } <span class="keyword">finally</span> {
        lock.unlock();
    }
}
</pre></td></tr></table></figure>

<p>这里的put方法会等待一个空的位置出来，然后再执行insert，但是系统的请求量非常大，此时一个请求过来后，前面的请求可能还处于等待空位置这一步，此时当前请求获取lock就等待，这样这个业务操作就一直处于获取锁获取不到的场景中了。这是一个真实出现的case，血一般的教训，当时只能不断重启机器来缓解问题。如何彻底解决这个问题，换个API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="javadoc">/**
 * Inserts the specified element at the tail of this queue, waiting
 * up to the specified wait time for space to become available if
 * the queue is full.
 *
 *<span class="javadoctag"> @throws</span> InterruptedException {@inheritDoc}
 *<span class="javadoctag"> @throws</span> NullPointerException {@inheritDoc}
 */</span>
<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span>(E e, <span class="keyword">long</span> timeout, TimeUnit unit)
    <span class="keyword">throws</span> InterruptedException {

    checkNotNull(e);
    <span class="keyword">long</span> nanos = unit.toNanos(timeout);
    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;
    lock.lockInterruptibly();
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (count == items.length) {
            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)
                <span class="keyword">return</span> <span class="keyword">false</span>;
            nanos = notFull.awaitNanos(nanos);
        }
        insert(e);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    } <span class="keyword">finally</span> {
        lock.unlock();
    }
}
</pre></td></tr></table></figure>

<p>换成offer判断返回值为false的情况，不然把业务操作阻塞住。以后在高并发场景下面就不要在使用put这个API了。</p>
]]></content>
    
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于系统架构设计的心得(一)]]></title>
    <link href="http://yangbolin.cn/2016/04/17/software-design/"/>
    <id>http://yangbolin.cn/2016/04/17/software-design/</id>
    <published>2016-04-17T13:33:06.000Z</published>
    <updated>2016-04-18T13:13:39.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>关于系统的架构设计，其实有很多内容，要想设计出足够灵活的软件系统，确实不是一件容易的事情，特别是面对我们日新月异的业务，业务的变动完全可以推翻你之前所做的所有设计，如何在复杂的业务中剥离出一些固定的规律，这大概就是系统架构的主要目的了。要想做好系统架构，你需要对业务有一个宏观层面的认识和理解，需要把你所面对的业务模块化，结构化，然后再针对每个模块每个结构进行详细的设计。当然这些模块的划分以及抽象，也需要你有一定的经验。</p>
<a id="more"></a>

<p>下面从模块划分，模型，关系，以及系统交互层面写写自己在设计方面的心得体会。</p>
<h4 id="二-模块划分">二.模块划分</h4>
<p>模块的划分，是系统架构的首先要考虑的问题，我们当前的系统有那些模块，首先我们要考虑的是一个核心模块，我们需要对我们的业务作出一个高度的抽象，把一些共性的东西抽取出来，形成我们的核心系统模块，也就是我们的系统内核，基于系统内核，我们再抽象出一些个性化模块支持差异化的业务，但是核心模块在整个业务发证过程中应该保持不变，或者只需要微调就可以了。<font color=red>话虽这么说，但是达到这个目的并不是很容易，需要你有全局观才能保持内核模块的健壮和鲁棒。</font><br>其实做的好的话，你的内核模块是用来驱动你的差异化模块的，执行到某个核心的动作的时候，可以路由到具体的差异化模块中去执行。</p>
<h4 id="三-模型">三.模型</h4>
<p>模型，非常重要，一个模型的设计决定了系统的能够支持的功能，如果模型设计的非常灵活，那么系统能支持的功能也就非常多。所以在设计模型的时候要仔细斟酌，模型中的每一个字段都要思考。看看那些东西是必须的，那些东西是毫无规律的，必须的并且毫无规律的东西都需要在模型中体现出来。那些有规律的可以通过配置来解决，有些场景必须有些场景不是必须的可以通过差异化存储来解决，差异化存储就是通过一个JSON字符串来存储，这是我目前经常使用的手段，而且在很多时候都非常有效。</p>
<h4 id="四-关系">四.关系</h4>
<p>关系，也就是模型和模型之间的关系，一对多，多对多等等，模型梳理出来后，模型之间的关系其实显而易见。如果你的模型和模型之间的关系非常复杂，那就说明你梳理出来的模型是不合理的，我们之所以做设计，一个根本的目的就是把复杂的事情简单化，而不是把复杂的事情复杂化，把一个PD看来很复杂的业务做成一个开发看来很复杂的系统。</p>
<h4 id="五-系统交互">五.系统交互</h4>
<p>关于系统交互，对于外部的系统，尽量先落库再处理。<br>①先落库，马上去处理，处理完后更新数据，这个是资金操作时需要考虑的一个原则。<br>②先落库，然后异步处理，直到处理成功或者处理一定次数后挂起，这也是一个简单但是非常重要的原则，因为你可以保证自身系统的稳定性，但是你无法要求你依赖的系统和你一样稳定。<br>③重要的操作，不要直接通过消息来交互，虽然消息解耦并且异步，但是你承受不起丢消息给你带来的排查和修复所浪费的时间成本。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>关于系统的架构设计，其实有很多内容，要想设计出足够灵活的软件系统，确实不是一件容易的事情，特别是面对我们日新月异的业务，业务的变动完全可以推翻你之前所做的所有设计，如何在复杂的业务中剥离出一些固定的规律，这大概就是系统架构的主要目的了。要想做好系统架构，你需要对业务有一个宏观层面的认识和理解，需要把你所面对的业务模块化，结构化，然后再针对每个模块每个结构进行详细的设计。当然这些模块的划分以及抽象，也需要你有一定的经验。</p>
]]></summary>
    
      <category term="架构" scheme="http://yangbolin.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="架构设计" scheme="http://yangbolin.cn/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于YGC时间变长的记录]]></title>
    <link href="http://yangbolin.cn/2016/03/19/jvm-systemdictionary/"/>
    <id>http://yangbolin.cn/2016/03/19/jvm-systemdictionary/</id>
    <published>2016-03-19T10:01:23.000Z</published>
    <updated>2016-03-19T10:28:42.000Z</updated>
    <content type="html"><![CDATA[<p>最近看见很多同事都在讨论一个JVM YGC时间变长的问题，在平时业务开发的过程中，我们经常使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>XStream xs = <span class="keyword">new</span> XStream();
</pre></td></tr></table></figure>

<p>来实现XML和JavaBean之间的相互转换，看看实现就知道在上面的构造函数中不断创建新的classloader出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="title">XStream</span>(
            ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {
        <span class="keyword">this</span>(reflectionProvider, driver, <span class="keyword">new</span> ClassLoaderReference(<span class="keyword">new</span> CompositeClassLoader()), mapper, <span class="keyword">new</span> DefaultConverterLookup(), <span class="keyword">null</span>);
    }
</pre></td></tr></table></figure>

<p>不断创建新的classloader会导致YGC的时间变长。JVM的类加载机制都是双亲委派机制。<br>假如：AClassLoader-&gt;BClassLoader-&gt;CClassLoader，现在需要加载X这个类，AClassLoader首先会交给BClassLoader去加载，BClassLoader会交给CClassLoader去加载，如果CClassLoader能加载到，那么X这个类就被加载了。此时在SystemDictionary这个HashTable数据结构中会存储3条记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>X-AClassLoader-X.cls
X-BClassLoader-X.cls
X-CClassLoader-X.cls

此时SystemDictionary中有三条关于X的加载记录，如果发现任何一条，就认为X已经加载过了。
</pre></td></tr></table></figure>

<p>其中AClassLoader和BClassLoader叫做X的出始类加载器。CClassLoader叫做X的定义类加载器。如果不断自定义ClassLoader的话，SystemDictionary中会不断增加K-V记录，这样YGC扫描的范围就越大，YGC耗时就越多。</p>
<p>最后，在使用XStream时，最好别每次都创建一个新的ClassLoader来，减少YGC的时间，提升性能。</p>
]]></content>
    
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用xstream解析utf-8格式的字符串]]></title>
    <link href="http://yangbolin.cn/2015/11/18/xstream-skills-for-utf8/"/>
    <id>http://yangbolin.cn/2015/11/18/xstream-skills-for-utf8/</id>
    <published>2015-11-18T06:26:04.000Z</published>
    <updated>2015-11-18T07:28:52.000Z</updated>
    <content type="html"><![CDATA[<p>最近在使用xstream解析一个xml字符串时，出现了解析失败的问题，出错原因很简单，xml字符串中指定了utf-8的编码，此时我们直接构造一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>XStream xstream = <span class="keyword">new</span> XStream();
</pre></td></tr></table></figure>

<p>这样构造的话，一定会解析失败。<br>需要按照下面的方式来构造才能正确解析utf-8格式的xml字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> DomDriver(<span class="string">"UTF-8"</span>));
</pre></td></tr></table></figure>

<p>xstream是一个比较方便的工具，能够实现xml和object之间的相互转换，注意在平时开发过程中的灵活使用。</p>
]]></content>
    
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac遇到的一个svn的问题]]></title>
    <link href="http://yangbolin.cn/2015/10/29/mac-svn-problem/"/>
    <id>http://yangbolin.cn/2015/10/29/mac-svn-problem/</id>
    <published>2015-10-29T05:34:37.000Z</published>
    <updated>2015-10-30T01:23:50.000Z</updated>
    <content type="html"><![CDATA[<p>今天在mac使用svn pe svn:ignore 来设置忽略文件夹时出现了下面的错误</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>svn: E205007: None of the environment variables SVN_EDITOR, VISUAL or EDITOR are <span class="operator"><span class="keyword">set</span>, <span class="keyword">and</span> <span class="keyword">no</span> <span class="string">'editor-cmd'</span> run-<span class="keyword">time</span> configuration <span class="keyword">option</span> was <span class="keyword">found</span></span>
</pre></td></tr></table></figure>

<p>解决办法，在.bash_profile中增加下面一行，然后source生效即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">export</span> SVN_EDITOR=vim
</pre></td></tr></table></figure>

<p>注意使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>svn pe svn:<span class="built_in">global</span><span class="attribute">-ignores</span> <span class="built_in">.</span>
</pre></td></tr></table></figure>

<p>进行全局设置，避免给每个目录执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">svn</span> <span class="tag">pe</span> <span class="tag">svn</span><span class="pseudo">:ignore</span> .
</pre></td></tr></table></figure>

<p>来设置</p>
]]></content>
    
    
      <category term="svn" scheme="http://yangbolin.cn/tags/svn/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓宽技术视野一]]></title>
    <link href="http://yangbolin.cn/2015/10/23/tec-accumulation-1/"/>
    <id>http://yangbolin.cn/2015/10/23/tec-accumulation-1/</id>
    <published>2015-10-23T15:55:18.000Z</published>
    <updated>2015-10-23T16:29:16.000Z</updated>
    <content type="html"><![CDATA[<p>利用空闲的时间，随便看看一些新的技术，拓宽自己的技术视野。</p>
<ul>
<li>Betamax 利用这个开源二方库能够mock一个http请求。 </li>
<li>cucumber 基于DSL来做单元测试，<a href="https://c0deattack.wordpress.com/2012/03/28/cucumber-jvm-with-cucumber-java-cucumber-junit-example/" target="_blank">具体例子</a></li>
<li>jOOR 一个简化发射调用的JAVA框架，把反射调用变成一行链式调用，这种框架貌似挺多的，<a href="https://c0deattack.wordpress.com/2012/03/28/cucumber-jvm-with-cucumber-java-cucumber-junit-example/" target="_blank">源码地址</a></li>
</ul>
]]></content>
    
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="开发杂谈" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[velocity工具函数以及InputStream到String的转换方法]]></title>
    <link href="http://yangbolin.cn/2015/10/15/velocity-utils-stream-to-string/"/>
    <id>http://yangbolin.cn/2015/10/15/velocity-utils-stream-to-string/</id>
    <published>2015-10-15T12:41:33.000Z</published>
    <updated>2015-10-19T03:03:10.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>最近在做需求的时候，需要在程序中把一个vm文件渲染成一个字符串，同时也需要把一个InputStream流转换成一个字符串，虽然说很简单，但是自己还是翻了翻以前的代码，也在网上找了相关的例子，为了下次使用的是能能够快速找到，专门记录一下。<br><a id="more"></a></p>
<h4 id="二-实现">二.实现</h4>
<h5 id="velocity渲染的工具类">velocity渲染的工具类</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(VelocityUtil.class);

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">render</span>(String content, Map&lt;String, String&gt; param) {
    VelocityEngine ve = <span class="keyword">new</span> VelocityEngine();
    VelocityContext context = <span class="keyword">new</span> VelocityContext(param);
    <span class="keyword">try</span> {
    	<span class="comment">//解决velocity LOG的问题       </span>
    	ve.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, <span class="keyword">new</span> NullLogChute());
        ve.init();
        StringWriter writer = <span class="keyword">new</span> StringWriter();
        ve.evaluate(context, writer, content, content);
        <span class="keyword">return</span> writer.toString();
    } <span class="keyword">catch</span> (Exception e) {
        LOG.error(<span class="string">"velocity render exception..."</span>, e);
    }

    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</pre></td></tr></table></figure>

<h4 id="InputStream到String转换的工具类">InputStream到String转换的工具类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="javadoc">/**
 * 把流转换成字符串的工具函数
 * 
 *<span class="javadoctag"> @param</span> in
 *<span class="javadoctag"> @return</span>
 *<span class="javadoctag"> @throws</span> Exception
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">inputStreamToString</span>(InputStream in) <span class="keyword">throws</span> Exception {
    StringBuilder sb = <span class="keyword">new</span> StringBuilder();
    String line = <span class="keyword">null</span>;
    BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));
    <span class="keyword">try</span> {
        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) {
            sb.append(line.trim());
        }
    } <span class="keyword">catch</span> (IOException e) {
        <span class="keyword">throw</span> e;
    } <span class="keyword">finally</span> {
        <span class="keyword">try</span> {
            in.close();
        } <span class="keyword">catch</span> (IOException e) {
            <span class="keyword">throw</span> e;
        }
    }
    <span class="keyword">return</span> sb.toString();
}
</pre></td></tr></table></figure>

<p>也可以直接使用org.apache.commons.io.IOUtils这个工具函数，注意commons-io包中工具函数的使用。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>最近在做需求的时候，需要在程序中把一个vm文件渲染成一个字符串，同时也需要把一个InputStream流转换成一个字符串，虽然说很简单，但是自己还是翻了翻以前的代码，也在网上找了相关的例子，为了下次使用的是能能够快速找到，专门记录一下。<br>]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何动态修改JVM的字节码]]></title>
    <link href="http://yangbolin.cn/2015/10/13/how-to-modify-jvm-bytecode-dynamic/"/>
    <id>http://yangbolin.cn/2015/10/13/how-to-modify-jvm-bytecode-dynamic/</id>
    <published>2015-10-13T11:13:30.000Z</published>
    <updated>2015-10-13T12:51:40.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做一个需求的时候，需要在JVM启动好之后，能够动态的修改JVM已经加载的一个类的一个方法，把这个方法的返回值直接改成返回true。</p>
<a id="more"></a>

<p>上述需求概括为动态修改JVM字节码，我们需要借助修改字节码的工具，同时也要让启动中的JVM能感知到我们的修改，这个需要借助java的instrument。下面我们就来看一下具体的实现。</p>
<h4 id="二-实现">二.实现</h4>
<h5 id="1-编写修改字节码的agent">1.编写修改字节码的agent</h5>
<p>在JVM已经加载的类中找到要修改的类，然后使用javassist从磁盘上读取到要修改类的字节码，修改指定方法的返回值后，让JVM重新再加载一下我们刚才修改的这个类，具体代码如下：<br>agent的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxmockAgent</span> {</span>
    <span class="comment">// 指定我们要修改字节码的类的全限定名</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASS_NAME = <span class="string">"xxxCommonBO"</span>;
    <span class="annotation">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span>(String agentArgs, Instrumentation inst) <span class="keyword">throws</span> UnmodifiableClassException{
        System.out.println(<span class="string">"loadagent after main..."</span>);
        <span class="comment">//获取当前JVM已经加载过的所有类</span>
        Class[] classes =  inst.getAllLoadedClasses();
        <span class="keyword">for</span> (Class clazz : classes) {
	    <span class="comment">//找到需要修改的类</span>
            <span class="keyword">if</span>(clazz.getName().equals(CLASS_NAME)) {
                System.out.println(<span class="string">"find class "</span> + CLASS_NAME);
                <span class="comment">//按照要求字节吗</span>
                inst.addTransformer(<span class="keyword">new</span> XxxCommonTransformer(), <span class="keyword">true</span>);
                <span class="comment">//让JVM重新加载修改过字节码的类</span>
                inst.retransformClasses(clazz);
            }
        }
        System.out.println(<span class="string">"loadagent after main sucess..."</span>);
    }
}
</pre></td></tr></table></figure>

<p>修改字节码的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxCommonTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">transform</span>(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,
                            ProtectionDomain protectionDomain,
                            <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException {
        String compareClass = className.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);
        System.out.println(<span class="string">"transformer..."</span> + compareClass);
        <span class="keyword">try</span> {
	    <span class="comment">//构建javassist需要ClassPool</span>
            ClassPool classPool = ClassPool.getDefault();
            <span class="comment">//把要修改的类的classpath加入到javassist的ClassPool中</span>
            classPool.appendClassPath(<span class="string">"/xxx/WEB-INF/lib/*"</span>);
            <span class="comment">//从磁盘上读取要修改类的字节码，并且转换成javassit中的CtClass模型</span>
            CtClass ctClass = classPool.get(compareClass);
            <span class="comment">//获取需要修改的字节码的方法</span>
            CtMethod ctMethod = ctClass.getDeclaredMethod(<span class="string">"isFromA"</span>);
            <span class="comment">//修改方法体</span>
            ctMethod.setBody(<span class="string">"return true;"</span>);
            <span class="comment">//写入修改后的字节码</span>
            ctClass.writeFile();
            <span class="keyword">return</span> ctClass.toBytecode();
        } <span class="keyword">catch</span> (Exception e) {
	    e.printStackTrace();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</pre></td></tr></table></figure>

<h5 id="2-编写attach到JVM的client">2.编写attach到JVM的client</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="keyword">if</span> (args.length != <span class="number">2</span>) {
            System.out.println(<span class="string">"[usage:java -jar client-1.0.0.jar pid path] and args.lenght="</span>+args.length);
            <span class="keyword">return</span>;
        }
        <span class="comment">// 第0个参数是要attach的JVM进程ID</span>
        String pid = args[<span class="number">0</span>];
        <span class="comment">// 第1个参数是agent JAR包所在的路径</span>
        String agentPath =args[<span class="number">1</span>];
        System.out.println(<span class="string">"pid:"</span> + pid);
        System.out.println(<span class="string">"agentPath:"</span> + agentPath);
        <span class="keyword">try</span> {
            attach(pid, agentPath);
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attach</span>(String pid, String agentPath) <span class="keyword">throws</span> Exception {
        <span class="keyword">try</span> {            
            <span class="comment">//attach到远程JVM上去</span>
            VirtualMachine  vm = VirtualMachine.attach(pid);
            <span class="comment">//加载agent</span>
            vm.loadAgent(agentPath);
        } <span class="keyword">catch</span> (RuntimeException re) {
            <span class="keyword">throw</span> re;
        } <span class="keyword">catch</span> (IOException ioexp) {
            <span class="keyword">throw</span> ioexp;
        } <span class="keyword">catch</span> (Exception exp) {
            exp.printStackTrace();
            <span class="keyword">throw</span> exp;
        }
    }
}
</pre></td></tr></table></figure>

<h4 id="三-注意点">三.注意点</h4>
<p>1.在编写agent的时候我们需要指定要修改的类所在的classpath，此时的类加载器是AppClassLoader，如果你要attach的JVM进程是用jetty&amp;&amp;tomcat等容器启动起来的，必须要指定要修改的类所在的classpath。<br>2.在agent中我们使用到javassit这个开源的操作字节码的二方库，加载javassit中类的类加载器也是AppClassLoader，同样如果你的JVM进程是用jetty或者tomcat启动的话，而且你的应用中已经包含了javassit这个二方库，AppClassLoader也加载不了，会出现ClassPool加载失败的异常，此时需要我们显式地把javassit包含到agent中去，如果你的agent是使用maven构建的话，你可以使用maven-shade-plugin这个maven插件，该插件既能把依赖的jar聚合起来，也能在jar包中自动生成MANIFEST.MF。<br>3.在编写client的时候我们用到了VirtualMachine这个类，这个类在tools.jar中，这个jar是jdk自己携带的。如果你是用maven来构建你的client的话，你可以用下面方式把tools.jar自动引入到你的project中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>					
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.sun<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>tools<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
	<span class="tag">&lt;<span class="title">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
	<span class="tag">&lt;<span class="title">systemPath</span>&gt;</span>${JAVA_HOME}/lib/tools.jar<span class="tag">&lt;/<span class="title">systemPath</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<p>4.在运行client的方式，我们通过java -jar来运行，此时需要tools.jar，如果你不想把tools.jar打包的client中，你需要在运行client JAR的时候带上tools.jar.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>java -Xbootclasspath/a:tools.jar  -jar /home/xxx/client-<span class="number">1.0</span><span class="number">.0</span>.jar <span class="number">22410</span> /home/xxx/agent-<span class="number">1.0</span><span class="number">.0</span>.jar
</pre></td></tr></table></figure>

<p>22410是进程PID</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做一个需求的时候，需要在JVM启动好之后，能够动态的修改JVM已经加载的一个类的一个方法，把这个方法的返回值直接改成返回true。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[awk使用总结]]></title>
    <link href="http://yangbolin.cn/2015/09/09/awk-command/"/>
    <id>http://yangbolin.cn/2015/09/09/awk-command/</id>
    <published>2015-09-09T13:12:36.000Z</published>
    <updated>2015-09-10T02:01:58.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在平时工作中经常会遇到一些文本的处理，awk就是一种文本处理语言，很方便，很轻量，可以说awk也是一种编程语言。</p>
<p>awk的工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，\$0则表示所有域，\$1表示第一个域，\$n表示第n个域。默认域的分隔符是”空白键”或”tab键”。<br><a id="more"></a></p>
<h4 id="二-常用命令">二.常用命令</h4>
<h5 id="1-显示指定分隔符分隔后的第一列">1.显示指定分隔符分隔后的第一列</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">awk</span> -F <span class="string">':'</span> <span class="string">'{print <span class="variable">$1</span>}'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>-F ‘:’ 指定了awk处理行文本的分隔符号<br>{print $1}表示是action，对于文本中的没一行都要执行这个action<br>这个文本处理模式是awk+action</p>
<h5 id="2-搜索文件中包含某一关键字的行">2.搜索文件中包含某一关键字的行</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk -<span class="literal">F</span>: <span class="string">'/root/'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>这里使用的pattern，匹配了pattern的行才会执行后面的action，没有指定action默认输出正行内容。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk -<span class="literal">F</span>: <span class="string">'/^root/'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>匹配所有以root开头的行</p>
<h5 id="3-awk内置变量">3.awk内置变量</h5>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">awk</span> -F <span class="string">':'</span> <span class="string">'{printf("filename:%s,linenumber:%s,linecontents:%s columns:%s\n",FILENAME,NR,NF,<span class="variable">$0</span>)}'</span> /etc/passwd
</pre></td></tr></table></figure>

<p>FILENAME awk浏览的文件名<br>NR 已读出的记录数目<br>NF 浏览记录的域的个数<br>printf用于格式化输出</p>
<h5 id="4-变量和赋值">4.变量和赋值</h5>
<p>统计一个文件中的行数</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk '{count++;print $0} <span class="operator"><span class="keyword">END</span>{print <span class="string">"user count is "</span>, <span class="aggregate">count</span>}<span class="string">' /etc/passwd</span></span>
</pre></td></tr></table></figure>

<p>注意这里的count虽然没有被初始化，但是它的值是0，但是稳妥的做法还是初始化一下</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="aggregate">count</span>=<span class="number">0</span>;</span>print "[<span class="operator"><span class="keyword">start</span>]<span class="keyword">user</span> <span class="aggregate">count</span> <span class="keyword">is</span> <span class="string">", count}' {count=count+1;print $0} END {print "</span>[<span class="keyword">end</span>] <span class="keyword">user</span> <span class="aggregate">count</span> <span class="keyword">is</span> <span class="string">", count}' /etc/passwd</span></span>
</pre></td></tr></table></figure>

<p>BEGIN后面的action只有在开始的时候才会执行，END后面的语句只有结束的时候才会执行</p>
<p>统计某个文件夹下的文件占用的字节数</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ls -l | awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="keyword">size</span>=<span class="number">0</span>} {<span class="keyword">size</span>=<span class="keyword">size</span>+$<span class="number">5</span>} <span class="keyword">END</span>{print <span class="string">"[end]size is "</span>,<span class="keyword">size</span>}<span class="string">'</span></span>
</pre></td></tr></table></figure>

<p>如果以M为单位显示：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ls -l | awk '<span class="operator"><span class="keyword">BEGIN</span> {<span class="keyword">size</span>=<span class="number">0</span>} {<span class="keyword">size</span>=<span class="keyword">size</span>+$<span class="number">5</span>} <span class="keyword">END</span>{print <span class="string">"[end] size is "</span>, <span class="keyword">size</span>/<span class="number">1024</span>/<span class="number">1024</span>, <span class="string">"M"</span>}<span class="string">'</span></span>
</pre></td></tr></table></figure>

<p>这个统计命令在排查线上日志超出限制时很有用。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在平时工作中经常会遇到一些文本的处理，awk就是一种文本处理语言，很方便，很轻量，可以说awk也是一种编程语言。</p>
<p>awk的工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，\$0则表示所有域，\$1表示第一个域，\$n表示第n个域。默认域的分隔符是”空白键”或”tab键”。<br>]]></summary>
    
      <category term="awk" scheme="http://yangbolin.cn/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java并发编程艺术读书笔记一]]></title>
    <link href="http://yangbolin.cn/2015/08/02/java-concurrent-note-1/"/>
    <id>http://yangbolin.cn/2015/08/02/java-concurrent-note-1/</id>
    <published>2015-08-02T05:44:15.000Z</published>
    <updated>2015-08-09T03:47:16.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>volatile<br>轻量级的同步机制，有volatile修饰的变量在进行写操作的时候会多出一条lock前缀的指令，比如lock addl $0 x 0,(%esp)。lock前缀的指令在多核处理器下面会引发下面两件事情：①将当前处理器缓存行的数据写回到系统内存。②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。③volatile写代表锁的释放，volatile读代表锁的获取。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>synchronized<br>对于普通方法，锁是当前实例对象。对于静态方法，锁是当前类的Class对象。对于同步方法块，所示synchronized括号里面配置的对象，代码块的同步是基于monitorenter和monitorexit来实现的。</p>
</li>
<li><p>Java对象头<br>synchronized用的锁是存在JAVA对象头里面的。JAVA对象头里的Mark Word默认存储了对象的HashCode，分代年龄和锁标记。</p>
</li>
<li><p>偏向锁<br>偏向锁使用了一种等到竞争出现才释放锁的机制。它首先会暂停拥有偏向缩的线程，然后检查持有偏向缩的线程是否活着，如果线程处于不活动状态，则将对象头设置为无锁状态；如果线程仍然活着，持有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。可以通过JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false。</p>
</li>
<li><p>轻量级锁<br>使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁。</p>
</li>
<li><p>重量级锁<br>自旋获取锁失败，轻量级线程就会转换成重量级线程。</p>
</li>
<li><p>总线锁<br>所谓总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器请求将被阻塞住，那么该处理器可以独占共享内存。</p>
</li>
<li><p>ABA问题<br>如果一个变量的值从A变到B又变到A，此时可以通过版本来感知到这一变化，注意版本思想在实际开发工作中的灵活使用。</p>
</li>
<li><p>CAS<br>在修改一个变量值的时候先判断一下变量当前的值是否和我们期望的值一样，入股一样就修改，不一样就不修改。</p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<ul>
<li>volatile<br>轻量级的同步机制，有volatile修饰的变量在进行写操作的时候会多出一条lock前缀的指令，比如lock addl $0 x 0,(%esp)。lock前缀的指令在多核处理器下面会引发下面两件事情：①将当前处理器缓存行的数据写回到系统内存。②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。③volatile写代表锁的释放，volatile读代表锁的获取。</li>
</ul>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="并发编程" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用svn merge命令来回滚代码]]></title>
    <link href="http://yangbolin.cn/2015/07/02/svn-merge-revert/"/>
    <id>http://yangbolin.cn/2015/07/02/svn-merge-revert/</id>
    <published>2015-07-02T01:18:16.000Z</published>
    <updated>2015-07-02T01:32:54.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-问题">一.问题</h4>
<p>我们经常使用svn来托管代码，svn ci就能把代码提交到svn服务器上，当我们误操作使用了svn ci后，此时想回滚怎么办？如果把本地代码回到执行svn ci之前的状态？</p>
<a id="more"></a>

<h4 id="二-解决方案">二.解决方案</h4>
<ul>
<li>1.svn up<br>查看提交后的版本，假设为M</li>
<li>2.svn log —stop-on-copy<br>查看svn提交的日志，选择要回滚到那个版本，假设为N</li>
<li>3.svn diff -r M:N<br>查看从版本M到版本N发生了那些变化</li>
<li>4.svn merge -rM:N svn-branch<br>从版本M回滚到版本N svn-branch就是当前svn的分支URL</li>
<li>5.修改好本地文件后再次提交</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-问题">一.问题</h4>
<p>我们经常使用svn来托管代码，svn ci就能把代码提交到svn服务器上，当我们误操作使用了svn ci后，此时想回滚怎么办？如果把本地代码回到执行svn ci之前的状态？</p>
]]></summary>
    
      <category term="svn" scheme="http://yangbolin.cn/tags/svn/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA反射调用总结]]></title>
    <link href="http://yangbolin.cn/2015/06/08/java-reflect/"/>
    <id>http://yangbolin.cn/2015/06/08/java-reflect/</id>
    <published>2015-06-08T14:48:54.000Z</published>
    <updated>2015-06-08T15:15:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>这几天一直在忙于一个框架的开发，我们的初衷是基于配置产出业务数据，不要让开发工程师去编写JAVA代码来产出账单，一开始觉得这件事情很难，很难做到不开发JAVA代码，事实确实如此，不过数据如果规整的话，基于配置完全可以，一行java代码都不用写。当然这个框架目前还在测试中，核心功能已经开发结束了，开发一个框架和开发一个业务功能要考虑的事情完全不一样，在开发框架之前，需要把所有可能出现的需求都要考虑一下，其实框架就是高度的抽象，我们把平时所做的一些功能逻辑梳理清楚，再上一个高度就能梳理出一个框架。在开发这个框架的过程中用到了反射，感觉JDK的反射写起来代码有点多，于是考虑用Spring框架提供反射工具类，还有木有其他处理反射调用框架或者工具呢？</p>
<a id="more"></a>

<h4 id="二-概述">二.概述</h4>
<h5 id="1-利用JDK本身的API来实现反射">1.利用JDK本身的API来实现反射</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>Object oo = <span class="keyword">new</span> InnerObject();
Method[] methods = oo.getClass().getDeclaredMethods();
<span class="keyword">for</span> (Method method : methods) {
    <span class="keyword">if</span> (method.getName().equals(<span class="string">"test"</span>)) {
        <span class="keyword">try</span> {
            Object retValue = method.invoke(oo, <span class="keyword">null</span>);
        } <span class="keyword">catch</span> (IllegalArgumentException e) {
            e.printStackTrace();
        } <span class="keyword">catch</span> (IllegalAccessException e) {
            e.printStackTrace();
        } <span class="keyword">catch</span> (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
}
</pre></td></tr></table></figure>

<p>一个反射调用要写这么多代码，我也是醉了。。。。</p>
<h5 id="2-利用Spring的工具类来实现反射">2.利用Spring的工具类来实现反射</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>Method method = ReflectionUtils.findMethod(oo.getClass(), <span class="string">"test"</span>, <span class="keyword">null</span>);
<span class="keyword">try</span> {
    Object retValue = method.invoke(oo, <span class="keyword">null</span>);
} <span class="keyword">catch</span> (IllegalArgumentException e) {
    e.printStackTrace();
} <span class="keyword">catch</span> (IllegalAccessException e) {
    e.printStackTrace();
} <span class="keyword">catch</span> (InvocationTargetException e) {
    e.printStackTrace();
}
</pre></td></tr></table></figure>

<p>虽然木有了for循环，但是代码还是有些多，不够精简。</p>
<h5 id="3-利用Mirror来做反射">3.利用Mirror来做反射</h5>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
 	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>net.vidageek<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
 	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>mirror<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
 	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Object oo = <span class="keyword">new</span> InnerObject();
Object retValue = <span class="keyword">new</span> Mirror().on(oo).invoke().method(<span class="string">"test1"</span>).withoutArgs();
</pre></td></tr></table></figure>

<p>看看mirror是不是精简了很多呢？还是函数编程思想，这种写法在JDK8中会非常普遍。这里只是举例说明了一下方法调用，其他更多反射调用参考 <a href="http://projetos.vidageek.net/mirror/mirror/" target="_blank">mirror</a></p>
<h4 id="三-总结">三.总结</h4>
<p>对于一个点，多思考，寻求最简单的写法，你会有更多的收获。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>这几天一直在忙于一个框架的开发，我们的初衷是基于配置产出业务数据，不要让开发工程师去编写JAVA代码来产出账单，一开始觉得这件事情很难，很难做到不开发JAVA代码，事实确实如此，不过数据如果规整的话，基于配置完全可以，一行java代码都不用写。当然这个框架目前还在测试中，核心功能已经开发结束了，开发一个框架和开发一个业务功能要考虑的事情完全不一样，在开发框架之前，需要把所有可能出现的需求都要考虑一下，其实框架就是高度的抽象，我们把平时所做的一些功能逻辑梳理清楚，再上一个高度就能梳理出一个框架。在开发这个框架的过程中用到了反射，感觉JDK的反射写起来代码有点多，于是考虑用Spring框架提供反射工具类，还有木有其他处理反射调用框架或者工具呢？</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[操作系统定时调度]]></title>
    <link href="http://yangbolin.cn/2015/05/18/os-timer-call/"/>
    <id>http://yangbolin.cn/2015/05/18/os-timer-call/</id>
    <published>2015-05-18T12:13:29.000Z</published>
    <updated>2015-05-19T00:58:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近需要开发一些定时任务，提到定时任务，我们都会想到quartz，为了让我们的定时任务能够更加灵活的被控制，我们通过shell脚本去执行一个java类，然后定时去执行这个shell脚本即可。如何去定时执行这个shell脚本，我们想到Linux本身提供后台进程去定时执行一些命令，那就是crontab，因此我们编写好自己的shell脚本再写好crontab后就能定时执行我们的任务了。</p>
<a id="more"></a>

<h4 id="二-如何配置">二.如何配置</h4>
<ul>
<li>查看crontab的配置<br>crontab -l</li>
<li>编辑crontab的配置<br>crontab -e</li>
<li><p>crontab的格式说明<br><img src="http://bolinyoung.qiniudn.com/crontab.jpg" alt="crontab格式说明"></p>
</li>
<li><p>less  /var/log/cron<br>查看crontab运行时的日志</p>
</li>
</ul>
<h4 id="三-注意点">三.注意点</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="bullet">* </span>6 <span class="bullet">* *</span> * sh xx.sh
</pre></td></tr></table></figure>

<p>表示每天凌晨6点开始没分钟执行一次sh xx.sh脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>0 6 <span class="bullet">* *</span> * sh xx.sh
</pre></td></tr></table></figure>

<p>表示每天凌晨6点开始执行一次sh xx.sh脚本，只执行一次</p>
<p>注意上面这两个频率的区别，排查问题的时候注意考虑那些一直被忽略的点，有可能那些点就是解决问题的关键之所在。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近需要开发一些定时任务，提到定时任务，我们都会想到quartz，为了让我们的定时任务能够更加灵活的被控制，我们通过shell脚本去执行一个java类，然后定时去执行这个shell脚本即可。如何去定时执行这个shell脚本，我们想到Linux本身提供后台进程去定时执行一些命令，那就是crontab，因此我们编写好自己的shell脚本再写好crontab后就能定时执行我们的任务了。</p>
]]></summary>
    
      <category term="crontab" scheme="http://yangbolin.cn/tags/crontab/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[css换行]]></title>
    <link href="http://yangbolin.cn/2015/05/07/css-break-line/"/>
    <id>http://yangbolin.cn/2015/05/07/css-break-line/</id>
    <published>2015-05-07T13:55:59.000Z</published>
    <updated>2015-05-08T01:22:36.000Z</updated>
    <content type="html"><![CDATA[<p>最近在搞一个后台系统的时候，发现table表格的宽度没法调整，找前端大神看了一下，发现是table表格中的全英文内容过长，不会自动换行导致。因此需要用CSS来实现换行，浏览器默认不会对英文内容进行换行的。具体CSS的写法如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">word-break</span>: <span class="tag">break-all</span>;
<span class="tag">word-wrap</span>: <span class="tag">break-word</span>;
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="CSS" scheme="http://yangbolin.cn/tags/CSS/"/>
    
      <category term="前端开发" scheme="http://yangbolin.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT常用命令总结]]></title>
    <link href="http://yangbolin.cn/2015/04/26/git-command/"/>
    <id>http://yangbolin.cn/2015/04/26/git-command/</id>
    <published>2015-04-26T06:27:34.000Z</published>
    <updated>2015-04-26T06:49:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近有个项目分支使用了git托管代码，虽然之前在github上托管过很多代码，但是对git本身的使用以及特性也没有太多的深入的了解，最近使用git出现了一个问题，查到最后是环境问题，很悲摧，为了避免悲剧再次出现，就看了一遍git相关的所有常见命令以及一些git的设计思想，比如工作区，暂存区，本地仓库等等，也算是对平时编写代码思路的一种启发。很多人都说git是分布式的，svn不是分布式的，那么git分布式到底体现在哪里，每个人本地都有一个完整的仓库吗？难道svn每个人本地的代码就不是完善的吗？关于git分布式，我们从下面几个点来解释：</p>
<a id="more"></a>

<ul>
<li>1.每个人都可以在本地管理代码的变更，而不像svn如果svn中心挂了，本地代码的管理就无法实现。</li>
<li>2.使用git人人都可以成为中心，而不像svn中心有且只有1个，中心挂了，只能坐等中心恢复，不然两个开发之间的代码就没法相互感知到。但是git可以在某个中心挂了之后，其他人能快速成为中心。</li>
<li>3.github的fork功能就一个分布式的典型例子，比如作者A拥有一个仓库repo，此时开源爱好者m对这个repo很感兴趣，想贡献一些代码，因此m就去fork了repo仓库，此时开源爱好者n也知道了这个事情，n和m一起基于fork出来的repo1来贡献代码，此时有两个仓库，一个是repo一个是repo1，repo挂掉不影响repo1，repo1挂掉不影响repo，等m和n都开发结束了，就提交分支合并请求到A那边，A觉得没啥问题就合并代码到repo仓库。</li>
</ul>
<h4 id="二-命令">二.命令</h4>
<p>基于命令维度总结了一下git的一些常用命令<br><img src="http://bolinyoung.qiniudn.com/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.bmp" alt="GIT-COMMAND"></p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近有个项目分支使用了git托管代码，虽然之前在github上托管过很多代码，但是对git本身的使用以及特性也没有太多的深入的了解，最近使用git出现了一个问题，查到最后是环境问题，很悲摧，为了避免悲剧再次出现，就看了一遍git相关的所有常见命令以及一些git的设计思想，比如工作区，暂存区，本地仓库等等，也算是对平时编写代码思路的一种启发。很多人都说git是分布式的，svn不是分布式的，那么git分布式到底体现在哪里，每个人本地都有一个完整的仓库吗？难道svn每个人本地的代码就不是完善的吗？关于git分布式，我们从下面几个点来解释：</p>
]]></summary>
    
      <category term="git" scheme="http://yangbolin.cn/tags/git/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[guava中的Multimap]]></title>
    <link href="http://yangbolin.cn/2015/04/12/guava-multimap/"/>
    <id>http://yangbolin.cn/2015/04/12/guava-multimap/</id>
    <published>2015-04-12T06:32:31.000Z</published>
    <updated>2015-04-12T06:58:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>我们在日常开发过程中都会使用Map这个数据结构，使用这个数据结构能够很方便维护一些映射关系，有时候，我们存储的结构是Key-Collection的映射关系，关于这个映射关系调用put方法的时候，我们需要先调用get方法，然后看看对应的Key是否在当前映射关系中已经存在Collection，如果不存在，我们直接忘Collection中增加一个元素，不存在我们需要手动去创建，然后在往我们手工创建的Collection中增加一个元素，最后再把这个Collection写入我们的Map中，很麻烦。对于C++ STL有过了解的人都知道，STL中有一个Multimap这个数据结构，该数据结构能方便地解决上面映射关系的问题。但是JDK本身不存在这样的数据结构。。。好在guava这个开源的二方库中自己定义了这个容器，该容器既能维护好Key-Collection这个数据结构，也能很方便往这个数据结构中写数据。</p>
<a id="more"></a>

<h4 id="二-Multimap数据结构">二.Multimap数据结构</h4>
<p><img src="http://bolinyoung.qiniudn.com/key-collection.png" alt="Multimap"></p>
<h4 id="三-如何使用">三.如何使用</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultimapTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Multimap&lt;String, Integer&gt; multimap = HashMultimap.create();
        multimap.put(<span class="string">"A"</span>, <span class="number">1</span>);
        multimap.put(<span class="string">"A"</span>, <span class="number">2</span>);
        
        System.out.println(multimap.get(<span class="string">"A"</span>));
    }
}
输出结果：
[<span class="number">1</span>, <span class="number">2</span>]
</pre></td></tr></table></figure>

<p>关于上述代码，我们看到我们的操作很简单，并不需要开发工程师自己去创建一个Collection，然后把这个Collection在手工写入Map中去。</p>
<h4 id="四-总结">四.总结</h4>
<p>可能很多工程师自己愿意创建Collection，并且自己写到Map中去，但是这个维护起来很不好维护，其实想想自己创建Collection并且写到Map中，也是一件很麻烦的事情，从此以后对于Key-Collection这种数据结构，直接走Multimap。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>我们在日常开发过程中都会使用Map这个数据结构，使用这个数据结构能够很方便维护一些映射关系，有时候，我们存储的结构是Key-Collection的映射关系，关于这个映射关系调用put方法的时候，我们需要先调用get方法，然后看看对应的Key是否在当前映射关系中已经存在Collection，如果不存在，我们直接忘Collection中增加一个元素，不存在我们需要手动去创建，然后在往我们手工创建的Collection中增加一个元素，最后再把这个Collection写入我们的Map中，很麻烦。对于C++ STL有过了解的人都知道，STL中有一个Multimap这个数据结构，该数据结构能方便地解决上面映射关系的问题。但是JDK本身不存在这样的数据结构。。。好在guava这个开源的二方库中自己定义了这个容器，该容器既能维护好Key-Collection这个数据结构，也能很方便往这个数据结构中写数据。</p>
]]></summary>
    
      <category term="guava" scheme="http://yangbolin.cn/tags/guava/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javac生成的access$000方法]]></title>
    <link href="http://yangbolin.cn/2015/03/21/javac-accessbash00/"/>
    <id>http://yangbolin.cn/2015/03/21/javac-accessbash00/</id>
    <published>2015-03-21T02:07:34.000Z</published>
    <updated>2015-03-21T02:41:01.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做字节码分析的时候，发现字节码中出现了access$000的方法，这个方法不是开发工程师写的，是编译器生成的，那么编译器生成这个方法是为了解决什么问题呢？我们知道编译会为静态代码块生成执行的方法，在类没有构造函数时为类生成缺省构造函数，这个access$000究竟是在什么场景下面用的呢？仔细分析包含access$000的类，发现该类中存在内部类，结合google搜索，原来acess$000是为了解决内部类访问外部类的成员，包括成员变量和成员方法。</p>
<a id="more"></a>

<h4 id="二-深入分析">二.深入分析</h4>
<p>我们先写个简单的测试例子，一个类中包含一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> {</span>
    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">3</span>;
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span>() {
        
    }
    
    class Inner {

        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() {
            Outer.<span class="keyword">this</span>.f();
            System.out.println(Outer.<span class="keyword">this</span>.x);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span>(String[] args) {
        System.out.println(<span class="string">"Inner Test"</span>);
    }
}
</pre></td></tr></table></figure>

<p>然后我们先看内部类的字节码<br><img src="http://bolinyoung.qiniudn.com/inner-call.png" alt="内部类字节码"><br>我们看到内部类的字节码中调用了access$000和access$100这两个方法，这两个方法都是Outer这个类的静态成员方法，同时带有一个Outer类型的参数。那么我们看看Outer这个类的字节码到底是什么样子<br><img src="http://bolinyoung.qiniudn.com/outer-code.png" alt="外部类的字节码"><br>果然外部类中存在两个这样的方法，我们先看一下access$000这个方法的实现，该方法先用aload_0把方法参数入栈，然后调用栈顶元素的f方法，即Outer的f方法，因为内部类中有地方通过外部类的this引用调用Outer的f()方法。access$100这个方法，很明显在访问Outer的成员变量x。</p>
<p>至此疑问都清楚了，原来access$xxx是编译器生成的，用来解决内部类访问外部类的成员。</p>
<p>但是你一定有一个疑问，我们自己能否写access$xxx的方法呢？答案是可以的。</p>
<h4 id="三-自己编写access$xxx">三.自己编写access$xxx</h4>
<p>写个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> {</span>
    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">3</span>;
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span>() {
        
    }
    
    class Inner {

        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() {
            Outer.<span class="keyword">this</span>.f();
            System.out.println(Outer.<span class="keyword">this</span>.x);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span>(String[] args) {
        System.out.println(<span class="string">"Inner Test"</span>);
    }
    
    <span class="comment">// 编写自己的access$xxx方法</span>
    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">888</span>(Outer outer) {
    	<span class="keyword">return</span> outer.x;
    }
}
</pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<ul>
<li>我们自己编写的access$xxx不能和编译生成的具有相同的方法签名，否则你会得到一个编译错误的。</li>
<li>access$xxx可以绕过编译器的检查，访问类的私有成员。</li>
<li>一般不要编写access$xxx方法。</li>
</ul>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做字节码分析的时候，发现字节码中出现了access$000的方法，这个方法不是开发工程师写的，是编译器生成的，那么编译器生成这个方法是为了解决什么问题呢？我们知道编译会为静态代码块生成执行的方法，在类没有构造函数时为类生成缺省构造函数，这个access$000究竟是在什么场景下面用的呢？仔细分析包含access$000的类，发现该类中存在内部类，结合google搜索，原来acess$000是为了解决内部类访问外部类的成员，包括成员变量和成员方法。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程语言" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Short对象的比较]]></title>
    <link href="http://yangbolin.cn/2014/12/26/short-ref-equal/"/>
    <id>http://yangbolin.cn/2014/12/26/short-ref-equal/</id>
    <published>2014-12-26T15:02:20.000Z</published>
    <updated>2014-12-27T02:30:27.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>今天和同事一起分析线下问题，发现代码中有个笔误，对两个Short类型的对象使用==来比较，结果是比较表达式一直为false，导致一个bug的产生。</p>
<a id="more"></a>

<h4 id="二-分析">二.分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Short s = <span class="number">100</span>;
        Short s1 = <span class="number">100</span>;
        <span class="comment">// true</span>
        System.out.println(s1 == s);

        Short t = <span class="number">129</span>;
        Short t1 = <span class="number">129</span>;
        <span class="comment">// false</span>
        System.out.println(t1 == t);
        
        Short m = <span class="keyword">new</span> Short(<span class="string">"100"</span>);
        Short m1 = <span class="keyword">new</span> Short(<span class="string">"100"</span>);
        <span class="comment">// false</span>
        System.out.println(m1 == m);
    }
}
</pre></td></tr></table></figure>

<p>写了一小段代码，模拟今天遇到的问题。我们看到第一个输出为true，第二个输出为false，第三个输出为false。为什么呢？我们来看一下生成的字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre>Code:
   <span class="comment">// Stack表示操作数栈的最大深度</span>
   <span class="comment">// Locals表示局部变量表所需的存储空间，单位是Slot，JVM为局部变量分配内存所使用的最小单位，double和long占用了两个Slot</span>
   <span class="comment">// Args_size 表示方法参数个数，main函数只有一个参数，当然size为1了</span>
   <span class="comment">// 明明main方法中只有6个局部变量，为啥空间大小是7,别忘了第一个存储的是调用方法的实例，如果是静态方法存储的是类实例，如果是非静态方法存储的是this引用。</span>
   Stack=<span class="number">3</span>, Locals=<span class="number">7</span>, Args_size=<span class="number">1</span>

   <span class="number">0</span>:	bipush	<span class="number">100</span>
   <span class="comment">// 这里调用了Short类的静态方法valueOf,待会分析valueOf的实现</span>
   <span class="number">2</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">5</span>:	astore_1
   <span class="number">6</span>:	bipush	<span class="number">100</span>
   <span class="number">8</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">11</span>:	astore_2
   <span class="number">12</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">15</span>:	aload_2
   <span class="number">16</span>:	aload_1
   <span class="number">17</span>:	if_acmpne	<span class="number">24</span>
   <span class="number">20</span>:	iconst_1
   <span class="number">21</span>:	goto	<span class="number">25</span>
   <span class="number">24</span>:	iconst_0
   <span class="number">25</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">28</span>:	sipush	<span class="number">129</span>
   <span class="number">31</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">34</span>:	astore_3
   <span class="number">35</span>:	sipush	<span class="number">129</span>
   <span class="number">38</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">41</span>:	astore	<span class="number">4</span>
   <span class="number">43</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">46</span>:	aload	<span class="number">4</span>
   <span class="number">48</span>:	aload_3
   <span class="number">49</span>:	if_acmpne	<span class="number">56</span>
   <span class="number">52</span>:	iconst_1
   <span class="number">53</span>:	goto	<span class="number">57</span>
   <span class="number">56</span>:	iconst_0
   <span class="number">57</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">60</span>:	<span class="keyword">new</span>	#<span class="number">17</span>; <span class="comment">//class java/lang/Short</span>
   <span class="number">63</span>:	dup
   <span class="number">64</span>:	ldc	#<span class="number">34</span>; <span class="comment">//String 100</span>
   <span class="comment">// 这里直接调用了Short的构造函数</span>
   <span class="number">66</span>:	invokespecial	#<span class="number">36</span>; <span class="comment">//Method java/lang/Short."&lt;init&gt;":(Ljava/lang/String;)V</span>
   <span class="number">69</span>:	astore	<span class="number">5</span>
   <span class="number">71</span>:	<span class="keyword">new</span>	#<span class="number">17</span>; <span class="comment">//class java/lang/Short</span>
   <span class="number">74</span>:	dup
   <span class="number">75</span>:	ldc	#<span class="number">34</span>; <span class="comment">//String 100</span>
   <span class="comment">// 这里直接调用了Short的构造函数</span>
   <span class="number">77</span>:	invokespecial	#<span class="number">36</span>; <span class="comment">//Method java/lang/Short."&lt;init&gt;":(Ljava/lang/String;)V</span>
   <span class="number">80</span>:	astore	<span class="number">6</span>
   <span class="number">82</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">85</span>:	aload	<span class="number">6</span>
   <span class="number">87</span>:	aload	<span class="number">5</span>
   <span class="number">89</span>:	if_acmpne	<span class="number">96</span>
   <span class="number">92</span>:	iconst_1
   <span class="number">93</span>:	goto	<span class="number">97</span>
   <span class="number">96</span>:	iconst_0
   <span class="number">97</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">100</span>:	<span class="keyword">return</span>
</pre></td></tr></table></figure>

<p>我们在字节码中看到有调用Short的valueOf方法，那么接下来我们看看valueOf方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>...
<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> {</span>
	<span class="keyword">private</span> <span class="title">ShortCache</span>(){}

	<span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];

	<span class="keyword">static</span> {
	    <span class="comment">// 缓存[-127,128]之间的Short对象</span>
	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)
		cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));
	}
}
...
<span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span>(<span class="keyword">short</span> s) {
	<span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;
	<span class="keyword">int</span> sAsInt = s;
	<span class="comment">// 走缓存</span>
	<span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> && sAsInt &lt;= <span class="number">127</span>) { <span class="comment">// must cache </span>
	    <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];
	}
        <span class="keyword">return</span> <span class="keyword">new</span> Short(s);
}
...
</pre></td></tr></table></figure>

<p>看完valueOf的实现，你就明白这一切了，首先使用=赋值的时候会调用valueOf(S)这个方法，S标识short，在这方法中如果要赋予的值在[-127,128]这个区间内，那么直接取缓存中的值，缓存中缓存了[-127,128]这个区间内的所有Short对象，如果Short的值在这个区间内，你使用=赋值，直接取缓存，至此上面的问题就不言而喻了。</p>
<h4 id="三-总结">三.总结</h4>
<blockquote>
<p>1.写代码的时候最好不要使用==来比较任何类型的引用，除非是基本类型，不然很容易出问题，导致某些场景下面没问题，某些场景下面有问题。<br>2.Long类型也有类似的机制。</p>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>今天和同事一起分析线下问题，发现代码中有个笔误，对两个Short类型的对象使用==来比较，结果是比较表达式一直为false，导致一个bug的产生。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次关于servlet的扩展]]></title>
    <link href="http://yangbolin.cn/2014/11/17/servlet-extend/"/>
    <id>http://yangbolin.cn/2014/11/17/servlet-extend/</id>
    <published>2014-11-17T14:43:31.000Z</published>
    <updated>2014-11-17T14:59:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>现有一个web框架，从HttpServletRequest中获取调用request.getParameter(“orderId”)获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。</p>
<a id="more"></a>

<h4 id="二-实现思路">二.实现思路</h4>
<p>1.直接先解密orderId，然后再修改request中的orderId，你会发现你没法修改，servlet规范不允许修改request。<br>2.对HttpServletRequest进行包装，在进入web框架的时候把这个HttpServletRequest包装一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> {</span>

    <span class="keyword">private</span> Map&lt;String, String&gt; param = <span class="keyword">new</span> HashMap&lt;String, String&gt;();

    <span class="javadoc">/**
     *<span class="javadoctag"> @param</span> request
     */</span>
    <span class="keyword">public</span> <span class="title">MyHttpServletRequestWrapper</span>(HttpServletRequest request) {
        <span class="keyword">super</span>(request);
    }

    <span class="comment">// 重写获取参数值的方法</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> String <span class="title">getParameter</span>(String name) {
        <span class="keyword">if</span> (param.containsKey(name)) {
            <span class="keyword">return</span> param.get(name);
        }
        <span class="keyword">return</span> <span class="keyword">super</span>.getParameter(name);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParameter</span>(String name, String value) {
        param.put(name, value);
    }
}
</pre></td></tr></table></figure>

<p>增加解密orderId的filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOrderIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>() {
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest request, ServletResponse servletResponse, FilterChain filterChain)                                                                   <span class="keyword">throws</span> IOException,                                                         ServletException {
        String orderId = request.getParameter(<span class="string">"orderId"</span>);
        <span class="comment">// 对orderId解密</span>
        orderId = WebUtils.decode(orderId);
        MyHttpServletRequestWrapper myRequestWrapper = <span class="keyword">new</span> MyHttpServletRequestWrapper(                        (HttpServletRequest) request);
        myRequestWrapper.addParameter(<span class="string">"orderId"</span>, orderId);
        <span class="comment">// 把包装后的Request传递给下一个Filter</span>
        filterChain.doFilter(myRequestWrapper, servletResponse);
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(FilterConfig arg0) <span class="keyword">throws</span> ServletException {
    }
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>现有一个web框架，从HttpServletRequest中获取调用request.getParameter(“orderId”)获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。</p>
]]></summary>
    
      <category term="servlet" scheme="http://yangbolin.cn/tags/servlet/"/>
    
      <category term="web开发" scheme="http://yangbolin.cn/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
