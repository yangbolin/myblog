<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BolinYoung's Blog]]></title>
  <subtitle><![CDATA[Believe in yourself]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yangbolin.cn/"/>
  <updated>2015-05-19T00:58:53.428Z</updated>
  <id>http://yangbolin.cn/</id>
  
  <author>
    <name><![CDATA[BolinYoung]]></name>
    <email><![CDATA[boris.yangbl@alibaba-inc.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[操作系统定时调度]]></title>
    <link href="http://yangbolin.cn/2015/05/18/os-timer-call/"/>
    <id>http://yangbolin.cn/2015/05/18/os-timer-call/</id>
    <published>2015-05-18T12:13:29.000Z</published>
    <updated>2015-05-19T00:58:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近需要开发一些定时任务，提到定时任务，我们都会想到quartz，为了让我们的定时任务能够更加灵活的被控制，我们通过shell脚本去执行一个java类，然后定时去执行这个shell脚本即可。如何去定时执行这个shell脚本，我们想到Linux本身提供后台进程去定时执行一些命令，那就是crontab，因此我们编写好自己的shell脚本再写好crontab后就能定时执行我们的任务了。</p>
<a id="more"></a>

<h4 id="二-如何配置">二.如何配置</h4>
<ul>
<li>查看crontab的配置<br>crontab -l</li>
<li>编辑crontab的配置<br>crontab -e</li>
<li><p>crontab的格式说明<br><img src="http://bolinyoung.qiniudn.com/crontab.jpg" alt="crontab格式说明"></p>
</li>
<li><p>less  /var/log/cron<br>查看crontab运行时的日志</p>
</li>
</ul>
<h4 id="三-注意点">三.注意点</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="bullet">* </span>6 <span class="bullet">* *</span> * sh xx.sh
</pre></td></tr></table></figure>

<p>表示每天凌晨6点开始没分钟执行一次sh xx.sh脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>0 6 <span class="bullet">* *</span> * sh xx.sh
</pre></td></tr></table></figure>

<p>表示每天凌晨6点开始执行一次sh xx.sh脚本，只执行一次</p>
<p>注意上面这两个频率的区别，排查问题的时候注意考虑那些一直被忽略的点，有可能那些点就是解决问题的关键之所在。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近需要开发一些定时任务，提到定时任务，我们都会想到quartz，为了让我们的定时任务能够更加灵活的被控制，我们通过shell脚本去执行一个java类，然后定时去执行这个shell脚本即可。如何去定时执行这个shell脚本，我们想到Linux本身提供后台进程去定时执行一些命令，那就是crontab，因此我们编写好自己的shell脚本再写好crontab后就能定时执行我们的任务了。</p>
]]></summary>
    
      <category term="crontab" scheme="http://yangbolin.cn/tags/crontab/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[css换行]]></title>
    <link href="http://yangbolin.cn/2015/05/07/css-break-line/"/>
    <id>http://yangbolin.cn/2015/05/07/css-break-line/</id>
    <published>2015-05-07T13:55:59.000Z</published>
    <updated>2015-05-08T01:22:36.000Z</updated>
    <content type="html"><![CDATA[<p>最近在搞一个后台系统的时候，发现table表格的宽度没法调整，找前端大神看了一下，发现是table表格中的全英文内容过长，不会自动换行导致。因此需要用CSS来实现换行，浏览器默认不会对英文内容进行换行的。具体CSS的写法如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">word-break</span>: <span class="tag">break-all</span>;
<span class="tag">word-wrap</span>: <span class="tag">break-word</span>;
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="CSS" scheme="http://yangbolin.cn/tags/CSS/"/>
    
      <category term="前端开发" scheme="http://yangbolin.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT常用命令总结]]></title>
    <link href="http://yangbolin.cn/2015/04/26/git-command/"/>
    <id>http://yangbolin.cn/2015/04/26/git-command/</id>
    <published>2015-04-26T06:27:34.000Z</published>
    <updated>2015-04-26T06:49:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近有个项目分支使用了git托管代码，虽然之前在github上托管过很多代码，但是对git本身的使用以及特性也没有太多的深入的了解，最近使用git出现了一个问题，查到最后是环境问题，很悲摧，为了避免悲剧再次出现，就看了一遍git相关的所有常见命令以及一些git的设计思想，比如工作区，暂存区，本地仓库等等，也算是对平时编写代码思路的一种启发。很多人都说git是分布式的，svn不是分布式的，那么git分布式到底体现在哪里，每个人本地都有一个完整的仓库吗？难道svn每个人本地的代码就不是完善的吗？关于git分布式，我们从下面几个点来解释：</p>
<a id="more"></a>

<ul>
<li>1.每个人都可以在本地管理代码的变更，而不像svn如果svn中心挂了，本地代码的管理就无法实现。</li>
<li>2.使用git人人都可以成为中心，而不像svn中心有且只有1个，中心挂了，只能坐等中心恢复，不然两个开发之间的代码就没法相互感知到。但是git可以在某个中心挂了之后，其他人能快速成为中心。</li>
<li>3.github的fork功能就一个分布式的典型例子，比如作者A拥有一个仓库repo，此时开源爱好者m对这个repo很感兴趣，想贡献一些代码，因此m就去fork了repo仓库，此时开源爱好者n也知道了这个事情，n和m一起基于fork出来的repo1来贡献代码，此时有两个仓库，一个是repo一个是repo1，repo挂掉不影响repo1，repo1挂掉不影响repo，等m和n都开发结束了，就提交分支合并请求到A那边，A觉得没啥问题就合并代码到repo仓库。</li>
</ul>
<h4 id="二-命令">二.命令</h4>
<p>基于命令维度总结了一下git的一些常用命令<br><img src="http://bolinyoung.qiniudn.com/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.bmp" alt="GIT-COMMAND"></p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近有个项目分支使用了git托管代码，虽然之前在github上托管过很多代码，但是对git本身的使用以及特性也没有太多的深入的了解，最近使用git出现了一个问题，查到最后是环境问题，很悲摧，为了避免悲剧再次出现，就看了一遍git相关的所有常见命令以及一些git的设计思想，比如工作区，暂存区，本地仓库等等，也算是对平时编写代码思路的一种启发。很多人都说git是分布式的，svn不是分布式的，那么git分布式到底体现在哪里，每个人本地都有一个完整的仓库吗？难道svn每个人本地的代码就不是完善的吗？关于git分布式，我们从下面几个点来解释：</p>
]]></summary>
    
      <category term="git" scheme="http://yangbolin.cn/tags/git/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[guava中的Multimap]]></title>
    <link href="http://yangbolin.cn/2015/04/12/guava-multimap/"/>
    <id>http://yangbolin.cn/2015/04/12/guava-multimap/</id>
    <published>2015-04-12T06:32:31.000Z</published>
    <updated>2015-04-12T06:58:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>我们在日常开发过程中都会使用Map这个数据结构，使用这个数据结构能够很方便维护一些映射关系，有时候，我们存储的结构是Key-Collection的映射关系，关于这个映射关系调用put方法的时候，我们需要先调用get方法，然后看看对应的Key是否在当前映射关系中已经存在Collection，如果不存在，我们直接忘Collection中增加一个元素，不存在我们需要手动去创建，然后在往我们手工创建的Collection中增加一个元素，最后再把这个Collection写入我们的Map中，很麻烦。对于C++ STL有过了解的人都知道，STL中有一个Multimap这个数据结构，该数据结构能方便地解决上面映射关系的问题。但是JDK本身不存在这样的数据结构。。。好在guava这个开源的二方库中自己定义了这个容器，该容器既能维护好Key-Collection这个数据结构，也能很方便往这个数据结构中写数据。</p>
<a id="more"></a>

<h4 id="二-Multimap数据结构">二.Multimap数据结构</h4>
<p><img src="http://bolinyoung.qiniudn.com/key-collection.png" alt="Multimap"></p>
<h4 id="三-如何使用">三.如何使用</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultimapTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Multimap&lt;String, Integer&gt; multimap = HashMultimap.create();
        multimap.put(<span class="string">"A"</span>, <span class="number">1</span>);
        multimap.put(<span class="string">"A"</span>, <span class="number">2</span>);
        
        System.out.println(multimap.get(<span class="string">"A"</span>));
    }
}
输出结果：
[<span class="number">1</span>, <span class="number">2</span>]
</pre></td></tr></table></figure>

<p>关于上述代码，我们看到我们的操作很简单，并不需要开发工程师自己去创建一个Collection，然后把这个Collection在手工写入Map中去。</p>
<h4 id="四-总结">四.总结</h4>
<p>可能很多工程师自己愿意创建Collection，并且自己写到Map中去，但是这个维护起来很不好维护，其实想想自己创建Collection并且写到Map中，也是一件很麻烦的事情，从此以后对于Key-Collection这种数据结构，直接走Multimap。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>我们在日常开发过程中都会使用Map这个数据结构，使用这个数据结构能够很方便维护一些映射关系，有时候，我们存储的结构是Key-Collection的映射关系，关于这个映射关系调用put方法的时候，我们需要先调用get方法，然后看看对应的Key是否在当前映射关系中已经存在Collection，如果不存在，我们直接忘Collection中增加一个元素，不存在我们需要手动去创建，然后在往我们手工创建的Collection中增加一个元素，最后再把这个Collection写入我们的Map中，很麻烦。对于C++ STL有过了解的人都知道，STL中有一个Multimap这个数据结构，该数据结构能方便地解决上面映射关系的问题。但是JDK本身不存在这样的数据结构。。。好在guava这个开源的二方库中自己定义了这个容器，该容器既能维护好Key-Collection这个数据结构，也能很方便往这个数据结构中写数据。</p>
]]></summary>
    
      <category term="guava" scheme="http://yangbolin.cn/tags/guava/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javac生成的access$000方法]]></title>
    <link href="http://yangbolin.cn/2015/03/21/javac-accessbash00/"/>
    <id>http://yangbolin.cn/2015/03/21/javac-accessbash00/</id>
    <published>2015-03-21T02:07:34.000Z</published>
    <updated>2015-03-21T02:41:01.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做字节码分析的时候，发现字节码中出现了access$000的方法，这个方法不是开发工程师写的，是编译器生成的，那么编译器生成这个方法是为了解决什么问题呢？我们知道编译会为静态代码块生成执行的方法，在类没有构造函数时为类生成缺省构造函数，这个access$000究竟是在什么场景下面用的呢？仔细分析包含access$000的类，发现该类中存在内部类，结合google搜索，原来acess$000是为了解决内部类访问外部类的成员，包括成员变量和成员方法。</p>
<a id="more"></a>

<h4 id="二-深入分析">二.深入分析</h4>
<p>我们先写个简单的测试例子，一个类中包含一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> {</span>
    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">3</span>;
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span>() {
        
    }
    
    class Inner {

        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() {
            Outer.<span class="keyword">this</span>.f();
            System.out.println(Outer.<span class="keyword">this</span>.x);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span>(String[] args) {
        System.out.println(<span class="string">"Inner Test"</span>);
    }
}
</pre></td></tr></table></figure>

<p>然后我们先看内部类的字节码<br><img src="http://bolinyoung.qiniudn.com/inner-call.png" alt="内部类字节码"><br>我们看到内部类的字节码中调用了access$000和access$100这两个方法，这两个方法都是Outer这个类的静态成员方法，同时带有一个Outer类型的参数。那么我们看看Outer这个类的字节码到底是什么样子<br><img src="http://bolinyoung.qiniudn.com/outer-code.png" alt="外部类的字节码"><br>果然外部类中存在两个这样的方法，我们先看一下access$000这个方法的实现，该方法先用aload_0把方法参数入栈，然后调用栈顶元素的f方法，即Outer的f方法，因为内部类中有地方通过外部类的this引用调用Outer的f()方法。access$100这个方法，很明显在访问Outer的成员变量x。</p>
<p>至此疑问都清楚了，原来access$xxx是编译器生成的，用来解决内部类访问外部类的成员。</p>
<p>但是你一定有一个疑问，我们自己能否写access$xxx的方法呢？答案是可以的。</p>
<h4 id="三-自己编写access$xxx">三.自己编写access$xxx</h4>
<p>写个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> {</span>
    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">3</span>;
    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span>() {
        
    }
    
    class Inner {

        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() {
            Outer.<span class="keyword">this</span>.f();
            System.out.println(Outer.<span class="keyword">this</span>.x);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span>(String[] args) {
        System.out.println(<span class="string">"Inner Test"</span>);
    }
    
    <span class="comment">// 编写自己的access$xxx方法</span>
    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">888</span>(Outer outer) {
    	<span class="keyword">return</span> outer.x;
    }
}
</pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<ul>
<li>我们自己编写的access$xxx不能和编译生成的具有相同的方法签名，否则你会得到一个编译错误的。</li>
<li>access$xxx可以绕过编译器的检查，访问类的私有成员。</li>
<li>一般不要编写access$xxx方法。</li>
</ul>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近在做字节码分析的时候，发现字节码中出现了access$000的方法，这个方法不是开发工程师写的，是编译器生成的，那么编译器生成这个方法是为了解决什么问题呢？我们知道编译会为静态代码块生成执行的方法，在类没有构造函数时为类生成缺省构造函数，这个access$000究竟是在什么场景下面用的呢？仔细分析包含access$000的类，发现该类中存在内部类，结合google搜索，原来acess$000是为了解决内部类访问外部类的成员，包括成员变量和成员方法。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程语言" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Short对象的比较]]></title>
    <link href="http://yangbolin.cn/2014/12/26/short-ref-equal/"/>
    <id>http://yangbolin.cn/2014/12/26/short-ref-equal/</id>
    <published>2014-12-26T15:02:20.000Z</published>
    <updated>2014-12-27T02:30:27.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>今天和同事一起分析线下问题，发现代码中有个笔误，对两个Short类型的对象使用==来比较，结果是比较表达式一直为false，导致一个bug的产生。</p>
<a id="more"></a>

<h4 id="二-分析">二.分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Short s = <span class="number">100</span>;
        Short s1 = <span class="number">100</span>;
        <span class="comment">// true</span>
        System.out.println(s1 == s);

        Short t = <span class="number">129</span>;
        Short t1 = <span class="number">129</span>;
        <span class="comment">// false</span>
        System.out.println(t1 == t);
        
        Short m = <span class="keyword">new</span> Short(<span class="string">"100"</span>);
        Short m1 = <span class="keyword">new</span> Short(<span class="string">"100"</span>);
        <span class="comment">// false</span>
        System.out.println(m1 == m);
    }
}
</pre></td></tr></table></figure>

<p>写了一小段代码，模拟今天遇到的问题。我们看到第一个输出为true，第二个输出为false，第三个输出为false。为什么呢？我们来看一下生成的字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre>Code:
   <span class="comment">// Stack表示操作数栈的最大深度</span>
   <span class="comment">// Locals表示局部变量表所需的存储空间，单位是Slot，JVM为局部变量分配内存所使用的最小单位，double和long占用了两个Slot</span>
   <span class="comment">// Args_size 表示方法参数个数，main函数只有一个参数，当然size为1了</span>
   <span class="comment">// 明明main方法中只有6个局部变量，为啥空间大小是7,别忘了第一个存储的是调用方法的实例，如果是静态方法存储的是类实例，如果是非静态方法存储的是this引用。</span>
   Stack=<span class="number">3</span>, Locals=<span class="number">7</span>, Args_size=<span class="number">1</span>

   <span class="number">0</span>:	bipush	<span class="number">100</span>
   <span class="comment">// 这里调用了Short类的静态方法valueOf,待会分析valueOf的实现</span>
   <span class="number">2</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">5</span>:	astore_1
   <span class="number">6</span>:	bipush	<span class="number">100</span>
   <span class="number">8</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">11</span>:	astore_2
   <span class="number">12</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">15</span>:	aload_2
   <span class="number">16</span>:	aload_1
   <span class="number">17</span>:	if_acmpne	<span class="number">24</span>
   <span class="number">20</span>:	iconst_1
   <span class="number">21</span>:	goto	<span class="number">25</span>
   <span class="number">24</span>:	iconst_0
   <span class="number">25</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">28</span>:	sipush	<span class="number">129</span>
   <span class="number">31</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">34</span>:	astore_3
   <span class="number">35</span>:	sipush	<span class="number">129</span>
   <span class="number">38</span>:	invokestatic	#<span class="number">16</span>; <span class="comment">//Method java/lang/Short.valueOf:(S)Ljava/lang/Short;</span>
   <span class="number">41</span>:	astore	<span class="number">4</span>
   <span class="number">43</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">46</span>:	aload	<span class="number">4</span>
   <span class="number">48</span>:	aload_3
   <span class="number">49</span>:	if_acmpne	<span class="number">56</span>
   <span class="number">52</span>:	iconst_1
   <span class="number">53</span>:	goto	<span class="number">57</span>
   <span class="number">56</span>:	iconst_0
   <span class="number">57</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">60</span>:	<span class="keyword">new</span>	#<span class="number">17</span>; <span class="comment">//class java/lang/Short</span>
   <span class="number">63</span>:	dup
   <span class="number">64</span>:	ldc	#<span class="number">34</span>; <span class="comment">//String 100</span>
   <span class="comment">// 这里直接调用了Short的构造函数</span>
   <span class="number">66</span>:	invokespecial	#<span class="number">36</span>; <span class="comment">//Method java/lang/Short."&lt;init&gt;":(Ljava/lang/String;)V</span>
   <span class="number">69</span>:	astore	<span class="number">5</span>
   <span class="number">71</span>:	<span class="keyword">new</span>	#<span class="number">17</span>; <span class="comment">//class java/lang/Short</span>
   <span class="number">74</span>:	dup
   <span class="number">75</span>:	ldc	#<span class="number">34</span>; <span class="comment">//String 100</span>
   <span class="comment">// 这里直接调用了Short的构造函数</span>
   <span class="number">77</span>:	invokespecial	#<span class="number">36</span>; <span class="comment">//Method java/lang/Short."&lt;init&gt;":(Ljava/lang/String;)V</span>
   <span class="number">80</span>:	astore	<span class="number">6</span>
   <span class="number">82</span>:	getstatic	#<span class="number">22</span>; <span class="comment">//Field java/lang/System.out:Ljava/io/PrintStream;</span>
   <span class="number">85</span>:	aload	<span class="number">6</span>
   <span class="number">87</span>:	aload	<span class="number">5</span>
   <span class="number">89</span>:	if_acmpne	<span class="number">96</span>
   <span class="number">92</span>:	iconst_1
   <span class="number">93</span>:	goto	<span class="number">97</span>
   <span class="number">96</span>:	iconst_0
   <span class="number">97</span>:	invokevirtual	#<span class="number">28</span>; <span class="comment">//Method java/io/PrintStream.println:(Z)V</span>
   <span class="number">100</span>:	<span class="keyword">return</span>
</pre></td></tr></table></figure>

<p>我们在字节码中看到有调用Short的valueOf方法，那么接下来我们看看valueOf方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>...
<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> {</span>
	<span class="keyword">private</span> <span class="title">ShortCache</span>(){}

	<span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];

	<span class="keyword">static</span> {
	    <span class="comment">// 缓存[-127,128]之间的Short对象</span>
	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)
		cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));
	}
}
...
<span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span>(<span class="keyword">short</span> s) {
	<span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;
	<span class="keyword">int</span> sAsInt = s;
	<span class="comment">// 走缓存</span>
	<span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> && sAsInt &lt;= <span class="number">127</span>) { <span class="comment">// must cache </span>
	    <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];
	}
        <span class="keyword">return</span> <span class="keyword">new</span> Short(s);
}
...
</pre></td></tr></table></figure>

<p>看完valueOf的实现，你就明白这一切了，首先使用=赋值的时候会调用valueOf(S)这个方法，S标识short，在这方法中如果要赋予的值在[-127,128]这个区间内，那么直接取缓存中的值，缓存中缓存了[-127,128]这个区间内的所有Short对象，如果Short的值在这个区间内，你使用=赋值，直接取缓存，至此上面的问题就不言而喻了。</p>
<h4 id="三-总结">三.总结</h4>
<blockquote>
<p>1.写代码的时候最好不要使用==来比较任何类型的引用，除非是基本类型，不然很容易出问题，导致某些场景下面没问题，某些场景下面有问题。<br>2.Long类型也有类似的机制。</p>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-背景">一.背景</h4>
<p>今天和同事一起分析线下问题，发现代码中有个笔误，对两个Short类型的对象使用==来比较，结果是比较表达式一直为false，导致一个bug的产生。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次关于servlet的扩展]]></title>
    <link href="http://yangbolin.cn/2014/11/17/servlet-extend/"/>
    <id>http://yangbolin.cn/2014/11/17/servlet-extend/</id>
    <published>2014-11-17T14:43:31.000Z</published>
    <updated>2014-11-17T14:59:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>现有一个web框架，从HttpServletRequest中获取调用request.getParameter(“orderId”)获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。</p>
<a id="more"></a>

<h4 id="二-实现思路">二.实现思路</h4>
<p>1.直接先解密orderId，然后再修改request中的orderId，你会发现你没法修改，servlet规范不允许修改request。<br>2.对HttpServletRequest进行包装，在进入web框架的时候把这个HttpServletRequest包装一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> {</span>

    <span class="keyword">private</span> Map&lt;String, String&gt; param = <span class="keyword">new</span> HashMap&lt;String, String&gt;();

    <span class="javadoc">/**
     *<span class="javadoctag"> @param</span> request
     */</span>
    <span class="keyword">public</span> <span class="title">MyHttpServletRequestWrapper</span>(HttpServletRequest request) {
        <span class="keyword">super</span>(request);
    }

    <span class="comment">// 重写获取参数值的方法</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> String <span class="title">getParameter</span>(String name) {
        <span class="keyword">if</span> (param.containsKey(name)) {
            <span class="keyword">return</span> param.get(name);
        }
        <span class="keyword">return</span> <span class="keyword">super</span>.getParameter(name);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParameter</span>(String name, String value) {
        param.put(name, value);
    }
}
</pre></td></tr></table></figure>

<p>增加解密orderId的filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOrderIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>() {
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest request, ServletResponse servletResponse, FilterChain filterChain)                                                                   <span class="keyword">throws</span> IOException,                                                         ServletException {
        String orderId = request.getParameter(<span class="string">"orderId"</span>);
        <span class="comment">// 对orderId解密</span>
        orderId = WebUtils.decode(orderId);
        MyHttpServletRequestWrapper myRequestWrapper = <span class="keyword">new</span> MyHttpServletRequestWrapper(                        (HttpServletRequest) request);
        myRequestWrapper.addParameter(<span class="string">"orderId"</span>, orderId);
        <span class="comment">// 把包装后的Request传递给下一个Filter</span>
        filterChain.doFilter(myRequestWrapper, servletResponse);
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(FilterConfig arg0) <span class="keyword">throws</span> ServletException {
    }
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>现有一个web框架，从HttpServletRequest中获取调用request.getParameter(“orderId”)获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。</p>
]]></summary>
    
      <category term="servlet" scheme="http://yangbolin.cn/tags/servlet/"/>
    
      <category term="web开发" scheme="http://yangbolin.cn/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[akka如何和Spring集成起来]]></title>
    <link href="http://yangbolin.cn/2014/11/17/akka-spring/"/>
    <id>http://yangbolin.cn/2014/11/17/akka-spring/</id>
    <published>2014-11-17T14:08:04.000Z</published>
    <updated>2014-11-17T15:16:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近又重新学习了一下akka，并且在一个web应用中成功使用了akka提升了系统的性能。我们在web应用中一般都会有dao&amp;&amp;service，这些都是spring的bean，我们定义一个actor，这个actor中可能调用dao读写数据库，也可能调用service做业务逻辑，因此我们就希望actor也是从spring容器中获取到的，这样就可以在actor中注入service&amp;&amp;dao了。</p>
<a id="more"></a>

<h4 id="二-如何从Spring容器中获取actor">二.如何从Spring容器中获取actor</h4>
<p>1.用于从Spring容器中获取actor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringActorProducer</span> <span class="keyword">implements</span> <span class="title">IndirectActorProducer</span> {</span>

    <span class="keyword">final</span> ApplicationContext applicationContext;
    <span class="keyword">final</span> String             actorBeanName;

    <span class="keyword">public</span> <span class="title">SpringActorProducer</span>(ApplicationContext applicationContext, String actorBeanName){
        <span class="keyword">this</span>.applicationContext = applicationContext;
        <span class="keyword">this</span>.actorBeanName = actorBeanName;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Actor <span class="title">produce</span>() {
        <span class="keyword">return</span> (Actor) applicationContext.getBean(actorBeanName);
    }

    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Class&lt;? extends Actor&gt; <span class="title">actorClass</span>() {
        <span class="keyword">return</span> (Class&lt;? extends Actor&gt;) applicationContext.getType(actorBeanName);
    }
}
</pre></td></tr></table></figure>

<p>2.扩展actor的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>public class SpringExtension extends AbstractExtensionId&lt;SpringExtension.SpringExt&gt; {

    /**
     * The identifier used to access the SpringExtension.
     */
    public static SpringExtension SpringExtProvider = new SpringExtension();

    /**
     * Is used by Akka to instantiate the Extension identified by this ExtensionId, internal use only.
     */
    @Override
    public SpringExt createExtension(ExtendedActorSystem system) {
        return new SpringExt();
    }

    /**
     * The Extension implementation.
     */
    public static class SpringExt implements Extension {

        private volatile ApplicationContext applicationContext;

        /**
         * Used to initialize the Spring application context for the extension.
         * 
         * @param applicationContext
         */
        public void initialize(ApplicationContext applicationContext) {
            this.applicationContext = applicationContext;
        }

        /**
         * Create a Props for the specified actorBeanName using the SpringActorProducer class.
         * 
         * @param actorBeanName The name of the actor bean to create Props for
         * @return a Props that will create the named actor bean using Spring
         */
        public Props props(String actorBeanName) {
            return Props.create(SpringActorProducer.class, applicationContext, actorBeanName);
        }
    }
}
</pre></td></tr></table></figure>

<p>3.示例actor以及actor依赖的service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingService</span> {</span>
  <span class="javadoc">/**
   * Increment the given number by one.
   */</span>
  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increment</span>(<span class="keyword">int</span> count) {
    <span class="keyword">return</span> count + <span class="number">1</span>;
  }
}
class CountingActor extends UntypedActor {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> {</span>}
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span> {</span>}

    <span class="comment">// the service that will be automatically injected</span>
    <span class="keyword">private</span> CountingService countingService;

    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object message) <span class="keyword">throws</span> Exception {
        System.out.println(countingService);
        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Count) {
            count = countingService.increment(count);
        } <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Get) {
            getSender().tell(count, getSelf());
        } <span class="keyword">else</span> {
            unhandled(message);
        }
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountingService</span>(CountingService countingService) {
        <span class="keyword">this</span>.countingService = countingService;
    }
    
    <span class="keyword">public</span> <span class="title">CountingActor</span>() {
        System.out.println(<span class="string">"CountingActor is Creating..."</span>);
    }
}
</pre></td></tr></table></figure>

<p>CountingActor依赖了CountingService，CountingService到时候会被注入到CountingActor中。</p>
<p>4.配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
	<span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>
	<span class="attribute">default-autowire</span>=<span class="value">"byName"</span>&gt;</span>

	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"countingService"</span> <span class="attribute">class</span>=<span class="value">"com.bolin.young.akka.spring.CountingService"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"countingActor"</span> <span class="attribute">class</span>=<span class="value">"com.bolin.young.akka.spring.CountingActor"</span>  <span class="attribute">scope</span>=<span class="value">"prototype"</span> /&gt;</span>

	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myActorSystem"</span> <span class="attribute">class</span>=<span class="value">"akka.actor.ActorSystem"</span>
		<span class="attribute">factory-method</span>=<span class="value">"create"</span> <span class="attribute">destroy-method</span>=<span class="value">"shutdown"</span> <span class="attribute">scope</span>=<span class="value">"singleton"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"mySpringAkkaSystem"</span> /&gt;</span>
	<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
	
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<p>5.如何使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// create a spring context and scan the classes</span>
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);

    ActorSystem myActorSystem = (ActorSystem)ctx.getBean(<span class="string">"myActorSystem"</span>);
    
    System.out.println(myActorSystem);
    
    SpringExtProvider.get(myActorSystem).initialize(ctx);
    
    <span class="keyword">final</span> ActorRef myActor = myActorSystem.actorOf(
                   SpringExtProvider.get(myActorSystem).props(<span class="string">"countingActor"</span>), <span class="string">"countingActor"</span>);
</pre></td></tr></table></figure>

<h4 id="三-最后总结">三.最后总结</h4>
<p>1.一般actorA发消息给actorB，actorB返回消息给actorA。我们可以自己在代码中发消息给actorA，然后坐等actorA的返回，如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>BootstrapAnalyzeMsg bootstrapAnalyzeMsg = <span class="keyword">new</span> BootstrapAnalyzeMsg();
bootstrapAnalyzeMsg.setFileItem(treeFile);

Timeout timeout = <span class="keyword">new</span> Timeout(Duration.create(TIME_OUT, <span class="string">"seconds"</span>));
Future&lt;Object&gt; future = Patterns.ask(bootstrapAnalyzeActor, bootstrapAnalyzeMsg, timeout);

<span class="keyword">try</span> {
     <span class="comment">// 当前线程会阻塞，直到有当前的Actor有消息过来。</span>
     ProjectAnalyzeResultMsg projectAnalyzeResultMsg = (ProjectAnalyzeResultMsg) Await.result(future,                                            timeout.duration());
     <span class="keyword">return</span> projectAnalyzeResultMsg.getJarConflictInfoList();
} <span class="keyword">catch</span> (Exception e) {
     e.printStackTrace();
} <span class="keyword">finally</span> {
     bootstrapAnalyzeActor.tell(<span class="keyword">new</span> ActorStopMsg(), <span class="keyword">null</span>);
}
</pre></td></tr></table></figure>

<p>该思想类似于java的Future。<br>2.actor也可以终止自己,没用的actor尽量提前终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>getContext().stop(getSelf());
</pre></td></tr></table></figure>

<p>3.actor在系统中的名字必须唯一。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近又重新学习了一下akka，并且在一个web应用中成功使用了akka提升了系统的性能。我们在web应用中一般都会有dao&amp;&amp;service，这些都是spring的bean，我们定义一个actor，这个actor中可能调用dao读写数据库，也可能调用service做业务逻辑，因此我们就希望actor也是从spring容器中获取到的，这样就可以在actor中注入service&amp;&amp;dao了。</p>
]]></summary>
    
      <category term="Akka" scheme="http://yangbolin.cn/tags/Akka/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用事务的一个注意点]]></title>
    <link href="http://yangbolin.cn/2014/10/31/transaction-attention/"/>
    <id>http://yangbolin.cn/2014/10/31/transaction-attention/</id>
    <published>2014-10-31T09:12:19.000Z</published>
    <updated>2015-01-02T14:17:59.000Z</updated>
    <content type="html"><![CDATA[<p>最近在代码中配置了一个事务，事务的意思就是当前这件事情要么全部正常做完，要么全部不做。为了避免数据库中出现脏数据，我给XXX类的ff方法配置了事务。在ff方法主要做下面这几件事情</p>
<a id="more"></a>

<ul>
<li>1.从数据库中读出一批数据dataList1，此时dataList1已经存在于内存中了。</li>
<li>2.修改这一批数据，此时的修改不会写到数据库，因为事务暂时还没有提交。</li>
<li>3.根据dataList1中的数据进行判断，然后再写数据库。</li>
</ul>
<p>这么处理有问题，因为dataList1在2结束后，会发生变化，但是内存中的dataList1感知不到，也就是说3处用的dataList1还是老数据，不是2修改后的数据，因此3处的判断条件会出现问题，因为3处用到的dataList1不是事务中最新的数据。</p>
<p>修复后的步骤如下：</p>
<ul>
<li>1.从数据库中读出一批数据dataList1，此时dataList1已经存在于内存中了。</li>
<li>2.修改这一批数据，此时的修改不会写到数据库，因为事务暂时还没有提交。</li>
<li>3.从数据库中再读取一次dataList1。</li>
<li>4.根据dataList1中的数据进行判断，然后再写数据库。</li>
</ul>
<p>注意：<br>事务中对数据库进行读写操作，此时写入的数据不会写到数据库中，但是能从事务中读取到最新的数据，如果要基于某些数据做判断，最好保证判断时这些数据在事务中是最新的，不要沿用一开始就加载到内存中的那批数据，因为一开始的数据不是最新的。</p>
<p>在事务中切忌发消息给其他系统，因为这个逻辑不对，事务可能会回滚，因为数据出错啥的，但是发出去的消息没法回滚，因此一旦在事务中发消息就会破坏事务的一致性。自己在事务中发了一个消息给外部系统，事务还没有提交，外部系统收到消息后找我来查询刚才事务中产生的数据，查询DB当然就查询不到了，因为事务还没有提交，消息就已经出去了，以后在事务中切忌发消息给外部系统。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在代码中配置了一个事务，事务的意思就是当前这件事情要么全部正常做完，要么全部不做。为了避免数据库中出现脏数据，我给XXX类的ff方法配置了事务。在ff方法主要做下面这几件事情</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于log4j的additivity]]></title>
    <link href="http://yangbolin.cn/2014/10/31/log4j-additivity/"/>
    <id>http://yangbolin.cn/2014/10/31/log4j-additivity/</id>
    <published>2014-10-31T09:10:37.000Z</published>
    <updated>2014-10-31T09:36:55.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-问题描述">一.问题描述</h4>
<p>最近优化了一下一个应用的日志，但是优化后的结果不是自己想要的，简单说指定的log部分输出到了root中的appender中，部分输出到自己指定的log中。</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"BOORT"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"file"</span> <span class="attribute">value</span>=<span class="value">"xxx/boort.log"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"append"</span> <span class="attribute">value</span>=<span class="value">"true"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"encoding"</span> <span class="attribute">value</span>=<span class="value">"GBK"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> <span class="attribute">value</span>=<span class="value">"%d %-5p %c{2} - %m%n"</span> /&gt;</span>
	<span class="tag">&lt;/<span class="title">layout</span>&gt;</span>
<span class="tag">&lt;/<span class="title">appender</span>&gt;</span>
<span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"OPENAPI"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"file"</span> <span class="attribute">value</span>=<span class="value">"xxx/service/api.log"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"append"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"encoding"</span> <span class="attribute">value</span>=<span class="value">"GBK"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> <span class="attribute">value</span>=<span class="value">"%d %-5p %c{2} - %m%n"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>
<span class="tag">&lt;/<span class="title">appender</span>&gt;</span>

<span class="tag">&lt;<span class="title">logger</span> <span class="attribute">name</span>=<span class="value">"xxxx.Service"</span> <span class="attribute">additivity</span>=<span class="value">"true"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"info"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"OPENAPI"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">logger</span>&gt;</span>
<span class="tag">&lt;<span class="title">root</span>&gt;</span>
	<span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"info"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"BOORT"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"JmonitorAppender"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">root</span>&gt;</span>
</pre></td></tr></table></figure>

<p>上述xxxx.Service中的日志部分会出现到boort.log，部分会出现到api.log中。但是我们期望xxxx.Service中日志只出现到api.log中。</p>
<h4 id="二-解决方案">二.解决方案</h4>
<p>上面的问题肯定是日志配置的问题，google后发现additivity=”true”在搞鬼<br><a href="http://wiki.apache.org/logging-log4j/Log4jXmlFormat" target="_blank">log4j的配置</a><br>具体说明如下：<br><img src="http://bolinyoung.qiniudn.com/log4j-additivity.png" alt="log4j的additivity"></p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-问题描述">一.问题描述</h4>
<p>最近优化了一下一个应用的日志，但是优化后的结果不是自己想要的，简单说指定的log部分输出到了root中的appender中，部分输出到自己指定的log中。</p>
]]></summary>
    
      <category term="log4j" scheme="http://yangbolin.cn/tags/log4j/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka入门]]></title>
    <link href="http://yangbolin.cn/2014/10/25/akka-start/"/>
    <id>http://yangbolin.cn/2014/10/25/akka-start/</id>
    <published>2014-10-25T14:35:44.000Z</published>
    <updated>2014-10-25T14:55:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>为了提高一个数据计算平台的吞吐了，最近抽空看了看akka，之前听同事说akka能够提高并发吞吐量，高容错，很稳定，今天抽时间先简单看了相关的文档，写了个简单的例子，主要演示如何使用akka，当然我们也可以搭建一个akka的集群。</p>
<a id="more"></a>

<h4 id="二-快速开始">二.快速开始</h4>
<p>akka相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="comment">&lt;!--  akka starting --&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-actor_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-remote_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-kernel_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-cluster_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-contrib_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-slf4j_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.fusesource<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>sigar<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-cluster_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="comment">&lt;!--  akka ending  --&gt;</span>
</pre></td></tr></table></figure>

<p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> Msg {
    GREET, DONE, WELCOME;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object msg) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (msg == Msg.GREET) {
            System.out.println(<span class="string">"Greeter Messgae!"</span>);
            <span class="comment">// 收到GREET消息后发出一个DONE的应答</span>
            getSender().tell(Msg.DONE, getSelf());
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object arg0) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (arg0 == Msg.WELCOME) {  
            System.out.println(<span class="string">"Welcome Messgae!"</span>);
            <span class="comment">// 收到WELCOME消息后，发出一个WELCOME的应答</span>
            getSender().tell(Msg.WELCOME, getSelf());
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preStart</span>() {
        <span class="comment">// 发送WELCOME消息给welcome这个Actor</span>
        <span class="keyword">final</span> ActorRef welcome = getContext().actorOf(Props.create(Welcome.class), <span class="string">"welcome"</span>);
        welcome.tell(Msg.WELCOME, getSelf());
        
        <span class="comment">// 发送GREET消息给greet这个Actor</span>
        <span class="keyword">final</span> ActorRef greeter = getContext().actorOf(Props.create(Greeter.class), <span class="string">"greeter"</span>);
        greeter.tell(Msg.GREET, getSelf());
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object msg) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (msg == Msg.DONE) {
            System.out.println(<span class="string">"Message DONE"</span>);
            getContext().stop(getSelf());
        } <span class="keyword">else</span> {
            System.out.println(msg);
        }
    }
}
</pre></td></tr></table></figure>

<p>这里的HelloWorld，Welcome，Greeter是三个Actor，在上述代码中HelloWorld向Welcome，Greeter发消息，Welcome，Greeter收到消息后分别向HelloWorld发出回应。<br>HelloWorld在收到DONE消息后会终止自己。通过akka.Main来启动，设置启动参数com.bolin.young.akka.HelloWorld，这样就能看到相关的输出了。</p>
<h4 id="三-总结">三.总结</h4>
<p>通过上面这个小例子，我们发现akka中有一个核心的东西，那就是actor，actor之间通过消息通信，actorA发消息给actorB，actorB收到actorA的消息后，也可以对actorA发送一个回应的消息。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>为了提高一个数据计算平台的吞吐了，最近抽空看了看akka，之前听同事说akka能够提高并发吞吐量，高容错，很稳定，今天抽时间先简单看了相关的文档，写了个简单的例子，主要演示如何使用akka，当然我们也可以搭建一个akka的集群。</p>
]]></summary>
    
      <category term="Akka" scheme="http://yangbolin.cn/tags/Akka/"/>
    
      <category term="并发技术" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过开放调用来避免死锁]]></title>
    <link href="http://yangbolin.cn/2014/10/25/open-call-to-avoid-deadlock/"/>
    <id>http://yangbolin.cn/2014/10/25/open-call-to-avoid-deadlock/</id>
    <published>2014-10-25T13:00:45.000Z</published>
    <updated>2014-10-25T13:31:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在编写并发程序的时候，我们经常会在一次业务逻辑处理过程中获取多个锁，然后做一些操作，如果这多个锁的获取顺序和其他地方的获取顺序不同的话，很容易发生死锁。为了避免这种死锁，我们必须保证获取多个锁的顺序一致，或者方法调用为开放调用，即调用某个方法时不需要持有锁。</p>
<a id="more"></a>

<h4 id="二-示例分析">二.示例分析</h4>
<p>Taxi表示一个出租车对象，包含位置和目的地两个属性，Dispatcher代表一个出租车队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>class Taxi {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>)<span class="keyword">private</span> Point location, destination;
	<span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;
	<span class="keyword">public</span> <span class="title">Taxi</span>(Dispatcher dispatcher) {
		<span class="keyword">this</span>.dispatcher = dispatcher;
	}
	<span class="javadoc">/** 获取出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span>() {
		<span class="keyword">return</span> location;
	}
	<span class="javadoc">/** 设置出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span>(Point location) {
		<span class="keyword">this</span>.location = location;
		<span class="keyword">if</span> (location.equals(distination)) {
			dispatcher.notifyAvailable(<span class="keyword">this</span>);
		}
	}
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>class Dispatcher {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;
	
	<span class="keyword">public</span> <span class="title">Dispatcher</span>() {
		taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
		availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
	}
	
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span>(Taxi taxi) {
		availableTaxis.add(taxi);
	}
	<span class="javadoc">/** 获取某个时刻，整个车队的完整快照 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span>() {
		Image image = <span class="keyword">new</span> Image();
		<span class="keyword">for</span> (Taxi t : taxis) {
			image.drawMarker(t.getLocation());
		}
		<span class="keyword">return</span> image;
	}
}
</pre></td></tr></table></figure>

<p>看看上面的代码，我们就知道setLocation和notifyAvailable方法都是同步方法，调用setLocation的线程首先获取Taxi上的锁，然后获取Dispatcher的锁。getImage方法先获取Dispatcher上的锁，再获取Taxi上的锁，这两个方法被不同的线程调用时容易产生死锁，相信现在的滴滴以及快的绝对不是这么干的。</p>
<p>下面我看看如何通过开放调用来避免这个死锁的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>class Taxi {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>)<span class="keyword">private</span> Point location, destination;
	<span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;
	<span class="keyword">public</span> <span class="title">Taxi</span>(Dispatcher dispatcher) {
		<span class="keyword">this</span>.dispatcher = dispatcher;
	}
	<span class="javadoc">/** 获取出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span>() {
		<span class="keyword">return</span> location;
	}
	<span class="javadoc">/** 设置出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span>(Point location) {
		<span class="keyword">boolean</span> reachedDestination = <span class="keyword">false</span>;
		<span class="javadoc">/** 缩小缩的范围 把方法变成开发调用 **/</span>
		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) {
			<span class="keyword">this</span>.location = location;
			reachedDestination = location.equals(distination);
		}
		
		<span class="keyword">if</span> (reachedDestination) {
			dispatcher.notifyAvailable(<span class="keyword">this</span>);
		}
	}
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>class Dispatcher {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;
	
	<span class="keyword">public</span> <span class="title">Dispatcher</span>() {
		taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
		availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
	}
	
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span>(Taxi taxi) {
		availableTaxis.add(taxi);
	}
	<span class="javadoc">/** 获取每辆出租车不同时刻的位置 **/</span>
	<span class="keyword">public</span> Image <span class="title">getImage</span>() {
		Set&lt;Taxi&gt; copy;
		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) {
			copy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);
		}
		Image image = <span class="keyword">new</span> Image();
		<span class="keyword">for</span> (Taxi t : taxis) {
			image.drawMarker(t.getLocation());
		}
		<span class="keyword">return</span> image;
	}
}
</pre></td></tr></table></figure>

<p>通过上面的改造，我们把setLocation和getImage都变成了开放调用，与那些持有锁时调用外部方法的程序相比，更容易对依赖的开发调用的程序进行死锁分析。</p>
<p>在编写并发程序的时候，一定要注意一个思想，加锁范围最小化。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在编写并发程序的时候，我们经常会在一次业务逻辑处理过程中获取多个锁，然后做一些操作，如果这多个锁的获取顺序和其他地方的获取顺序不同的话，很容易发生死锁。为了避免这种死锁，我们必须保证获取多个锁的顺序一致，或者方法调用为开放调用，即调用某个方法时不需要持有锁。</p>
]]></summary>
    
      <category term="Concurrency" scheme="http://yangbolin.cn/tags/Concurrency/"/>
    
      <category term="并发技术" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[项目中的点点滴滴]]></title>
    <link href="http://yangbolin.cn/2014/10/19/project-accumulation-1/"/>
    <id>http://yangbolin.cn/2014/10/19/project-accumulation-1/</id>
    <published>2014-10-19T08:21:50.000Z</published>
    <updated>2014-10-19T10:08:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近一直在忙项目中的事情，不过在整个开发过程中自己也有一些体会，写写这些体会，就当是自己的经验了，这里不会涉及到太深的原理，只是记录一些技巧以及一些值得注意的地方，形成一些编程的思想，理念，可以更好地运用到后续的项目之中。</p>
<a id="more"></a>

<h4 id="二-关于Spring定时任务">二.关于Spring定时任务</h4>
<p>Spring定时任务在项目中经常会被使用，我们经常通过限定IP的方式保证我们自己设计的定时任务只会在一台机器上启动，关于Spring定时任务在项目中需要注意一下配置，有时候会漏写一些配置，其实没有必要死记这些配置怎么写，按照正常的思路，你需要指定要运行的任务是什么，其次，既然是定时任务，那就需要指定定时，也就是什么时候运行，最后，任务以及任务要运行的时间都有了，那么如何调度呢？也就是说运行时刻到了，谁来调度这个任务。显然配置Spring定时任务需要把握三个要素，就是上面这三个点，下面我们写一个简单的配置例子来说明一下这三个点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 1.指定要运行的任务 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"autoAuditFailedTaskJobDetail"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"concurrent"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>false<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"autoAuditFailedTask"</span> /&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">value</span>&gt;</span>execute<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
 <span class="comment">&lt;!-- 2.配置触发器 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"autoAuditFailedTaskCronTrigger"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;</span>
    <span class="comment">&lt;!-- 这里不可以直接在属性jobDetail中引用taskJob，因为他要求的是一个jobDetail类型的对象，所以我们得通过MethodInvokingJobDetailFactoryBean来转一下 --&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jobDetail"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"autoAuditFailedTaskJobDetail"</span> /&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="comment">&lt;!-- 每天晚上23:00点触发  --&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cronExpression"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">value</span>&gt;</span>0 0 23 * * ?<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="comment">&lt;!-- 3. 添加调度器 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"triggers"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">list</span>&gt;</span>
          <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"autoAuditFailedTaskCronTrigger"</span> /&gt;</span>
       <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<p>在配置的时候注意这三个点，缺一不可。</p>
<h4 id="三-关于NPE">三.关于NPE</h4>
<p>我们在写代码的时候经常会考虑NPE的问题，对于参数经常会做NPE校验，在对每一个参数做NPE校验的时候一定要想一下该参数是否一定不为NULL，不要一味地追求NPE。</p>
<h4 id="四-关于时间的加减以及格式化">四.关于时间的加减以及格式化</h4>
<p>经常有这样的需求，需要把当前时间向前或者向后推算N天，以及对时间做格式化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Calendar calendar = Calendar.getInstance();
calendar.setTime(<span class="keyword">new</span> Date());
<span class="comment">// n可以为正数，也可以为负数</span>
calendar.add(Calendar.DAY_OF_MONTH, n);
<span class="comment">// 时间格式化</span>
DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"MM/dd"</span>);
format.format(calendar.getTime());
</pre></td></tr></table></figure>

<h4 id="五-关于xstream">五.关于xstream</h4>
<p>xstream可以实现XML和Object之间的相互转换</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span>

    <span class="keyword">private</span> <span class="keyword">int</span>     age;
    <span class="keyword">private</span> SexEnum sex;
    <span class="keyword">private</span> String  name;

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>() {
        <span class="keyword">return</span> age;
    }

    <span class="keyword">public</span> SexEnum <span class="title">getSex</span>() {
        <span class="keyword">return</span> sex;
    }

    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span>(<span class="keyword">int</span> age) {
        <span class="keyword">this</span>.age = age;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span>(SexEnum sex) {
        <span class="keyword">this</span>.sex = sex;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> SexEnum {
    MALE(<span class="string">"M"</span>), FEMALE(<span class="string">"F"</span>);

    String value;

    SexEnum(String value){
        <span class="keyword">this</span>.value = value;
    }

    <span class="keyword">public</span> String <span class="title">getValue</span>() {
        <span class="keyword">return</span> value;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(String value) {
        <span class="keyword">this</span>.value = value;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> SexEnum <span class="title">parse</span>(String value) {
        <span class="keyword">for</span> (SexEnum sexEnum : SexEnum.values()) {
            <span class="keyword">if</span> (value.equals(sexEnum.getValue())) {
                <span class="keyword">return</span> sexEnum;
            }
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XStreamTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="comment">// Object TO XML</span>
        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();
        Person person1 =  <span class="keyword">new</span> Person();
        person1.setAge(<span class="number">22</span>);
        person1.setName(<span class="string">"nuaa"</span>);
        person1.setSex(SexEnum.MALE);
        personList.add(person1);
        
        Person person2 =  <span class="keyword">new</span> Person();
        person2.setAge(<span class="number">22</span>);
        person2.setName(<span class="string">"buaa"</span>);
        person2.setSex(SexEnum.MALE);
        personList.add(person2);
        
        XStream xstream = <span class="keyword">new</span> XStream();
        <span class="comment">// 使用别名</span>
        xstream.alias(<span class="string">"person"</span>, Person.class);
        xstream.alias(<span class="string">"personList"</span>, List.class);
        <span class="comment">// 注册枚举转换器</span>
        xstream.registerConverter(<span class="keyword">new</span> AbstractSingleValueConverter(){
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span>(@<span class="title">SuppressWarnings</span>("rawtypes") Class type) {
                <span class="keyword">if</span> (type.equals(SexEnum.class)) {
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                }
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
            <span class="comment">// String转换成对象</span>
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> Object <span class="title">fromString</span>(String str) {
                <span class="keyword">return</span> SexEnum.parse(str);
            }

            <span class="comment">// 对象转换成String</span>
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> String <span class="title">toString</span>(Object obj) {
                SexEnum sexEnum = (SexEnum)obj;
                <span class="keyword">return</span> sexEnum.getValue();
            }
        });
        
        String xml = xstream.toXML(personList);
        System.out.println(xml);

        <span class="comment">// XML TO Object</span>
        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
        List&lt;Person&gt; fromXMLList = (List&lt;Person&gt;)xstream.fromXML(xml);
        System.out.println(fromXMLList);
        <span class="keyword">for</span>(Person person : fromXMLList) {
            System.out.println(<span class="string">"#############################"</span>);
            System.out.println(<span class="string">"age: "</span> + person.getAge());
            System.out.println(<span class="string">"sex: "</span> + person.getSex());
            System.out.println(<span class="string">"name: "</span> + person.getName());
        }
    }
}
</pre></td></tr></table></figure>

<p>使用xtream可以避免自己解析XML文件。</p>
<h4 id="六-关于fastjson">六.关于fastjson</h4>
<p>fastjson把对象转化成json字符串时会出现$ref，这是由于对象之间有循环引用导致，这有可能导致堆栈溢出，我们可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>JSON.toJSONString(object,  SerializerFeature.DisableCircularReferenceDetect)
</pre></td></tr></table></figure>

<p>来避免json串中出现$ref。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近一直在忙项目中的事情，不过在整个开发过程中自己也有一些体会，写写这些体会，就当是自己的经验了，这里不会涉及到太深的原理，只是记录一些技巧以及一些值得注意的地方，形成一些编程的思想，理念，可以更好地运用到后续的项目之中。</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用BTrace监控方法入参]]></title>
    <link href="http://yangbolin.cn/2014/10/12/btrace-for-exception/"/>
    <id>http://yangbolin.cn/2014/10/12/btrace-for-exception/</id>
    <published>2014-10-12T10:06:18.000Z</published>
    <updated>2014-11-08T07:20:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>昨天在生产环境出现一个类的方法被调用然后出现了异常，这个异常没有被catch而是直接抛给上层的调用，我们想知道抛异常时调用该方法的参数是什么样子的，然后根据这个参数分析问题聚图出现在什么地方。</p>
<a id="more"></a>

<p>为了能够清晰的说明问题，这里大致描述一下昨天出问题的类的代码结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxUtil</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">decodeXxx</span>(String sSrc, String sSkey,String iVParam) <span class="keyword">throws</span> Exception {
	<span class="comment">// 在这里做解码，然后在这里抛异常了</span>
	}
}
</pre></td></tr></table></figure>

<p>静态方法decodeXxx被调用时，在方法内部抛出了没有被catch住的异常，这就是基本现象。</p>
<h4 id="二-排查过程">二.排查过程</h4>
<p>我们需要知道调用decodeXxx方法是参数是什么样子的，生成环境没法DEBUG只能考虑使用BTrace脚本了，使用BTrace动态监控decodeXxx的调用，然后输出方法调用的参数，于是我准备了如下的BTrace脚本，此时所有decodeXxx方法的调用都会被监控到，如何区分有异常的case呢？我们日志中记录的异常以及异常发生的时间，因此我们需要在监控脚本中输出监控时间，然后和日志中异常发生的时间对比，找出最终出现问题的方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;
<span class="keyword">import</span> com.sun.btrace.annotations.*;
<span class="keyword">import</span> com.sun.btrace.AnyType;

<span class="annotation">@BTrace</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceMethodArgsAndReturn</span>{</span>

        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>,
        location=<span class="annotation">@Location</span>(Kind.RETURN)
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"Call xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
                <span class="comment">// 输出时间,这里之所以输出时间就是为了和日志中的时间对比寻找出错时方法调用的入参，日志中记录了异常时间</span>
                println(strcat(<span class="string">"time is:"</span>,str(timeMillis()));
        }
}
</pre></td></tr></table></figure>

<p>脚本准备好了，然后在线上和JVM建立链接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sudo -u admin /home/boris<span class="preprocessor">.yangbl</span>/btrace/bin/btrace -<span class="keyword">cp</span> /home/boris<span class="preprocessor">.yangbl</span>/btrace/build <span class="number">8485</span> TraceMethodArgsAndReturn<span class="preprocessor">.java</span>
</pre></td></tr></table></figure>

<p>其中8485是JVM的PID。<br>执行命令后，监控确实被监控到了，但是方法内部抛异常的case没有被监控到，奇怪，此时子写检查上面的监控脚本，发现location=@Location(Kind.RETURN)，这说明方法返回时才会被监控到，要是方法抛异常了，方法的return字节码压根就不会被调用，要是方法的return字节码不会被调用，那BTrace动态增加的字节码也不会被调用，因此需要修改一下BTrace脚本了，输出的时候不要限制方法返回，现在把BTrace脚本修改如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;
<span class="keyword">import</span> com.sun.btrace.annotations.*;
<span class="keyword">import</span> com.sun.btrace.AnyType;

<span class="annotation">@BTrace</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceMethodArgsAndReturn</span>{</span>

        <span class="comment">// 方法返回时的监控</span>
        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>,
        location=<span class="annotation">@Location</span>(Kind.RETURN)
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"return xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
        }
        <span class="comment">// 进入方法的监控</span>
        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"enter xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
        }
}
</pre></td></tr></table></figure>

<p>修改成上面的监控脚本后，我们都不需要在脚本中输出监控时间了，要是有方法抛异常的化了，必然会出现只有enter(进入方法的监控)没有return(方法返回时的监控)的输出，由于线上有两台机器，因此同时在这两台机器上使用了这个BTrace脚本，最终定位到了decodeXxx方法内部抛出异常时方法的入参是什么。后面的分析和业务有关，这里不做过多解释。</p>
<h4 id="三-最后总结">三.最后总结</h4>
<p>location=@Location(Kind.RETURN)要是方法内部出现异常的话，此时被BTrace修改后的字节码就没法执行了。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>昨天在生产环境出现一个类的方法被调用然后出现了异常，这个异常没有被catch而是直接抛给上层的调用，我们想知道抛异常时调用该方法的参数是什么样子的，然后根据这个参数分析问题聚图出现在什么地方。</p>
]]></summary>
    
      <category term="BTrace" scheme="http://yangbolin.cn/tags/BTrace/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA线程本地存储之ThreadLocal的分析]]></title>
    <link href="http://yangbolin.cn/2014/10/07/thread-local-analyze/"/>
    <id>http://yangbolin.cn/2014/10/07/thread-local-analyze/</id>
    <published>2014-10-07T13:01:03.000Z</published>
    <updated>2014-10-07T13:07:13.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ThreadLocal是JDK的一个线程本地存储的类，我们可以把一些线程私有的数据写在ThreadLocal中，这样这些数据只有一个线程可见，实现了所谓的栈封闭。这样存储一些线程私有的数据，我们就不用去费心考虑如何保证临界资源的互斥访问了，同时对于一个线程，这些私有数据也只做一次初始化。</p>
<a id="more"></a>

<h4 id="二-一段ThreadLocal的测试代码">二.一段ThreadLocal的测试代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>class LocalObject {
    <span class="keyword">private</span> String name;
    
    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}

class LocalStoreThread extends Thread {
    <span class="javadoc">/** 定义了一个线程本地存储的成员变量 **/</span>
    <span class="keyword">private</span> ThreadLocal&lt;LocalObject&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;LocalObject&gt;();

    <span class="keyword">public</span> <span class="title">LocalStoreThread</span>(LocalObject lo) {
        threadLocal.set(lo);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        System.out.println(threadLocal.get().getName());
    }
}

<span class="javadoc">/**
 * &lt;pre&gt;
 * 创建一个线程实例，这个线程实例中有一个线程本地存储成员变量
 * &lt;/pre&gt;
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        LocalObject lo = <span class="keyword">new</span> LocalObject();
        lo.setName(<span class="string">"thread-local"</span>);
        <span class="keyword">new</span> LocalStoreThread(lo).start();
    }
}
</pre></td></tr></table></figure>

<p>上述代码运行的时候在run方法中抛出了空指针异常，明明在构造函数中调用了threadLocal的set方法，为什么get的时候获取到了null,然后使用了null抛出了NPE呢？</p>
<p>由于ThreadLocal是和线程相关的，我们上面的代码在够在函数中往线程本地存储变量中设置了一个实例对象，在run方法中获取这个实例对象的时候发现拿到是null,所以我们有必要看一下set时对应的线程和get时对应的线程是不是一样的。因此在set之前打印一下Thread.currentThread()，同时在get之前打印一下Thread.currentThread()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>class LocalObject {
    <span class="keyword">private</span> String name;
    
    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}

class LocalStoreThread extends Thread {
    <span class="javadoc">/** 定义了一个线程本地存储的成员变量 **/</span>
    <span class="keyword">private</span> ThreadLocal&lt;LocalObject&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;LocalObject&gt;();

    <span class="keyword">public</span> <span class="title">LocalStoreThread</span>(LocalObject lo) {
        <span class="comment">// set之前打印当前线程</span>
        System.out.println(Thread.currentThread().getName());   <span class="comment">// main</span>
        threadLocal.set(lo);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="comment">// get之前打印当前线程</span>
        System.out.println(Thread.currentThread().getName()); <span class="comment">// Thread-0</span>
        System.out.println(threadLocal.get().getName());
    }
}

<span class="javadoc">/**
 * &lt;pre&gt;
 * 创建一个线程实例，这个线程实例中有一个线程本地存储成员变量
 * &lt;/pre&gt;
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        LocalObject lo = <span class="keyword">new</span> LocalObject();
        lo.setName(<span class="string">"thread-local"</span>);
        <span class="keyword">new</span> LocalStoreThread(lo).start();
    }
}
</pre></td></tr></table></figure>

<p>好，问题出现了，set时的当前线程和get时的当前线程不一样，所以get的结果是null。set是写在线程的构造函数中的，此时当前线程是main线程，因为在main线程中创建线程。但是在run方法中当前线程已经不是main线程了变成了new出来的这个新线程了。</p>
<h4 id="三-ThreadLocal中get和set方法分析">三.ThreadLocal中get和set方法分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">public</span> T <span class="title">get</span>() {
        <span class="comment">// 获取当前线程实例</span>
        Thread t = Thread.currentThread();
        <span class="comment">/* 获取当前线程实例的ThreadLocalMap，其实就是一个数组
         * 这个数组可以扩容，每次空间不够时都拿当前大小*2
         */</span>
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {
            <span class="comment">/*根据this哈希获取数组中的一个元素*/</span>
            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);
            <span class="keyword">if</span> (e != <span class="keyword">null</span>)
                <span class="keyword">return</span> (T)e.value;
        }
        <span class="comment">// 如果当前线程的ThreadLocalMap为null,就创建一个</span>
        <span class="keyword">return</span> setInitialValue();
}
<span class="keyword">private</span> T <span class="title">setInitialValue</span>() {
        <span class="comment">/* 这里调用了ThreadLocal的initValue方法，一般都会在创建ThreadLocal
         * 实例的时候重写这个方法，比如说ThreadLocal中要是存放数据库链接对象的
         * 话，就需要一个初始化方法来初始化这个数据库链接对象
         */</span>
        T value = initialValue();
        <span class="comment">/*把初始化好的值保存起来*/</span>
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>)
            map.set(<span class="keyword">this</span>, value);
        <span class="keyword">else</span>
            createMap(t, value);
        <span class="keyword">return</span> value;
}
<span class="comment">/*创建线程的ThreadLocalMap*/</span>
<span class="keyword">void</span> createMap(Thread t, T firstValue) {
        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);
}
<span class="comment">/*获取线程的ThreadLocalMap*/</span>
ThreadLocalMap getMap(Thread t) {
        <span class="keyword">return</span> t.threadLocals;
}
</pre></td></tr></table></figure>

<p>上述代码就是ThreadLocal的get源代码，先根据当前线程获取当前线程的ThreadLocalMap,此时获取到的就是一个table数组，接下来根据ThreadLocal实例的threadLocalHashCode来获取table数组中的一个元素，这个元素是个K-V的键值对，此时V就是本地存储的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">/*关于set代码和get代码是对称的*/</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>)
            map.set(<span class="keyword">this</span>, value);
        <span class="keyword">else</span>
            createMap(t, value);
}
</pre></td></tr></table></figure>

<h4 id="四-ThreadLocal源代码中提供的一个实例代码">四.ThreadLocal源代码中提供的一个实例代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueThreadIdGenerator</span> {</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger uniqueId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);  

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal &lt; Integer &gt; uniqueNum =   
            <span class="keyword">new</span> ThreadLocal &lt; Integer &gt; () {  
        <span class="comment">//定义初始值（副本）  </span>
        <span class="annotation">@Override</span> <span class="keyword">protected</span> Integer <span class="title">initialValue</span>() {  
            <span class="keyword">return</span> uniqueId.getAndIncrement();  
        }  
    };  

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCurrentThreadId</span>() {  
        <span class="comment">// 这里应该要把 uniqueId换成uniqueNum，源码应该是写错了   </span>
        <span class="keyword">return</span> uniqueNum.get();  
    }

    <span class="keyword">static</span> class MyThread extends Thread {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
            System.out.println(UniqueThreadIdGenerator.getCurrentThreadId());
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {
            <span class="keyword">new</span> MyThread().start();
        }
    }
}
</pre></td></tr></table></figure>

<p>这里总共创建了5个线程，每个线程在run方法中调用UniqueThreadIdGenerator.getCurrentThreadId()时，发现每个线程的ThreadLocalMap都是null,所以每次初始化的方法initialValue都会被调用。</p>
<h4 id="五-Thread&amp;&amp;ThreadLocal&amp;&amp;ThreadLocalMap之间的关系">五.Thread&amp;&amp;ThreadLocal&amp;&amp;ThreadLocalMap之间的关系</h4>
<p><img src="http://dl.iteye.com/upload/attachment/0084/5636/079ae373-cc30-3a5e-8890-496018582ca0.bmp" alt="图示"></p>
<h4 id="六-总结">六.总结</h4>
<p>一个线程只有一个ThreadLocalMap,其实ThreadLocalMap就是一个table数组，数组中的每个元素都是一个K-V的键值对，其中K就是ThreadLocal实例，在获取本地存储的值的时候根据ThreadLocal实例的threadLocalHashCode来对table进行Hash查找，找到对应的K-V键值对。一个线程可以有多个ThreadLocal实例，那么有多少个ThreadLocal实例就决定了table数组的大小，这个数组是动态增长的，每次要是大小不够，就自动扩充为原来大小的2倍，然后对于原来的元素重新Hash,这个操作的成本还是很大的。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ThreadLocal是JDK的一个线程本地存储的类，我们可以把一些线程私有的数据写在ThreadLocal中，这样这些数据只有一个线程可见，实现了所谓的栈封闭。这样存储一些线程私有的数据，我们就不用去费心考虑如何保证临界资源的互斥访问了，同时对于一个线程，这些私有数据也只做一次初始化。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[幂等性&&数据库的锁]]></title>
    <link href="http://yangbolin.cn/2014/10/07/idempotency-and-db-lock/"/>
    <id>http://yangbolin.cn/2014/10/07/idempotency-and-db-lock/</id>
    <published>2014-10-07T10:52:48.000Z</published>
    <updated>2014-10-07T11:31:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-幂等性">一.幂等性</h4>
<p>幂等性是高等代数中的概念，这里不是讨论数学上幂等性的概念，而是讨论程序中幂等性。幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的. 声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试.</p>
<a id="more"></a>

<p>比如系统A提供了接口f1给系统B调用，系统B调用了系统A提供的f1接口，发现超时，然后再调用一次，超时可能是由于系统A处理的有点慢导致，此时系统A会感知到接口f1的两次调用，如果f1是给用户的账户增加10000RMB的话，这样的场景可能会导致最终给用户增加了N*10000RMB(N&gt;1)，此时接口f1就需要做幂等性处理，不管这个请求重复调用多少次，最终只会给用户增加10000RMB，首先我们需要从业务层面去思考看能否解决这个问题，一般的业务都会根据业务逻辑推算出那些重复请求的，实在推算不出的话，我们就需要做额外的处理了，要求调用方调用f1的时候传递一个唯一性的请求标识进来，系统A感知到f1的调用后，会先查当前请求标识是否已经被接受，如果被接收的话，先看是处理中还是已经完成，如果是这两个状态中的任何一个，我们都认为是重复调用。要是查不到记当前请求被接受的记录的话，先插入一条当前请求被接受的记录，并且状态记录为处理中，然后再去处理请求，此时如果请求处理成功就把请求被接受的记录状态修改为处理成功，要是处理失败就把请求被接受的记录删除。如果处理成功就把当前请求被接受的记录状态修改为处理成功。</p>
<h4 id="二-数据库锁">二.数据库锁</h4>
<p>我们在写代码的时候经常会遇到这样的场景，从数据库中读取一批数据出来，然后根据一些逻辑条件修改这批数据，修改完后写回到数据库中，我们读出数据进行逻辑处理时，数据库中的这些数据可能已经发生变化了。为了保证上面数据的正确性，我们需要引入数据库的锁来解决这个问题即select for update锁，先对需要修改的记录加锁，等数据库事务提交后再把锁释放，这个过程中其他对数据的修改要先拿到这个锁才能继续做写操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> XXXTable <span class="keyword">WHERE</span> conditions <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span>
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-幂等性">一.幂等性</h4>
<p>幂等性是高等代数中的概念，这里不是讨论数学上幂等性的概念，而是讨论程序中幂等性。幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的. 声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试.</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM常用命令总结]]></title>
    <link href="http://yangbolin.cn/2014/09/17/jvm-cmd/"/>
    <id>http://yangbolin.cn/2014/09/17/jvm-cmd/</id>
    <published>2014-09-17T11:38:19.000Z</published>
    <updated>2014-11-19T13:36:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="GC相关">GC相关</h4>
<p>jstat -gcutil pid time<br>实时查看JAVA进程PID的垃圾回收情况，PID表示JAVA进程的ID，time表示统计的时间频率，单位是ms，比如jstat -gcutil 8888 1000 表示每隔1000ms统计一次JAVA进程8888的GC回收。</p>
<a id="more"></a>

<h4 id="内存相关">内存相关</h4>
<p>jmap -dump:format=b,file=/home/admin/xxx.bin PID<br>获取JVM的内存的dump文件</p>
<p>jinfo -flag +HeapDumpBeforeFullGC PID<br>jinfo -flag +HeapDumpAfterFullGC PID<br>设置这两个标记后，可以让JVM在发生FGC前后自动dump堆内存，等dump完后，执行下面的命令去掉这两个标记<br>jinfo -flag -HeapDumpBeforeFullGC PID<br>jinfo -flag -HeapDumpAfterFullGC PID<br>在dump结束后，记得去掉这两个标记</p>
<p>jmap -histo:live PID<br>查看系统中存活的实例数目</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="GC相关">GC相关</h4>
<p>jstat -gcutil pid time<br>实时查看JAVA进程PID的垃圾回收情况，PID表示JAVA进程的ID，time表示统计的时间频率，单位是ms，比如jstat -gcutil 8888 1000 表示每隔1000ms统计一次JAVA进程8888的GC回收。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[裂变思想]]></title>
    <link href="http://yangbolin.cn/2014/09/06/fission-thought/"/>
    <id>http://yangbolin.cn/2014/09/06/fission-thought/</id>
    <published>2014-09-06T02:49:07.000Z</published>
    <updated>2014-09-06T03:16:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>关于裂变这个词语，一开始想到的就是双11的时候红包的裂变，一个红包经过裂变后变成多个红包，让更多的人参与进来，这个红包裂变的想法当时就给自己留下了深刻的印象，其实这不是什么业务的创新，而是算法思想在业务上的经典使用。</p>
<a id="more"></a>

<p>在算法中一个经典的思想就是分治，要解决一个问题A，先把问题A分解为A1，A2，A3三个子问题，这三个子问题解决了，问题A也就得到相应的解决，此时可以理解为问题A在需要解决的时候裂变成3个子问题。问题变多了，但是原来的问题更好解决了，因此在这种状况下面问题变多不一定是坏事情。</p>
<h4 id="二-裂变">二.裂变</h4>
<p>当一些业务点没法在一个实体体现出来的时候，考虑把这个实体裂变，然后修改裂变后实体的相关状态以满足业务需求，此时实体A裂变成两个实体A1和A2，裂变后实体A就不存在了，但是通过A1和A2上的一些关联信息一定能推理出A1和A2是实体A裂变而来的。<br><img src="http://bolinyoung.qiniudn.com/%E8%A3%82%E5%8F%98.png" alt="裂变"></p>
<h4 id="三-总结">三.总结</h4>
<p>在设计的时候注意裂变思想的灵活使用，虽然很简单，但是能不能灵活使用是另外一个问题。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>关于裂变这个词语，一开始想到的就是双11的时候红包的裂变，一个红包经过裂变后变成多个红包，让更多的人参与进来，这个红包裂变的想法当时就给自己留下了深刻的印象，其实这不是什么业务的创新，而是算法思想在业务上的经典使用。</p>
]]></summary>
    
      <category term="Algorithm" scheme="http://yangbolin.cn/tags/Algorithm/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次velocity异常的分析]]></title>
    <link href="http://yangbolin.cn/2014/08/22/velocity-exception-analyze/"/>
    <id>http://yangbolin.cn/2014/08/22/velocity-exception-analyze/</id>
    <published>2014-08-22T14:05:14.000Z</published>
    <updated>2014-08-22T16:41:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>最近在使用velocity模板的时候RuntimeInstance的1103行代码出现了NPE,如下图所示<br><img src="http://bolinyoung.qiniudn.com/velocity-npe.png" alt="velocity-npe"><br>该行代码一直在抛NPE。</p>
<a id="more"></a>

<h4 id="二-分析">二.分析</h4>
<p>RuntimeInstance的1103行出现NPE原因只有一个，那就是parserPool是NULL，现在我们只要搞清楚parserPool为啥在这里是NULL，我们就知道这个NPE出现的原因了，看上面的图，我们发现在执行1103行代码的时候调用了requireInitialization()，那么此时需要看看requireInitialization()到底做了那些事情。<br><img src="http://bolinyoung.qiniudn.com/requireInitialization.png" alt="requireInitialization"><br>我们看到了requireInitialization中调用了init方法，但是这个方法可能抛出异常。关于requireInitialization方法中的代码很有疑问，首先想到的是并发问题，这里怎么没考虑到多个线程并发初始化的问题呢？其次，initialized标识当前实例是否已经被初始化了，能进入到if分支中，说明当前实例肯定没有被初始化，因此initialized值一定是false，initializing标识当前实例正在被初始化,能进入到if分支中，说明当前实例没有被正在初始化，因此initializing的值一定是false。接下来我们看看init的代码<br><img src="http://bolinyoung.qiniudn.com/init.png" alt="init"><br>一开始怀疑并发的问题，看了init的代码后，这个点就不用再去怀疑了。init中也有一个if分支，进入if分支的逻辑和requireInitialization进入if分支的逻辑是一样的，这里就不再进行分析了，关键看2处的代码，此时会标记当前实例正在被初始化，加入initializeParserPool()方法中抛出了一个Exception，此时下面的代码就不会被执行，当前方法栈帧直接退出，当前线程获取的锁也会被释放(后面给出验证的例子)，此时initializing值没有机会设置成false了，也就是说3处的代码没法机会执行了，直接回到requireInitialization方法中，该方法中捕获了这个异常，此时问题就出现了，等下次再初始化的时候requireInitialization中的init方法永远就不会被调用了，此时1103行代码就一直NPE了，由于错过了第一次init时的真正异常，后面看到就一直是NPE，不知道NPE的具体原因是啥了，也就是说requireInitialization中catch住的异常后续发现不了。</p>
<h4 id="三-解决思路">三.解决思路</h4>
<p>通过上面的分析，我们只要找到requireInitialization中catch住的异常是啥，问题也就差不多解决了，因为第一次初始化的时候异常已经发生了，后续的初始化都不会进入到requireInitialization中的if分支了，此时要么重启系统去看第一初始化时异常是什么，要么找日志，debug神器中可以动态修改变量的值，那么在requireInitialization的if分支处设置断点，然后动态修改initializing的值为false,此时异常出现了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Failed <span class="built_in">to</span> initialize <span class="operator">an</span> instance <span class="operator">of</span> org.apache.velocity.runtime.<span class="built_in">log</span>.Log4JLogChute <span class="operator">with</span> <span class="operator">the</span> current runtime configuration.
</pre></td></tr></table></figure>

<p> 异常信息表明可能log有问题，因为出现Log4J关键词了，这个异常很陌生，不知如何解决，直接去谷歌一下就能解决问题，一般参考stackoverflow上的答案，有人说在velocity引擎初始化的时候增加下面代码即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Properties p = <span class="keyword">new</span> Properties();
p.setProperty(<span class="string">"runtime.log.logsystem.class"</span>, <span class="string">"org.apache.velocity.runtime.log.NullLogSystem"</span>);
<span class="keyword">try</span> {
      INSTANCE.init(p);
} <span class="keyword">catch</span> (Exception e) {
      LOG.error(e);
}
</pre></td></tr></table></figure>

<p>索性试一下，发现问题解决啦。</p>
<h4 id="四-总结">四.总结</h4>
<p>1.个人认为RuntimeInstance的requireInitialization方法有BUG，应该增加finally分支，在该分支中把initializing设置为false，后续可以考虑修复一下velocity的这个BUG，在开源项目中贡献一些代码。<br>2.遇见陌生异常时记得谷歌，记得stackoverflow。<br>3.在分析的过程中，自己突然想到一个问题，synchronized修饰的方法内部抛出Exception后当前线程获取到锁会不会释放，答案是会释放，深层次的分析估计要看JVM源码了，这里给出验证的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> {</span>

    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span>() <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (<span class="keyword">true</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"test exception"</span>);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        SynchronizedTest oo = <span class="keyword">new</span> SynchronizedTest();
        
        <span class="keyword">new</span> ThreadModel1(oo).start();
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">1000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        <span class="keyword">new</span> ThreadModel2(oo).start();
    }
}

class ThreadModel1 extends Thread {

    <span class="keyword">private</span> SynchronizedTest synchronizedTest;
    <span class="keyword">public</span> <span class="title">ThreadModel1</span>(SynchronizedTest synchronizedTest) {
        <span class="keyword">this</span>.synchronizedTest = synchronizedTest;
    }
    
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">try</span> {
            synchronizedTest.init();
        } <span class="keyword">catch</span> (Exception e) {
            System.out.println(<span class="string">"ThreadModel1 Exception..."</span>);
            <span class="keyword">while</span>(<span class="keyword">true</span>) {}
        }
    }
}

class ThreadModel2 extends Thread {

    <span class="keyword">private</span> SynchronizedTest synchronizedTest;
    <span class="keyword">public</span> <span class="title">ThreadModel2</span>(SynchronizedTest synchronizedTest) {
        <span class="keyword">this</span>.synchronizedTest = synchronizedTest;
    }
    
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">try</span> {
            synchronizedTest.init();
        } <span class="keyword">catch</span> (Exception e) {
            System.out.println(<span class="string">"ThreadModel2 Exception..."</span>);
        }
    }
}
</pre></td></tr></table></figure>

<p>输出结果:<br>ThreadModel1 Exception…<br>ThreadModel2 Exception…</p>
<p>ThreadModel2线程能继续运行并且输出结果，说明init上的锁已经被ThreadModel1线程所释放。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>最近在使用velocity模板的时候RuntimeInstance的1103行代码出现了NPE,如下图所示<br><img src="http://bolinyoung.qiniudn.com/velocity-npe.png" alt="velocity-npe"><br>该行代码一直在抛NPE。</p>
]]></summary>
    
      <category term="velocity" scheme="http://yangbolin.cn/tags/velocity/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次JVM分享的相关记录]]></title>
    <link href="http://yangbolin.cn/2014/08/16/a-jvm-share/"/>
    <id>http://yangbolin.cn/2014/08/16/a-jvm-share/</id>
    <published>2014-08-16T07:44:15.000Z</published>
    <updated>2014-09-09T03:46:50.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近看见公司一位前辈有分享JVM相关的知识，自己特地从跑过去听了一下，感觉讲的不是很深入，但是相对来说还是不错的，本文就自己听到的一些东西做一个简单的总结。平时我们大多数都是用JAVA写代码,很多人学JAVA都是从HelloWorld开始，但是从你写HelloWorld代码到最终输出HelloWorld到底发生那些事情呢？要想清楚的回答这个问题，并不是很容易，你需要对JVM有一个清晰的了解后，才能说清楚这个问题，这只是一个引子，本文也不去挑战这个问题，这里主要记录一下自己从这个分享中听到的一些感兴趣的东西。</p>
<a id="more"></a>

<h4 id="二-JVM运行时数据区">二.JVM运行时数据区</h4>
<p><img src="http://bolinyoung.qiniudn.com/jvmdataarea.png" alt="JVM运行时数据区"></p>
<p>JVM运行时数据区域分为堆内存和非堆内存。注意这里的程序计数器，和CPU没有关系，不要看见Register就认为是CPU的寄存器，每个方法都会由一系列的字节码组成，这里的PC指向的是当前要执行的字节码，执行完字节码后，PC就会向前移动。</p>
<h4 id="三-类初始化">三.类初始化</h4>
<p>在JAVA代码中，我们经常写class，JVM加载一个类的时候，先会初始化一个类实例，这个初始化好的类实例存储在perm区中，注意这个类实例不是我们在代码中new出来的对象实例，我们在代码中new出来的对象实例是存储在堆内存中的，也就是说new一个对象的实例和类实例是存储在不同地方的。</p>
<p><img src="http://bolinyoung.qiniudn.com/classinitprocess.png" alt="类初始化的过程"></p>
<p>类初始化的过程总体上分为Load,Link,Initialize三个阶段，当代码中需要某个类的时候，JVM先会在classpath中尝试去找，如果找不到相应的类，此时会抛出ClassNotFoundException，如果能找到相应的类，就会看这类是否有使用其他的类，有的话，又会去加载当前类依赖的类，接下来会做Link，其实和C/C++编译时的Link是一样的，把当前类所需要的其他类放在一起，看看会不会有问题，Link分为三个阶段，字节码校验，当然这个校验可以通过JVM参数去掉，即verify，prepare阶段会对类的静态成员变量做初始化，比如int会被初始化为0,引用类型会被初始化为null，resolve阶段就是看看当前类所依赖的其他类有没有问题，比如classA依赖classB，在classA中使用classB中的方法f，此时会校验classB中方法f是否存在。最后就是Initialize了，这里的Initialize其实就是执行clinit方法。</p>
<p>注意Link中的Prepare阶段会对类静态成员初始化，我们new一个实例的时候，类的非静态成员变量也有类似初始化的过程，但是这两个初始化不是发生在同一个阶段，new的时候会在堆内存上分配内存空间，此时也会对非静态成员变量做初始化。</p>
<p>下面我们来分析一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span> {</span>

    <span class="keyword">static</span> {
        a = <span class="number">1</span>;
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  a = <span class="number">0</span>;
	
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        System.out.println(StaticCode.a);
    }
}
</pre></td></tr></table></figure>

<p>这段代码的输出结果是什么？<br>首先考虑这段代码会不会有编译的问题，提前使用了静态成员变量a。自己编译一下就知道了，这段代码不会有编译的问题。输出结果是0。自己运行一下就知道了。但是为啥结果是0呢？我们来分析一下字节码，看看为啥结果是0<br>使用javap -verbose来查看字节码，注意字节码中静态代码块<br><img src="http://bolinyoung.qiniudn.com/staticcode-0.png" alt="StaticCode中的静态代码块"><br>其实这个静态代码块对应的方法就是clinit方法。这个方法中有5条字节码指令，偏移量0和1处的字节码表示获取常量1并且赋值给静态成员变量i,这两个字节码指令从哪里来的呢？就是声明静态代码块中对静态成员变量a的赋值操作。偏移量4和5处的字节码表示声明静态成员变量a时的赋值操作，此时这个赋值操作排在静态代码块中赋值操作的后面，因此输出结果为0。</p>
<p>对于上述代码块，如果我们把static代码块的顺序静态成员变量声明的顺序改变一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span> {</span>

	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  a = <span class="number">0</span>;
	
    <span class="keyword">static</span> {
        a = <span class="number">1</span>;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        System.out.println(StaticCode.a);
    }
}
</pre></td></tr></table></figure>

<p>此时输出结果为1,因为静态成员变量的声明排在静态代码块的前面，此时静态成员变量声明时的赋值字节码会出现静态代码块中赋值字节码的后面，再看看相关的字节码就能发现<br><img src="http://bolinyoung.qiniudn.com/staticcode-0-latter.png" alt="改变顺序后的字节码"></p>
<p>关于静态代码块中的字节码和静态成员变量赋值的字节码谁先执行谁后执行，取决于java代码中静态成员变量和静态代码块出现的先后顺序。</p>
<p>再看一个对象实例化的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>
	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">12</span>;
	<span class="keyword">public</span> <span class="title">Base</span>() {
		foo();
	}
	
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>() {
		System.out.println(i);
	}
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> {</span>
	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">13</span>;
	
	<span class="keyword">public</span> <span class="title">Child</span>() {
	}
	
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>() {
		System.out.println(i);
	}
	
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		<span class="keyword">new</span> Child();
	}
}
</pre></td></tr></table></figure>

<p>这段代码很简单，在基类构造函数中调用foo方法，这个方法被派生类重写了，此时输出结果为多少？<br>运行发现此时输出结果为0,首先我们new Child()后在基类构造函数中调用的foo方法一定是在派生类中重写过的foo方法，因为当前实例对象是派生类类型的，初始化实例的时候都是先初始化父类，再初始化子类，这是关键，初始化父类的时候子类还没有初始化好，但是调用子类的foo方法，此时i的值是在分配内存空间时初始化的值，int类型的被初始化为0,因此输出结果为0。我们再来分析一下Child类构造函数的字节码。<br><img src="http://bolinyoung.qiniudn.com/ChildByteCode.png" alt="Child类构造函数字节码"><br>JVM调用每个方法的时候都会给这个方法创建一个方法栈帧，每个方法栈帧都包含一个局部变量表，一个操作数栈，当然还有其他的比如堆栈映射表。局部变量表其实就是一个数组，实例方法中局部变量表的第一元素表示当前实例this，我们看看Child构造函数的字节码发现第一条就是aload_0，表示把局部变量表的第0个元素放到栈顶，也就是this引用放到栈的顶部，然后执行invokespecial，即调用父类的构造函数，调用结束后，栈顶的this引用会被弹出，因此需要继续给栈顶压一个this引用，因为后面要对成员变量i赋值，执行aload_0后就能把this引用再次压入到栈顶部，bipush 13标识把13转换成int型的值，然后压入到栈的顶部，putfield表示弹出栈顶的整型值，赋值给成员变量i，此时栈顶部就是this引用了，this引用也会被弹出，因为赋值的时候需要知道变量i是哪个实例的成员变量。分析完这段字节码后，输出结果为0也就很好解释了。因为调用基类构造函数时，派生类成员变量i的赋值还没有进行。</p>
<p>JVM有一个限制，不允许多个线程去初始化同一个类，当一个线程初始化ClassA的时候，另外一个线程要是也来初始化ClassA的话，此时只能等待，等迁移个线程初始化完后后一个线程直接返回。下面这例子就是来证明这个结论</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>class Lock {}

class Danger {
  <span class="keyword">static</span> {
    System.out.println(<span class="string">"clinit begin..."</span>);
    <span class="keyword">try</span> {
    	Thread.sleep(<span class="number">2000</span>);
    } <span class="keyword">catch</span> (Exception e) {
    	System.out.println(e);
    }
    <span class="keyword">synchronized</span> (Lock.class) 
    { 
    	System.out.println(<span class="string">"clinit done!"</span>);
    }
  }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
  	<span class="comment">// 创建一个线程,此处标记为Thread1，方便下面好描述</span>
    <span class="keyword">new</span> Thread() {
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">synchronized</span> (Lock.class) {
          System.out.println(<span class="string">"new thread start!"</span>);
          <span class="keyword">try</span> {
          	Thread.sleep(<span class="number">1000</span>);
          } <span class="keyword">catch</span> (Exception e) {
          	System.out.println(e);
          }
          <span class="keyword">new</span> Danger();
        }
        System.out.println(<span class="string">"new thread end!"</span>);
      }
    }.start();
    <span class="keyword">try</span> {
    	Thread.sleep(<span class="number">500</span>);
    } <span class="keyword">catch</span> (Exception e) {
    	System.out.println(e);
    }
    
    System.out.println(<span class="keyword">new</span> Danger());
    System.out.println(<span class="string">"DONE!"</span>);
  }
}
</pre></td></tr></table></figure>

<p>上述代码运行就会死锁。<br>现在我们来分析为什么会死锁，线程Thread1先执行获取到Lock.class上的锁，然后sleep等待1000ms,此时Main线程sleep等待500ms，Main线程睡醒后，开始创建Danager实例，然后在创建Dananger实例时执行Danager类实例初始化的代码，在类初始化的代码中sleep等待2000ms,在这个过程中Thread1睡醒了，然后也去创建Danger实例，当然也需要执行类实例初始化的代码了，但是Main线程正在执行Danger类实例的初始化，因此Thread1只能等待，等Main线程睡醒了，但是需要等Thread1释放Lock.class上的锁才能完成Danger类实例初始化，此时Thread1等Main线程初始化完Danger类，Main线程等Thread1释放Lock.class上的锁，因此Thread1和Main互等，形成死锁，死锁的本质原因就是JVM不允许多个线程同时初始化一个类实例。</p>
<p>同事F说这段代码写的太复杂了，不太好理解，的确，然后F给出了一个更简单的例子证明JVM不允许多个线程同时初始化一个类实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownDeadLock</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object referObject = <span class="keyword">new</span> Object();
    <span class="keyword">static</span> {
        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                <span class="keyword">if</span> (referObject == <span class="keyword">null</span>)
                ;
            }

        });
        System.exit(<span class="number">0</span>);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {

    }
}
</pre></td></tr></table></figure>

<p>上述代码会导致JVM没法退出，static代码块中在类初始化的时候会执行，System.exit(0);会导致JVM退出，但是有一个JVM退出时回调的钩子线程，这个线程会访问ShutDownDeadLock的静态成员变量referObject，但是此时ShutDownDeadLock类实例不允许其他线程使用，因为当前类实例正在被初始化，被JVM加锁了。</p>
<p>上面的代码做如下修改就能正常退出了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownUnDeadLock</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object referObject = <span class="keyword">new</span> Object();
    
    <span class="keyword">static</span> {
        <span class="keyword">final</span> Object oo = referObject;
        
        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                <span class="keyword">if</span> (oo == <span class="keyword">null</span>)
                ;
            }

        });
        System.exit(<span class="number">0</span>);
    }
    

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {

    }
}
</pre></td></tr></table></figure>

<p>此时JVM能够正常退出，因此线此时访问oo时不需要通过ShutDownUnDeadLock类实例来访问，直接从方法栈帧的局部变量表中读取，也就是说直接从栈上读取。</p>
<p>我们经常在代码中定义常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IQuantConstant</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IQUANT_PAGE_SIZE = <span class="number">30</span>;
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IQuantConstantTest</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		System.out.println(IQuantConstant.IQUANT_PAGE_SIZE);
	}
}
</pre></td></tr></table></figure>

<p>如果IQuantConstant和IQuantConstantTest在不同的JAR包中，此时修改了IQuantConstant中常量IQUANT_PAGE_SIZE的值后，另外一个JAR包感知不到，这个是编译器做的优化，编译的时候直接把IQUANT_PAGE_SIZE的值拷贝过去。</p>
<p>TLAB是指thread local allocation buffers，用来避免线程竞争同步的开销。</p>
<p>一个class能被卸载的前提是加载这个class的classloader加载的所有类都能被卸载，这个在使用groovy脚本时要注意，容易引起classloader的泄漏，导致perm区OOM。perm区的gc就能卸载满足条件的class。</p>
<h4 id="三-GC相关">三.GC相关</h4>
<p><img src="http://bolinyoung.qiniudn.com/cmsgc.png" alt="CMS"><br>使用CMS垃圾回收的时候，会有两次stop-the-world,因此使用jstat -gcutil查看FGC次数时，发现每次FGC都是增加2。</p>
<p>新生代分为eden区，s0和s1,之所以有s0和s1两个对等的区，是因为MinorGC采用的是拷贝复制的算法进行垃圾回收，MinorGC会把存活的对象从s0拷贝到s1，或者从s1拷贝到s0。</p>
<p>GC算法<br>标记-清除，该算法先去标记可回收的对象，然后再一个个回收调，容易产生内存碎片。</p>
<p>复制，该算法把内存划分为两个对等的区域，把存活的对象直接从一个区域拷贝到另外一个区域。</p>
<p>标记-整理，先标记出需要可回收的对象，然后对不可回收的对象进行移动，让不可回收的对象集中在内存的一端。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近看见公司一位前辈有分享JVM相关的知识，自己特地从跑过去听了一下，感觉讲的不是很深入，但是相对来说还是不错的，本文就自己听到的一些东西做一个简单的总结。平时我们大多数都是用JAVA写代码,很多人学JAVA都是从HelloWorld开始，但是从你写HelloWorld代码到最终输出HelloWorld到底发生那些事情呢？要想清楚的回答这个问题，并不是很容易，你需要对JVM有一个清晰的了解后，才能说清楚这个问题，这只是一个引子，本文也不去挑战这个问题，这里主要记录一下自己从这个分享中听到的一些感兴趣的东西。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
