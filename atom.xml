<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BolinYoung's Blog]]></title>
  <subtitle><![CDATA[Believe in yourself]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yangbolin.cn/"/>
  <updated>2014-11-23T09:41:06.879Z</updated>
  <id>http://yangbolin.cn/</id>
  
  <author>
    <name><![CDATA[BolinYoung]]></name>
    <email><![CDATA[boris.yangbl@alibaba-inc.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一次关于servlet的扩展]]></title>
    <link href="http://yangbolin.cn/2014/11/17/servlet-extend/"/>
    <id>http://yangbolin.cn/2014/11/17/servlet-extend/</id>
    <published>2014-11-17T14:43:31.000Z</published>
    <updated>2014-11-17T14:59:21.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>现有一个web框架，从HttpServletRequest中获取调用request.getParameter(“orderId”)获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。</p>
<a id="more"></a>

<h4 id="二-实现思路">二.实现思路</h4>
<p>1.直接先解密orderId，然后再修改request中的orderId，你会发现你没法修改，servlet规范不允许修改request。<br>2.对HttpServletRequest进行包装，在进入web框架的时候把这个HttpServletRequest包装一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpServletRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> {</span>

    <span class="keyword">private</span> Map&lt;String, String&gt; param = <span class="keyword">new</span> HashMap&lt;String, String&gt;();

    <span class="javadoc">/**
     *<span class="javadoctag"> @param</span> request
     */</span>
    <span class="keyword">public</span> <span class="title">MyHttpServletRequestWrapper</span>(HttpServletRequest request) {
        <span class="keyword">super</span>(request);
    }

    <span class="comment">// 重写获取参数值的方法</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> String <span class="title">getParameter</span>(String name) {
        <span class="keyword">if</span> (param.containsKey(name)) {
            <span class="keyword">return</span> param.get(name);
        }
        <span class="keyword">return</span> <span class="keyword">super</span>.getParameter(name);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParameter</span>(String name, String value) {
        param.put(name, value);
    }
}
</pre></td></tr></table></figure>

<p>增加解密orderId的filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOrderIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>() {
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest request, ServletResponse servletResponse, FilterChain filterChain)                                                                   <span class="keyword">throws</span> IOException,                                                         ServletException {
        String orderId = request.getParameter(<span class="string">"orderId"</span>);
        <span class="comment">// 对orderId解密</span>
        orderId = WebUtils.decode(orderId);
        MyHttpServletRequestWrapper myRequestWrapper = <span class="keyword">new</span> MyHttpServletRequestWrapper(                        (HttpServletRequest) request);
        myRequestWrapper.addParameter(<span class="string">"orderId"</span>, orderId);
        <span class="comment">// 把包装后的Request传递给下一个Filter</span>
        filterChain.doFilter(myRequestWrapper, servletResponse);
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(FilterConfig arg0) <span class="keyword">throws</span> ServletException {
    }
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>现有一个web框架，从HttpServletRequest中获取调用request.getParameter(“orderId”)获取订单的ID，为了安全，我们对订单的ID加密了，也就是此时外部传递过来的orderId已经加密，但是这个web框架不认识加密后的orderId，这就需要我们在自己的web应用中把orderId解密，然后继续传递。</p>
]]></summary>
    
      <category term="servlet" scheme="http://yangbolin.cn/tags/servlet/"/>
    
      <category term="web开发" scheme="http://yangbolin.cn/categories/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[akka如何和Spring集成起来]]></title>
    <link href="http://yangbolin.cn/2014/11/17/akka-spring/"/>
    <id>http://yangbolin.cn/2014/11/17/akka-spring/</id>
    <published>2014-11-17T14:08:04.000Z</published>
    <updated>2014-11-17T15:16:08.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近又重新学习了一下akka，并且在一个web应用中成功使用了akka提升了系统的性能。我们在web应用中一般都会有dao&amp;&amp;service，这些都是spring的bean，我们定义一个actor，这个actor中可能调用dao读写数据库，也可能调用service做业务逻辑，因此我们就希望actor也是从spring容器中获取到的，这样就可以在actor中注入service&amp;&amp;dao了。</p>
<a id="more"></a>

<h4 id="二-如何从Spring容器中获取actor">二.如何从Spring容器中获取actor</h4>
<p>1.用于从Spring容器中获取actor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringActorProducer</span> <span class="keyword">implements</span> <span class="title">IndirectActorProducer</span> {</span>

    <span class="keyword">final</span> ApplicationContext applicationContext;
    <span class="keyword">final</span> String             actorBeanName;

    <span class="keyword">public</span> <span class="title">SpringActorProducer</span>(ApplicationContext applicationContext, String actorBeanName){
        <span class="keyword">this</span>.applicationContext = applicationContext;
        <span class="keyword">this</span>.actorBeanName = actorBeanName;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Actor <span class="title">produce</span>() {
        <span class="keyword">return</span> (Actor) applicationContext.getBean(actorBeanName);
    }

    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Class&lt;? extends Actor&gt; <span class="title">actorClass</span>() {
        <span class="keyword">return</span> (Class&lt;? extends Actor&gt;) applicationContext.getType(actorBeanName);
    }
}
</pre></td></tr></table></figure>

<p>2.扩展actor的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>public class SpringExtension extends AbstractExtensionId&lt;SpringExtension.SpringExt&gt; {

    /**
     * The identifier used to access the SpringExtension.
     */
    public static SpringExtension SpringExtProvider = new SpringExtension();

    /**
     * Is used by Akka to instantiate the Extension identified by this ExtensionId, internal use only.
     */
    @Override
    public SpringExt createExtension(ExtendedActorSystem system) {
        return new SpringExt();
    }

    /**
     * The Extension implementation.
     */
    public static class SpringExt implements Extension {

        private volatile ApplicationContext applicationContext;

        /**
         * Used to initialize the Spring application context for the extension.
         * 
         * @param applicationContext
         */
        public void initialize(ApplicationContext applicationContext) {
            this.applicationContext = applicationContext;
        }

        /**
         * Create a Props for the specified actorBeanName using the SpringActorProducer class.
         * 
         * @param actorBeanName The name of the actor bean to create Props for
         * @return a Props that will create the named actor bean using Spring
         */
        public Props props(String actorBeanName) {
            return Props.create(SpringActorProducer.class, applicationContext, actorBeanName);
        }
    }
}
</pre></td></tr></table></figure>

<p>3.示例actor以及actor依赖的service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingService</span> {</span>
  <span class="javadoc">/**
   * Increment the given number by one.
   */</span>
  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increment</span>(<span class="keyword">int</span> count) {
    <span class="keyword">return</span> count + <span class="number">1</span>;
  }
}
class CountingActor extends UntypedActor {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> {</span>}
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span> {</span>}

    <span class="comment">// the service that will be automatically injected</span>
    <span class="keyword">private</span> CountingService countingService;

    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object message) <span class="keyword">throws</span> Exception {
        System.out.println(countingService);
        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Count) {
            count = countingService.increment(count);
        } <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Get) {
            getSender().tell(count, getSelf());
        } <span class="keyword">else</span> {
            unhandled(message);
        }
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountingService</span>(CountingService countingService) {
        <span class="keyword">this</span>.countingService = countingService;
    }
    
    <span class="keyword">public</span> <span class="title">CountingActor</span>() {
        System.out.println(<span class="string">"CountingActor is Creating..."</span>);
    }
}
</pre></td></tr></table></figure>

<p>CountingActor依赖了CountingService，CountingService到时候会被注入到CountingActor中。</p>
<p>4.配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
	<span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>
	<span class="attribute">default-autowire</span>=<span class="value">"byName"</span>&gt;</span>

	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"countingService"</span> <span class="attribute">class</span>=<span class="value">"com.bolin.young.akka.spring.CountingService"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"countingActor"</span> <span class="attribute">class</span>=<span class="value">"com.bolin.young.akka.spring.CountingActor"</span>  <span class="attribute">scope</span>=<span class="value">"prototype"</span> /&gt;</span>

	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myActorSystem"</span> <span class="attribute">class</span>=<span class="value">"akka.actor.ActorSystem"</span>
		<span class="attribute">factory-method</span>=<span class="value">"create"</span> <span class="attribute">destroy-method</span>=<span class="value">"shutdown"</span> <span class="attribute">scope</span>=<span class="value">"singleton"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"mySpringAkkaSystem"</span> /&gt;</span>
	<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
	
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<p>5.如何使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// create a spring context and scan the classes</span>
    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);

    ActorSystem myActorSystem = (ActorSystem)ctx.getBean(<span class="string">"myActorSystem"</span>);
    
    System.out.println(myActorSystem);
    
    SpringExtProvider.get(myActorSystem).initialize(ctx);
    
    <span class="keyword">final</span> ActorRef myActor = myActorSystem.actorOf(
                   SpringExtProvider.get(myActorSystem).props(<span class="string">"countingActor"</span>), <span class="string">"countingActor"</span>);
</pre></td></tr></table></figure>

<h4 id="三-最后总结">三.最后总结</h4>
<p>1.一般actorA发消息给actorB，actorB返回消息给actorA。我们可以自己在代码中发消息给actorA，然后坐等actorA的返回，如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>BootstrapAnalyzeMsg bootstrapAnalyzeMsg = <span class="keyword">new</span> BootstrapAnalyzeMsg();
bootstrapAnalyzeMsg.setFileItem(treeFile);

Timeout timeout = <span class="keyword">new</span> Timeout(Duration.create(TIME_OUT, <span class="string">"seconds"</span>));
Future&lt;Object&gt; future = Patterns.ask(bootstrapAnalyzeActor, bootstrapAnalyzeMsg, timeout);

<span class="keyword">try</span> {
     <span class="comment">// 当前线程会阻塞，直到有当前的Actor有消息过来。</span>
     ProjectAnalyzeResultMsg projectAnalyzeResultMsg = (ProjectAnalyzeResultMsg) Await.result(future,                                            timeout.duration());
     <span class="keyword">return</span> projectAnalyzeResultMsg.getJarConflictInfoList();
} <span class="keyword">catch</span> (Exception e) {
     e.printStackTrace();
} <span class="keyword">finally</span> {
     bootstrapAnalyzeActor.tell(<span class="keyword">new</span> ActorStopMsg(), <span class="keyword">null</span>);
}
</pre></td></tr></table></figure>

<p>该思想类似于java的Future。<br>2.actor也可以终止自己,没用的actor尽量提前终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>getContext().stop(getSelf());
</pre></td></tr></table></figure>

<p>3.actor在系统中的名字必须唯一。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近又重新学习了一下akka，并且在一个web应用中成功使用了akka提升了系统的性能。我们在web应用中一般都会有dao&amp;&amp;service，这些都是spring的bean，我们定义一个actor，这个actor中可能调用dao读写数据库，也可能调用service做业务逻辑，因此我们就希望actor也是从spring容器中获取到的，这样就可以在actor中注入service&amp;&amp;dao了。</p>
]]></summary>
    
      <category term="Akka" scheme="http://yangbolin.cn/tags/Akka/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用事务的一个注意点]]></title>
    <link href="http://yangbolin.cn/2014/10/31/transaction-attention/"/>
    <id>http://yangbolin.cn/2014/10/31/transaction-attention/</id>
    <published>2014-10-31T09:12:19.000Z</published>
    <updated>2014-10-31T09:59:37.000Z</updated>
    <content type="html"><![CDATA[<p>最近在代码中配置了一个事务，事务的意思就是当前这件事情要么全部正常做完，要么全部不做。为了避免数据库中出现脏数据，我给XXX类的ff方法配置了事务。在ff方法主要做下面这几件事情</p>
<a id="more"></a>

<ul>
<li>1.从数据库中读出一批数据dataList1，此时dataList1已经存在于内存中了。</li>
<li>2.修改这一批数据，此时的修改不会写到数据库，因为事务暂时还没有提交。</li>
<li>3.根据dataList1中的数据进行判断，然后再写数据库。</li>
</ul>
<p>这么处理有问题，因为dataList1在2结束后，会发生变化，但是内存中的dataList1感知不到，也就是说3处用的dataList1还是老数据，不是2修改后的数据，因此3处的判断条件会出现问题，因为3处用到的dataList1不是事务中最新的数据。</p>
<p>修复后的步骤如下：</p>
<ul>
<li>1.从数据库中读出一批数据dataList1，此时dataList1已经存在于内存中了。</li>
<li>2.修改这一批数据，此时的修改不会写到数据库，因为事务暂时还没有提交。</li>
<li>3.从数据库中再读取一次dataList1。</li>
<li>4.根据dataList1中的数据进行判断，然后再写数据库。</li>
</ul>
<p>注意：<br>事务中对数据库进行读写操作，此时写入的数据不会写到数据库中，但是能从事务中读取到最新的数据，如果要基于某些数据做判断，最好保证判断时这些数据在事务中是最新的，不要沿用一开始就加载到内存中的那批数据，因为一开始的数据不是最新的。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在代码中配置了一个事务，事务的意思就是当前这件事情要么全部正常做完，要么全部不做。为了避免数据库中出现脏数据，我给XXX类的ff方法配置了事务。在ff方法主要做下面这几件事情</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于log4j的additivity]]></title>
    <link href="http://yangbolin.cn/2014/10/31/log4j-additivity/"/>
    <id>http://yangbolin.cn/2014/10/31/log4j-additivity/</id>
    <published>2014-10-31T09:10:37.000Z</published>
    <updated>2014-10-31T09:36:55.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-问题描述">一.问题描述</h4>
<p>最近优化了一下一个应用的日志，但是优化后的结果不是自己想要的，简单说指定的log部分输出到了root中的appender中，部分输出到自己指定的log中。</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"BOORT"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"file"</span> <span class="attribute">value</span>=<span class="value">"xxx/boort.log"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"append"</span> <span class="attribute">value</span>=<span class="value">"true"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"encoding"</span> <span class="attribute">value</span>=<span class="value">"GBK"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> <span class="attribute">value</span>=<span class="value">"%d %-5p %c{2} - %m%n"</span> /&gt;</span>
	<span class="tag">&lt;/<span class="title">layout</span>&gt;</span>
<span class="tag">&lt;/<span class="title">appender</span>&gt;</span>
<span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"OPENAPI"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"file"</span> <span class="attribute">value</span>=<span class="value">"xxx/service/api.log"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"append"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"encoding"</span> <span class="attribute">value</span>=<span class="value">"GBK"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> <span class="attribute">value</span>=<span class="value">"%d %-5p %c{2} - %m%n"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>
<span class="tag">&lt;/<span class="title">appender</span>&gt;</span>

<span class="tag">&lt;<span class="title">logger</span> <span class="attribute">name</span>=<span class="value">"xxxx.Service"</span> <span class="attribute">additivity</span>=<span class="value">"true"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"info"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"OPENAPI"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">logger</span>&gt;</span>
<span class="tag">&lt;<span class="title">root</span>&gt;</span>
	<span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"info"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"BOORT"</span> /&gt;</span>
	<span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"JmonitorAppender"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">root</span>&gt;</span>
</pre></td></tr></table></figure>

<p>上述xxxx.Service中的日志部分会出现到boort.log，部分会出现到api.log中。但是我们期望xxxx.Service中日志只出现到api.log中。</p>
<h4 id="二-解决方案">二.解决方案</h4>
<p>上面的问题肯定是日志配置的问题，google后发现additivity=”true”在搞鬼<br><a href="http://wiki.apache.org/logging-log4j/Log4jXmlFormat" target="_blank">log4j的配置</a><br>具体说明如下：<br><img src="http://bolinyoung.qiniudn.com/log4j-additivity.png" alt="log4j的additivity"></p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-问题描述">一.问题描述</h4>
<p>最近优化了一下一个应用的日志，但是优化后的结果不是自己想要的，简单说指定的log部分输出到了root中的appender中，部分输出到自己指定的log中。</p>
]]></summary>
    
      <category term="log4j" scheme="http://yangbolin.cn/tags/log4j/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka入门]]></title>
    <link href="http://yangbolin.cn/2014/10/25/akka-start/"/>
    <id>http://yangbolin.cn/2014/10/25/akka-start/</id>
    <published>2014-10-25T14:35:44.000Z</published>
    <updated>2014-10-25T14:55:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>为了提高一个数据计算平台的吞吐了，最近抽空看了看akka，之前听同事说akka能够提高并发吞吐量，高容错，很稳定，今天抽时间先简单看了相关的文档，写了个简单的例子，主要演示如何使用akka，当然我们也可以搭建一个akka的集群。</p>
<a id="more"></a>

<h4 id="二-快速开始">二.快速开始</h4>
<p>akka相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="comment">&lt;!--  akka starting --&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-actor_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-remote_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-kernel_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-cluster_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-contrib_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-slf4j_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.fusesource<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>sigar<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>1.6.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-cluster_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
	<span class="tag">&lt;<span class="title">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="comment">&lt;!--  akka ending  --&gt;</span>
</pre></td></tr></table></figure>

<p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> Msg {
    GREET, DONE, WELCOME;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object msg) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (msg == Msg.GREET) {
            System.out.println(<span class="string">"Greeter Messgae!"</span>);
            <span class="comment">// 收到GREET消息后发出一个DONE的应答</span>
            getSender().tell(Msg.DONE, getSelf());
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object arg0) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (arg0 == Msg.WELCOME) {  
            System.out.println(<span class="string">"Welcome Messgae!"</span>);
            <span class="comment">// 收到WELCOME消息后，发出一个WELCOME的应答</span>
            getSender().tell(Msg.WELCOME, getSelf());
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preStart</span>() {
        <span class="comment">// 发送WELCOME消息给welcome这个Actor</span>
        <span class="keyword">final</span> ActorRef welcome = getContext().actorOf(Props.create(Welcome.class), <span class="string">"welcome"</span>);
        welcome.tell(Msg.WELCOME, getSelf());
        
        <span class="comment">// 发送GREET消息给greet这个Actor</span>
        <span class="keyword">final</span> ActorRef greeter = getContext().actorOf(Props.create(Greeter.class), <span class="string">"greeter"</span>);
        greeter.tell(Msg.GREET, getSelf());
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span>(Object msg) <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (msg == Msg.DONE) {
            System.out.println(<span class="string">"Message DONE"</span>);
            getContext().stop(getSelf());
        } <span class="keyword">else</span> {
            System.out.println(msg);
        }
    }
}
</pre></td></tr></table></figure>

<p>这里的HelloWorld，Welcome，Greeter是三个Actor，在上述代码中HelloWorld向Welcome，Greeter发消息，Welcome，Greeter收到消息后分别向HelloWorld发出回应。<br>HelloWorld在收到DONE消息后会终止自己。通过akka.Main来启动，设置启动参数com.bolin.young.akka.HelloWorld，这样就能看到相关的输出了。</p>
<h4 id="三-总结">三.总结</h4>
<p>通过上面这个小例子，我们发现akka中有一个核心的东西，那就是actor，actor之间通过消息通信，actorA发消息给actorB，actorB收到actorA的消息后，也可以对actorA发送一个回应的消息。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>为了提高一个数据计算平台的吞吐了，最近抽空看了看akka，之前听同事说akka能够提高并发吞吐量，高容错，很稳定，今天抽时间先简单看了相关的文档，写了个简单的例子，主要演示如何使用akka，当然我们也可以搭建一个akka的集群。</p>
]]></summary>
    
      <category term="Akka" scheme="http://yangbolin.cn/tags/Akka/"/>
    
      <category term="并发技术" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过开放调用来避免死锁]]></title>
    <link href="http://yangbolin.cn/2014/10/25/open-call-to-avoid-deadlock/"/>
    <id>http://yangbolin.cn/2014/10/25/open-call-to-avoid-deadlock/</id>
    <published>2014-10-25T13:00:45.000Z</published>
    <updated>2014-10-25T13:31:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在编写并发程序的时候，我们经常会在一次业务逻辑处理过程中获取多个锁，然后做一些操作，如果这多个锁的获取顺序和其他地方的获取顺序不同的话，很容易发生死锁。为了避免这种死锁，我们必须保证获取多个锁的顺序一致，或者方法调用为开放调用，即调用某个方法时不需要持有锁。</p>
<a id="more"></a>

<h4 id="二-示例分析">二.示例分析</h4>
<p>Taxi表示一个出租车对象，包含位置和目的地两个属性，Dispatcher代表一个出租车队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>class Taxi {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>)<span class="keyword">private</span> Point location, destination;
	<span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;
	<span class="keyword">public</span> <span class="title">Taxi</span>(Dispatcher dispatcher) {
		<span class="keyword">this</span>.dispatcher = dispatcher;
	}
	<span class="javadoc">/** 获取出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span>() {
		<span class="keyword">return</span> location;
	}
	<span class="javadoc">/** 设置出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span>(Point location) {
		<span class="keyword">this</span>.location = location;
		<span class="keyword">if</span> (location.equals(distination)) {
			dispatcher.notifyAvailable(<span class="keyword">this</span>);
		}
	}
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>class Dispatcher {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;
	
	<span class="keyword">public</span> <span class="title">Dispatcher</span>() {
		taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
		availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
	}
	
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span>(Taxi taxi) {
		availableTaxis.add(taxi);
	}
	<span class="javadoc">/** 获取某个时刻，整个车队的完整快照 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span>() {
		Image image = <span class="keyword">new</span> Image();
		<span class="keyword">for</span> (Taxi t : taxis) {
			image.drawMarker(t.getLocation());
		}
		<span class="keyword">return</span> image;
	}
}
</pre></td></tr></table></figure>

<p>看看上面的代码，我们就知道setLocation和notifyAvailable方法都是同步方法，调用setLocation的线程首先获取Taxi上的锁，然后获取Dispatcher的锁。getImage方法先获取Dispatcher上的锁，再获取Taxi上的锁，这两个方法被不同的线程调用时容易产生死锁，相信现在的滴滴以及快的绝对不是这么干的。</p>
<p>下面我看看如何通过开放调用来避免这个死锁的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>class Taxi {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>)<span class="keyword">private</span> Point location, destination;
	<span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;
	<span class="keyword">public</span> <span class="title">Taxi</span>(Dispatcher dispatcher) {
		<span class="keyword">this</span>.dispatcher = dispatcher;
	}
	<span class="javadoc">/** 获取出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span>() {
		<span class="keyword">return</span> location;
	}
	<span class="javadoc">/** 设置出租车的位置 **/</span>
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span>(Point location) {
		<span class="keyword">boolean</span> reachedDestination = <span class="keyword">false</span>;
		<span class="javadoc">/** 缩小缩的范围 把方法变成开发调用 **/</span>
		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) {
			<span class="keyword">this</span>.location = location;
			reachedDestination = location.equals(distination);
		}
		
		<span class="keyword">if</span> (reachedDestination) {
			dispatcher.notifyAvailable(<span class="keyword">this</span>);
		}
	}
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>class Dispatcher {
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;
	<span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;
	
	<span class="keyword">public</span> <span class="title">Dispatcher</span>() {
		taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
		availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();
	}
	
	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span>(Taxi taxi) {
		availableTaxis.add(taxi);
	}
	<span class="javadoc">/** 获取每辆出租车不同时刻的位置 **/</span>
	<span class="keyword">public</span> Image <span class="title">getImage</span>() {
		Set&lt;Taxi&gt; copy;
		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) {
			copy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);
		}
		Image image = <span class="keyword">new</span> Image();
		<span class="keyword">for</span> (Taxi t : taxis) {
			image.drawMarker(t.getLocation());
		}
		<span class="keyword">return</span> image;
	}
}
</pre></td></tr></table></figure>

<p>通过上面的改造，我们把setLocation和getImage都变成了开放调用，与那些持有锁时调用外部方法的程序相比，更容易对依赖的开发调用的程序进行死锁分析。</p>
<p>在编写并发程序的时候，一定要注意一个思想，加锁范围最小化。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>在编写并发程序的时候，我们经常会在一次业务逻辑处理过程中获取多个锁，然后做一些操作，如果这多个锁的获取顺序和其他地方的获取顺序不同的话，很容易发生死锁。为了避免这种死锁，我们必须保证获取多个锁的顺序一致，或者方法调用为开放调用，即调用某个方法时不需要持有锁。</p>
]]></summary>
    
      <category term="Concurrency" scheme="http://yangbolin.cn/tags/Concurrency/"/>
    
      <category term="并发技术" scheme="http://yangbolin.cn/categories/%E5%B9%B6%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[项目中的点点滴滴]]></title>
    <link href="http://yangbolin.cn/2014/10/19/project-accumulation-1/"/>
    <id>http://yangbolin.cn/2014/10/19/project-accumulation-1/</id>
    <published>2014-10-19T08:21:50.000Z</published>
    <updated>2014-10-19T10:08:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近一直在忙项目中的事情，不过在整个开发过程中自己也有一些体会，写写这些体会，就当是自己的经验了，这里不会涉及到太深的原理，只是记录一些技巧以及一些值得注意的地方，形成一些编程的思想，理念，可以更好地运用到后续的项目之中。</p>
<a id="more"></a>

<h4 id="二-关于Spring定时任务">二.关于Spring定时任务</h4>
<p>Spring定时任务在项目中经常会被使用，我们经常通过限定IP的方式保证我们自己设计的定时任务只会在一台机器上启动，关于Spring定时任务在项目中需要注意一下配置，有时候会漏写一些配置，其实没有必要死记这些配置怎么写，按照正常的思路，你需要指定要运行的任务是什么，其次，既然是定时任务，那就需要指定定时，也就是什么时候运行，最后，任务以及任务要运行的时间都有了，那么如何调度呢？也就是说运行时刻到了，谁来调度这个任务。显然配置Spring定时任务需要把握三个要素，就是上面这三个点，下面我们写一个简单的配置例子来说明一下这三个点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 1.指定要运行的任务 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"autoAuditFailedTaskJobDetail"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"concurrent"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>false<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"autoAuditFailedTask"</span> /&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">value</span>&gt;</span>execute<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
 <span class="comment">&lt;!-- 2.配置触发器 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"autoAuditFailedTaskCronTrigger"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;</span>
    <span class="comment">&lt;!-- 这里不可以直接在属性jobDetail中引用taskJob，因为他要求的是一个jobDetail类型的对象，所以我们得通过MethodInvokingJobDetailFactoryBean来转一下 --&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jobDetail"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"autoAuditFailedTaskJobDetail"</span> /&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
   <span class="comment">&lt;!-- 每天晚上23:00点触发  --&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cronExpression"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">value</span>&gt;</span>0 0 23 * * ?<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="comment">&lt;!-- 3. 添加调度器 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"triggers"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">list</span>&gt;</span>
          <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"autoAuditFailedTaskCronTrigger"</span> /&gt;</span>
       <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<p>在配置的时候注意这三个点，缺一不可。</p>
<h4 id="三-关于NPE">三.关于NPE</h4>
<p>我们在写代码的时候经常会考虑NPE的问题，对于参数经常会做NPE校验，在对每一个参数做NPE校验的时候一定要想一下该参数是否一定不为NULL，不要一味地追求NPE。</p>
<h4 id="四-关于时间的加减以及格式化">四.关于时间的加减以及格式化</h4>
<p>经常有这样的需求，需要把当前时间向前或者向后推算N天，以及对时间做格式化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Calendar calendar = Calendar.getInstance();
calendar.setTime(<span class="keyword">new</span> Date());
<span class="comment">// n可以为正数，也可以为负数</span>
calendar.add(Calendar.DAY_OF_MONTH, n);
<span class="comment">// 时间格式化</span>
DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"MM/dd"</span>);
format.format(calendar.getTime());
</pre></td></tr></table></figure>

<h4 id="五-关于xstream">五.关于xstream</h4>
<p>xstream可以实现XML和Object之间的相互转换</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.thoughtworks.xstream<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>xstream<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.4.7<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span>

    <span class="keyword">private</span> <span class="keyword">int</span>     age;
    <span class="keyword">private</span> SexEnum sex;
    <span class="keyword">private</span> String  name;

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>() {
        <span class="keyword">return</span> age;
    }

    <span class="keyword">public</span> SexEnum <span class="title">getSex</span>() {
        <span class="keyword">return</span> sex;
    }

    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span>(<span class="keyword">int</span> age) {
        <span class="keyword">this</span>.age = age;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span>(SexEnum sex) {
        <span class="keyword">this</span>.sex = sex;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> SexEnum {
    MALE(<span class="string">"M"</span>), FEMALE(<span class="string">"F"</span>);

    String value;

    SexEnum(String value){
        <span class="keyword">this</span>.value = value;
    }

    <span class="keyword">public</span> String <span class="title">getValue</span>() {
        <span class="keyword">return</span> value;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(String value) {
        <span class="keyword">this</span>.value = value;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> SexEnum <span class="title">parse</span>(String value) {
        <span class="keyword">for</span> (SexEnum sexEnum : SexEnum.values()) {
            <span class="keyword">if</span> (value.equals(sexEnum.getValue())) {
                <span class="keyword">return</span> sexEnum;
            }
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XStreamTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="comment">// Object TO XML</span>
        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();
        Person person1 =  <span class="keyword">new</span> Person();
        person1.setAge(<span class="number">22</span>);
        person1.setName(<span class="string">"nuaa"</span>);
        person1.setSex(SexEnum.MALE);
        personList.add(person1);
        
        Person person2 =  <span class="keyword">new</span> Person();
        person2.setAge(<span class="number">22</span>);
        person2.setName(<span class="string">"buaa"</span>);
        person2.setSex(SexEnum.MALE);
        personList.add(person2);
        
        XStream xstream = <span class="keyword">new</span> XStream();
        <span class="comment">// 使用别名</span>
        xstream.alias(<span class="string">"person"</span>, Person.class);
        xstream.alias(<span class="string">"personList"</span>, List.class);
        <span class="comment">// 注册枚举转换器</span>
        xstream.registerConverter(<span class="keyword">new</span> AbstractSingleValueConverter(){
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span>(@<span class="title">SuppressWarnings</span>("rawtypes") Class type) {
                <span class="keyword">if</span> (type.equals(SexEnum.class)) {
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                }
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
            <span class="comment">// String转换成对象</span>
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> Object <span class="title">fromString</span>(String str) {
                <span class="keyword">return</span> SexEnum.parse(str);
            }

            <span class="comment">// 对象转换成String</span>
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> String <span class="title">toString</span>(Object obj) {
                SexEnum sexEnum = (SexEnum)obj;
                <span class="keyword">return</span> sexEnum.getValue();
            }
        });
        
        String xml = xstream.toXML(personList);
        System.out.println(xml);

        <span class="comment">// XML TO Object</span>
        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
        List&lt;Person&gt; fromXMLList = (List&lt;Person&gt;)xstream.fromXML(xml);
        System.out.println(fromXMLList);
        <span class="keyword">for</span>(Person person : fromXMLList) {
            System.out.println(<span class="string">"#############################"</span>);
            System.out.println(<span class="string">"age: "</span> + person.getAge());
            System.out.println(<span class="string">"sex: "</span> + person.getSex());
            System.out.println(<span class="string">"name: "</span> + person.getName());
        }
    }
}
</pre></td></tr></table></figure>

<p>使用xtream可以避免自己解析XML文件。</p>
<h4 id="六-关于fastjson">六.关于fastjson</h4>
<p>fastjson把对象转化成json字符串时会出现$ref，这是由于对象之间有循环引用导致，这有可能导致堆栈溢出，我们可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>JSON.toJSONString(object,  SerializerFeature.DisableCircularReferenceDetect)
</pre></td></tr></table></figure>

<p>来避免json串中出现$ref。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近一直在忙项目中的事情，不过在整个开发过程中自己也有一些体会，写写这些体会，就当是自己的经验了，这里不会涉及到太深的原理，只是记录一些技巧以及一些值得注意的地方，形成一些编程的思想，理念，可以更好地运用到后续的项目之中。</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用BTrace监控方法入参]]></title>
    <link href="http://yangbolin.cn/2014/10/12/btrace-for-exception/"/>
    <id>http://yangbolin.cn/2014/10/12/btrace-for-exception/</id>
    <published>2014-10-12T10:06:18.000Z</published>
    <updated>2014-11-08T07:20:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>昨天在生产环境出现一个类的方法被调用然后出现了异常，这个异常没有被catch而是直接抛给上层的调用，我们想知道抛异常时调用该方法的参数是什么样子的，然后根据这个参数分析问题聚图出现在什么地方。</p>
<a id="more"></a>

<p>为了能够清晰的说明问题，这里大致描述一下昨天出问题的类的代码结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxUtil</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">decodeXxx</span>(String sSrc, String sSkey,String iVParam) <span class="keyword">throws</span> Exception {
	<span class="comment">// 在这里做解码，然后在这里抛异常了</span>
	}
}
</pre></td></tr></table></figure>

<p>静态方法decodeXxx被调用时，在方法内部抛出了没有被catch住的异常，这就是基本现象。</p>
<h4 id="二-排查过程">二.排查过程</h4>
<p>我们需要知道调用decodeXxx方法是参数是什么样子的，生成环境没法DEBUG只能考虑使用BTrace脚本了，使用BTrace动态监控decodeXxx的调用，然后输出方法调用的参数，于是我准备了如下的BTrace脚本，此时所有decodeXxx方法的调用都会被监控到，如何区分有异常的case呢？我们日志中记录的异常以及异常发生的时间，因此我们需要在监控脚本中输出监控时间，然后和日志中异常发生的时间对比，找出最终出现问题的方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;
<span class="keyword">import</span> com.sun.btrace.annotations.*;
<span class="keyword">import</span> com.sun.btrace.AnyType;

<span class="annotation">@BTrace</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceMethodArgsAndReturn</span>{</span>

        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>,
        location=<span class="annotation">@Location</span>(Kind.RETURN)
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"Call xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
                <span class="comment">// 输出时间,这里之所以输出时间就是为了和日志中的时间对比寻找出错时方法调用的入参，日志中记录了异常时间</span>
                println(strcat(<span class="string">"time is:"</span>,str(timeMillis()));
        }
}
</pre></td></tr></table></figure>

<p>脚本准备好了，然后在线上和JVM建立链接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sudo -u admin /home/boris<span class="preprocessor">.yangbl</span>/btrace/bin/btrace -<span class="keyword">cp</span> /home/boris<span class="preprocessor">.yangbl</span>/btrace/build <span class="number">8485</span> TraceMethodArgsAndReturn<span class="preprocessor">.java</span>
</pre></td></tr></table></figure>

<p>其中8485是JVM的PID。<br>执行命令后，监控确实被监控到了，但是方法内部抛异常的case没有被监控到，奇怪，此时子写检查上面的监控脚本，发现location=@Location(Kind.RETURN)，这说明方法返回时才会被监控到，要是方法抛异常了，方法的return字节码压根就不会被调用，要是方法的return字节码不会被调用，那BTrace动态增加的字节码也不会被调用，因此需要修改一下BTrace脚本了，输出的时候不要限制方法返回，现在把BTrace脚本修改如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;
<span class="keyword">import</span> com.sun.btrace.annotations.*;
<span class="keyword">import</span> com.sun.btrace.AnyType;

<span class="annotation">@BTrace</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceMethodArgsAndReturn</span>{</span>

        <span class="comment">// 方法返回时的监控</span>
        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>,
        location=<span class="annotation">@Location</span>(Kind.RETURN)
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"return xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
        }
        <span class="comment">// 进入方法的监控</span>
        <span class="annotation">@OnMethod</span>(
        clazz=<span class="string">"xxx.xxxUtil"</span>,
        method=<span class="string">"decodeXxx"</span>
        )
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span>(AnyType sSrc, AnyType sSkey, AnyType iVParam, @Return Object result){
                println(<span class="string">"enter xxxUtil.decodeXxx"</span>);
                <span class="comment">// 打印入参sSrc</span>
                println(strcat(<span class="string">"sSrc is:"</span>,str(sSrc)));
                <span class="comment">// 打印入参sSkey</span>
                println(strcat(<span class="string">"sSkey is:"</span>,str(sSkey)));
                <span class="comment">// 打印入参iVParam</span>
                println(strcat(<span class="string">"iVParam is:"</span>,str(iVParam)));
                <span class="comment">// 打印函数返回结果result</span>
                println(strcat(<span class="string">"result is:"</span>,str(result)));
        }
}
</pre></td></tr></table></figure>

<p>修改成上面的监控脚本后，我们都不需要在脚本中输出监控时间了，要是有方法抛异常的化了，必然会出现只有enter(进入方法的监控)没有return(方法返回时的监控)的输出，由于线上有两台机器，因此同时在这两台机器上使用了这个BTrace脚本，最终定位到了decodeXxx方法内部抛出异常时方法的入参是什么。后面的分析和业务有关，这里不做过多解释。</p>
<h4 id="三-最后总结">三.最后总结</h4>
<p>location=@Location(Kind.RETURN)要是方法内部出现异常的话，此时被BTrace修改后的字节码就没法执行了。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>昨天在生产环境出现一个类的方法被调用然后出现了异常，这个异常没有被catch而是直接抛给上层的调用，我们想知道抛异常时调用该方法的参数是什么样子的，然后根据这个参数分析问题聚图出现在什么地方。</p>
]]></summary>
    
      <category term="BTrace" scheme="http://yangbolin.cn/tags/BTrace/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA线程本地存储之ThreadLocal的分析]]></title>
    <link href="http://yangbolin.cn/2014/10/07/thread-local-analyze/"/>
    <id>http://yangbolin.cn/2014/10/07/thread-local-analyze/</id>
    <published>2014-10-07T13:01:03.000Z</published>
    <updated>2014-10-07T13:07:13.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ThreadLocal是JDK的一个线程本地存储的类，我们可以把一些线程私有的数据写在ThreadLocal中，这样这些数据只有一个线程可见，实现了所谓的栈封闭。这样存储一些线程私有的数据，我们就不用去费心考虑如何保证临界资源的互斥访问了，同时对于一个线程，这些私有数据也只做一次初始化。</p>
<a id="more"></a>

<h4 id="二-一段ThreadLocal的测试代码">二.一段ThreadLocal的测试代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>class LocalObject {
    <span class="keyword">private</span> String name;
    
    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}

class LocalStoreThread extends Thread {
    <span class="javadoc">/** 定义了一个线程本地存储的成员变量 **/</span>
    <span class="keyword">private</span> ThreadLocal&lt;LocalObject&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;LocalObject&gt;();

    <span class="keyword">public</span> <span class="title">LocalStoreThread</span>(LocalObject lo) {
        threadLocal.set(lo);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        System.out.println(threadLocal.get().getName());
    }
}

<span class="javadoc">/**
 * &lt;pre&gt;
 * 创建一个线程实例，这个线程实例中有一个线程本地存储成员变量
 * &lt;/pre&gt;
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        LocalObject lo = <span class="keyword">new</span> LocalObject();
        lo.setName(<span class="string">"thread-local"</span>);
        <span class="keyword">new</span> LocalStoreThread(lo).start();
    }
}
</pre></td></tr></table></figure>

<p>上述代码运行的时候在run方法中抛出了空指针异常，明明在构造函数中调用了threadLocal的set方法，为什么get的时候获取到了null,然后使用了null抛出了NPE呢？</p>
<p>由于ThreadLocal是和线程相关的，我们上面的代码在够在函数中往线程本地存储变量中设置了一个实例对象，在run方法中获取这个实例对象的时候发现拿到是null,所以我们有必要看一下set时对应的线程和get时对应的线程是不是一样的。因此在set之前打印一下Thread.currentThread()，同时在get之前打印一下Thread.currentThread()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre>class LocalObject {
    <span class="keyword">private</span> String name;
    
    <span class="keyword">public</span> String <span class="title">getName</span>() {
        <span class="keyword">return</span> name;
    }
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(String name) {
        <span class="keyword">this</span>.name = name;
    }
}

class LocalStoreThread extends Thread {
    <span class="javadoc">/** 定义了一个线程本地存储的成员变量 **/</span>
    <span class="keyword">private</span> ThreadLocal&lt;LocalObject&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;LocalObject&gt;();

    <span class="keyword">public</span> <span class="title">LocalStoreThread</span>(LocalObject lo) {
        <span class="comment">// set之前打印当前线程</span>
        System.out.println(Thread.currentThread().getName());   <span class="comment">// main</span>
        threadLocal.set(lo);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="comment">// get之前打印当前线程</span>
        System.out.println(Thread.currentThread().getName()); <span class="comment">// Thread-0</span>
        System.out.println(threadLocal.get().getName());
    }
}

<span class="javadoc">/**
 * &lt;pre&gt;
 * 创建一个线程实例，这个线程实例中有一个线程本地存储成员变量
 * &lt;/pre&gt;
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        LocalObject lo = <span class="keyword">new</span> LocalObject();
        lo.setName(<span class="string">"thread-local"</span>);
        <span class="keyword">new</span> LocalStoreThread(lo).start();
    }
}
</pre></td></tr></table></figure>

<p>好，问题出现了，set时的当前线程和get时的当前线程不一样，所以get的结果是null。set是写在线程的构造函数中的，此时当前线程是main线程，因为在main线程中创建线程。但是在run方法中当前线程已经不是main线程了变成了new出来的这个新线程了。</p>
<h4 id="三-ThreadLocal中get和set方法分析">三.ThreadLocal中get和set方法分析</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">public</span> T <span class="title">get</span>() {
        <span class="comment">// 获取当前线程实例</span>
        Thread t = Thread.currentThread();
        <span class="comment">/* 获取当前线程实例的ThreadLocalMap，其实就是一个数组
         * 这个数组可以扩容，每次空间不够时都拿当前大小*2
         */</span>
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>) {
            <span class="comment">/*根据this哈希获取数组中的一个元素*/</span>
            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);
            <span class="keyword">if</span> (e != <span class="keyword">null</span>)
                <span class="keyword">return</span> (T)e.value;
        }
        <span class="comment">// 如果当前线程的ThreadLocalMap为null,就创建一个</span>
        <span class="keyword">return</span> setInitialValue();
}
<span class="keyword">private</span> T <span class="title">setInitialValue</span>() {
        <span class="comment">/* 这里调用了ThreadLocal的initValue方法，一般都会在创建ThreadLocal
         * 实例的时候重写这个方法，比如说ThreadLocal中要是存放数据库链接对象的
         * 话，就需要一个初始化方法来初始化这个数据库链接对象
         */</span>
        T value = initialValue();
        <span class="comment">/*把初始化好的值保存起来*/</span>
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>)
            map.set(<span class="keyword">this</span>, value);
        <span class="keyword">else</span>
            createMap(t, value);
        <span class="keyword">return</span> value;
}
<span class="comment">/*创建线程的ThreadLocalMap*/</span>
<span class="keyword">void</span> createMap(Thread t, T firstValue) {
        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);
}
<span class="comment">/*获取线程的ThreadLocalMap*/</span>
ThreadLocalMap getMap(Thread t) {
        <span class="keyword">return</span> t.threadLocals;
}
</pre></td></tr></table></figure>

<p>上述代码就是ThreadLocal的get源代码，先根据当前线程获取当前线程的ThreadLocalMap,此时获取到的就是一个table数组，接下来根据ThreadLocal实例的threadLocalHashCode来获取table数组中的一个元素，这个元素是个K-V的键值对，此时V就是本地存储的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">/*关于set代码和get代码是对称的*/</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span class="keyword">if</span> (map != <span class="keyword">null</span>)
            map.set(<span class="keyword">this</span>, value);
        <span class="keyword">else</span>
            createMap(t, value);
}
</pre></td></tr></table></figure>

<h4 id="四-ThreadLocal源代码中提供的一个实例代码">四.ThreadLocal源代码中提供的一个实例代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueThreadIdGenerator</span> {</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger uniqueId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);  

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal &lt; Integer &gt; uniqueNum =   
            <span class="keyword">new</span> ThreadLocal &lt; Integer &gt; () {  
        <span class="comment">//定义初始值（副本）  </span>
        <span class="annotation">@Override</span> <span class="keyword">protected</span> Integer <span class="title">initialValue</span>() {  
            <span class="keyword">return</span> uniqueId.getAndIncrement();  
        }  
    };  

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCurrentThreadId</span>() {  
        <span class="comment">// 这里应该要把 uniqueId换成uniqueNum，源码应该是写错了   </span>
        <span class="keyword">return</span> uniqueNum.get();  
    }

    <span class="keyword">static</span> class MyThread extends Thread {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
            System.out.println(UniqueThreadIdGenerator.getCurrentThreadId());
        }
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {
            <span class="keyword">new</span> MyThread().start();
        }
    }
}
</pre></td></tr></table></figure>

<p>这里总共创建了5个线程，每个线程在run方法中调用UniqueThreadIdGenerator.getCurrentThreadId()时，发现每个线程的ThreadLocalMap都是null,所以每次初始化的方法initialValue都会被调用。</p>
<h4 id="五-Thread&amp;&amp;ThreadLocal&amp;&amp;ThreadLocalMap之间的关系">五.Thread&amp;&amp;ThreadLocal&amp;&amp;ThreadLocalMap之间的关系</h4>
<p><img src="http://dl.iteye.com/upload/attachment/0084/5636/079ae373-cc30-3a5e-8890-496018582ca0.bmp" alt="图示"></p>
<h4 id="六-总结">六.总结</h4>
<p>一个线程只有一个ThreadLocalMap,其实ThreadLocalMap就是一个table数组，数组中的每个元素都是一个K-V的键值对，其中K就是ThreadLocal实例，在获取本地存储的值的时候根据ThreadLocal实例的threadLocalHashCode来对table进行Hash查找，找到对应的K-V键值对。一个线程可以有多个ThreadLocal实例，那么有多少个ThreadLocal实例就决定了table数组的大小，这个数组是动态增长的，每次要是大小不够，就自动扩充为原来大小的2倍，然后对于原来的元素重新Hash,这个操作的成本还是很大的。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ThreadLocal是JDK的一个线程本地存储的类，我们可以把一些线程私有的数据写在ThreadLocal中，这样这些数据只有一个线程可见，实现了所谓的栈封闭。这样存储一些线程私有的数据，我们就不用去费心考虑如何保证临界资源的互斥访问了，同时对于一个线程，这些私有数据也只做一次初始化。</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[幂等性&&数据库的锁]]></title>
    <link href="http://yangbolin.cn/2014/10/07/idempotency-and-db-lock/"/>
    <id>http://yangbolin.cn/2014/10/07/idempotency-and-db-lock/</id>
    <published>2014-10-07T10:52:48.000Z</published>
    <updated>2014-10-07T11:31:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-幂等性">一.幂等性</h4>
<p>幂等性是高等代数中的概念，这里不是讨论数学上幂等性的概念，而是讨论程序中幂等性。幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的. 声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试.</p>
<a id="more"></a>

<p>比如系统A提供了接口f1给系统B调用，系统B调用了系统A提供的f1接口，发现超时，然后再调用一次，超时可能是由于系统A处理的有点慢导致，此时系统A会感知到接口f1的两次调用，如果f1是给用户的账户增加10000RMB的话，这样的场景可能会导致最终给用户增加了N*10000RMB(N&gt;1)，此时接口f1就需要做幂等性处理，不管这个请求重复调用多少次，最终只会给用户增加10000RMB，首先我们需要从业务层面去思考看能否解决这个问题，一般的业务都会根据业务逻辑推算出那些重复请求的，实在推算不出的话，我们就需要做额外的处理了，要求调用方调用f1的时候传递一个唯一性的请求标识进来，系统A感知到f1的调用后，会先查当前请求标识是否已经被接受，如果被接收的话，先看是处理中还是已经完成，如果是这两个状态中的任何一个，我们都认为是重复调用。要是查不到记当前请求被接受的记录的话，先插入一条当前请求被接受的记录，并且状态记录为处理中，然后再去处理请求，此时如果请求处理成功就把请求被接受的记录状态修改为处理成功，要是处理失败就把请求被接受的记录删除。如果处理成功就把当前请求被接受的记录状态修改为处理成功。</p>
<h4 id="二-数据库锁">二.数据库锁</h4>
<p>我们在写代码的时候经常会遇到这样的场景，从数据库中读取一批数据出来，然后根据一些逻辑条件修改这批数据，修改完后写回到数据库中，我们读出数据进行逻辑处理时，数据库中的这些数据可能已经发生变化了。为了保证上面数据的正确性，我们需要引入数据库的锁来解决这个问题即select for update锁，先对需要修改的记录加锁，等数据库事务提交后再把锁释放，这个过程中其他对数据的修改要先拿到这个锁才能继续做写操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> XXXTable <span class="keyword">WHERE</span> conditions <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span>
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-幂等性">一.幂等性</h4>
<p>幂等性是高等代数中的概念，这里不是讨论数学上幂等性的概念，而是讨论程序中幂等性。幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的. 声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试.</p>
]]></summary>
    
      <category term="Experience" scheme="http://yangbolin.cn/tags/Experience/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM常用命令总结]]></title>
    <link href="http://yangbolin.cn/2014/09/17/jvm-cmd/"/>
    <id>http://yangbolin.cn/2014/09/17/jvm-cmd/</id>
    <published>2014-09-17T11:38:19.000Z</published>
    <updated>2014-11-19T13:36:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="GC相关">GC相关</h4>
<p>jstat -gcutil pid time<br>实时查看JAVA进程PID的垃圾回收情况，PID表示JAVA进程的ID，time表示统计的时间频率，单位是ms，比如jstat -gcutil 8888 1000 表示每隔1000ms统计一次JAVA进程8888的GC回收。</p>
<a id="more"></a>

<h4 id="内存相关">内存相关</h4>
<p>jmap -dump:format=b,file=/home/admin/xxx.bin PID<br>获取JVM的内存的dump文件</p>
<p>jinfo -flag +HeapDumpBeforeFullGC PID<br>jinfo -flag +HeapDumpAfterFullGC PID<br>设置这两个标记后，可以让JVM在发生FGC前后自动dump堆内存，等dump完后，执行下面的命令去掉这两个标记<br>jinfo -flag -HeapDumpBeforeFullGC PID<br>jinfo -flag -HeapDumpAfterFullGC PID<br>在dump结束后，记得去掉这两个标记</p>
<p>jmap -histo:live PID<br>查看系统中存活的实例数目</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="GC相关">GC相关</h4>
<p>jstat -gcutil pid time<br>实时查看JAVA进程PID的垃圾回收情况，PID表示JAVA进程的ID，time表示统计的时间频率，单位是ms，比如jstat -gcutil 8888 1000 表示每隔1000ms统计一次JAVA进程8888的GC回收。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[裂变思想]]></title>
    <link href="http://yangbolin.cn/2014/09/06/fission-thought/"/>
    <id>http://yangbolin.cn/2014/09/06/fission-thought/</id>
    <published>2014-09-06T02:49:07.000Z</published>
    <updated>2014-09-06T03:16:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>关于裂变这个词语，一开始想到的就是双11的时候红包的裂变，一个红包经过裂变后变成多个红包，让更多的人参与进来，这个红包裂变的想法当时就给自己留下了深刻的印象，其实这不是什么业务的创新，而是算法思想在业务上的经典使用。</p>
<a id="more"></a>

<p>在算法中一个经典的思想就是分治，要解决一个问题A，先把问题A分解为A1，A2，A3三个子问题，这三个子问题解决了，问题A也就得到相应的解决，此时可以理解为问题A在需要解决的时候裂变成3个子问题。问题变多了，但是原来的问题更好解决了，因此在这种状况下面问题变多不一定是坏事情。</p>
<h4 id="二-裂变">二.裂变</h4>
<p>当一些业务点没法在一个实体体现出来的时候，考虑把这个实体裂变，然后修改裂变后实体的相关状态以满足业务需求，此时实体A裂变成两个实体A1和A2，裂变后实体A就不存在了，但是通过A1和A2上的一些关联信息一定能推理出A1和A2是实体A裂变而来的。<br><img src="http://bolinyoung.qiniudn.com/%E8%A3%82%E5%8F%98.png" alt="裂变"></p>
<h4 id="三-总结">三.总结</h4>
<p>在设计的时候注意裂变思想的灵活使用，虽然很简单，但是能不能灵活使用是另外一个问题。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>关于裂变这个词语，一开始想到的就是双11的时候红包的裂变，一个红包经过裂变后变成多个红包，让更多的人参与进来，这个红包裂变的想法当时就给自己留下了深刻的印象，其实这不是什么业务的创新，而是算法思想在业务上的经典使用。</p>
]]></summary>
    
      <category term="Algorithm" scheme="http://yangbolin.cn/tags/Algorithm/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次velocity异常的分析]]></title>
    <link href="http://yangbolin.cn/2014/08/22/velocity-exception-analyze/"/>
    <id>http://yangbolin.cn/2014/08/22/velocity-exception-analyze/</id>
    <published>2014-08-22T14:05:14.000Z</published>
    <updated>2014-08-22T16:41:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>最近在使用velocity模板的时候RuntimeInstance的1103行代码出现了NPE,如下图所示<br><img src="http://bolinyoung.qiniudn.com/velocity-npe.png" alt="velocity-npe"><br>该行代码一直在抛NPE。</p>
<a id="more"></a>

<h4 id="二-分析">二.分析</h4>
<p>RuntimeInstance的1103行出现NPE原因只有一个，那就是parserPool是NULL，现在我们只要搞清楚parserPool为啥在这里是NULL，我们就知道这个NPE出现的原因了，看上面的图，我们发现在执行1103行代码的时候调用了requireInitialization()，那么此时需要看看requireInitialization()到底做了那些事情。<br><img src="http://bolinyoung.qiniudn.com/requireInitialization.png" alt="requireInitialization"><br>我们看到了requireInitialization中调用了init方法，但是这个方法可能抛出异常。关于requireInitialization方法中的代码很有疑问，首先想到的是并发问题，这里怎么没考虑到多个线程并发初始化的问题呢？其次，initialized标识当前实例是否已经被初始化了，能进入到if分支中，说明当前实例肯定没有被初始化，因此initialized值一定是false，initializing标识当前实例正在被初始化,能进入到if分支中，说明当前实例没有被正在初始化，因此initializing的值一定是false。接下来我们看看init的代码<br><img src="http://bolinyoung.qiniudn.com/init.png" alt="init"><br>一开始怀疑并发的问题，看了init的代码后，这个点就不用再去怀疑了。init中也有一个if分支，进入if分支的逻辑和requireInitialization进入if分支的逻辑是一样的，这里就不再进行分析了，关键看2处的代码，此时会标记当前实例正在被初始化，加入initializeParserPool()方法中抛出了一个Exception，此时下面的代码就不会被执行，当前方法栈帧直接退出，当前线程获取的锁也会被释放(后面给出验证的例子)，此时initializing值没有机会设置成false了，也就是说3处的代码没法机会执行了，直接回到requireInitialization方法中，该方法中捕获了这个异常，此时问题就出现了，等下次再初始化的时候requireInitialization中的init方法永远就不会被调用了，此时1103行代码就一直NPE了，由于错过了第一次init时的真正异常，后面看到就一直是NPE，不知道NPE的具体原因是啥了，也就是说requireInitialization中catch住的异常后续发现不了。</p>
<h4 id="三-解决思路">三.解决思路</h4>
<p>通过上面的分析，我们只要找到requireInitialization中catch住的异常是啥，问题也就差不多解决了，因为第一次初始化的时候异常已经发生了，后续的初始化都不会进入到requireInitialization中的if分支了，此时要么重启系统去看第一初始化时异常是什么，要么找日志，debug神器中可以动态修改变量的值，那么在requireInitialization的if分支处设置断点，然后动态修改initializing的值为false,此时异常出现了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Failed <span class="built_in">to</span> initialize <span class="operator">an</span> instance <span class="operator">of</span> org.apache.velocity.runtime.<span class="built_in">log</span>.Log4JLogChute <span class="operator">with</span> <span class="operator">the</span> current runtime configuration.
</pre></td></tr></table></figure>

<p> 异常信息表明可能log有问题，因为出现Log4J关键词了，这个异常很陌生，不知如何解决，直接去谷歌一下就能解决问题，一般参考stackoverflow上的答案，有人说在velocity引擎初始化的时候增加下面代码即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Properties p = <span class="keyword">new</span> Properties();
p.setProperty(<span class="string">"runtime.log.logsystem.class"</span>, <span class="string">"org.apache.velocity.runtime.log.NullLogSystem"</span>);
<span class="keyword">try</span> {
      INSTANCE.init(p);
} <span class="keyword">catch</span> (Exception e) {
      LOG.error(e);
}
</pre></td></tr></table></figure>

<p>索性试一下，发现问题解决啦。</p>
<h4 id="四-总结">四.总结</h4>
<p>1.个人认为RuntimeInstance的requireInitialization方法有BUG，应该增加finally分支，在该分支中把initializing设置为false，后续可以考虑修复一下velocity的这个BUG，在开源项目中贡献一些代码。<br>2.遇见陌生异常时记得谷歌，记得stackoverflow。<br>3.在分析的过程中，自己突然想到一个问题，synchronized修饰的方法内部抛出Exception后当前线程获取到锁会不会释放，答案是会释放，深层次的分析估计要看JVM源码了，这里给出验证的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> {</span>

    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span>() <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (<span class="keyword">true</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"test exception"</span>);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        SynchronizedTest oo = <span class="keyword">new</span> SynchronizedTest();
        
        <span class="keyword">new</span> ThreadModel1(oo).start();
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">1000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        <span class="keyword">new</span> ThreadModel2(oo).start();
    }
}

class ThreadModel1 extends Thread {

    <span class="keyword">private</span> SynchronizedTest synchronizedTest;
    <span class="keyword">public</span> <span class="title">ThreadModel1</span>(SynchronizedTest synchronizedTest) {
        <span class="keyword">this</span>.synchronizedTest = synchronizedTest;
    }
    
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">try</span> {
            synchronizedTest.init();
        } <span class="keyword">catch</span> (Exception e) {
            System.out.println(<span class="string">"ThreadModel1 Exception..."</span>);
            <span class="keyword">while</span>(<span class="keyword">true</span>) {}
        }
    }
}

class ThreadModel2 extends Thread {

    <span class="keyword">private</span> SynchronizedTest synchronizedTest;
    <span class="keyword">public</span> <span class="title">ThreadModel2</span>(SynchronizedTest synchronizedTest) {
        <span class="keyword">this</span>.synchronizedTest = synchronizedTest;
    }
    
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">try</span> {
            synchronizedTest.init();
        } <span class="keyword">catch</span> (Exception e) {
            System.out.println(<span class="string">"ThreadModel2 Exception..."</span>);
        }
    }
}
</pre></td></tr></table></figure>

<p>输出结果:<br>ThreadModel1 Exception…<br>ThreadModel2 Exception…</p>
<p>ThreadModel2线程能继续运行并且输出结果，说明init上的锁已经被ThreadModel1线程所释放。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>最近在使用velocity模板的时候RuntimeInstance的1103行代码出现了NPE,如下图所示<br><img src="http://bolinyoung.qiniudn.com/velocity-npe.png" alt="velocity-npe"><br>该行代码一直在抛NPE。</p>
]]></summary>
    
      <category term="velocity" scheme="http://yangbolin.cn/tags/velocity/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次JVM分享的相关记录]]></title>
    <link href="http://yangbolin.cn/2014/08/16/a-jvm-share/"/>
    <id>http://yangbolin.cn/2014/08/16/a-jvm-share/</id>
    <published>2014-08-16T07:44:15.000Z</published>
    <updated>2014-09-09T03:46:50.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近看见公司一位前辈有分享JVM相关的知识，自己特地从跑过去听了一下，感觉讲的不是很深入，但是相对来说还是不错的，本文就自己听到的一些东西做一个简单的总结。平时我们大多数都是用JAVA写代码,很多人学JAVA都是从HelloWorld开始，但是从你写HelloWorld代码到最终输出HelloWorld到底发生那些事情呢？要想清楚的回答这个问题，并不是很容易，你需要对JVM有一个清晰的了解后，才能说清楚这个问题，这只是一个引子，本文也不去挑战这个问题，这里主要记录一下自己从这个分享中听到的一些感兴趣的东西。</p>
<a id="more"></a>

<h4 id="二-JVM运行时数据区">二.JVM运行时数据区</h4>
<p><img src="http://bolinyoung.qiniudn.com/jvmdataarea.png" alt="JVM运行时数据区"></p>
<p>JVM运行时数据区域分为堆内存和非堆内存。注意这里的程序计数器，和CPU没有关系，不要看见Register就认为是CPU的寄存器，每个方法都会由一系列的字节码组成，这里的PC指向的是当前要执行的字节码，执行完字节码后，PC就会向前移动。</p>
<h4 id="三-类初始化">三.类初始化</h4>
<p>在JAVA代码中，我们经常写class，JVM加载一个类的时候，先会初始化一个类实例，这个初始化好的类实例存储在perm区中，注意这个类实例不是我们在代码中new出来的对象实例，我们在代码中new出来的对象实例是存储在堆内存中的，也就是说new一个对象的实例和类实例是存储在不同地方的。</p>
<p><img src="http://bolinyoung.qiniudn.com/classinitprocess.png" alt="类初始化的过程"></p>
<p>类初始化的过程总体上分为Load,Link,Initialize三个阶段，当代码中需要某个类的时候，JVM先会在classpath中尝试去找，如果找不到相应的类，此时会抛出ClassNotFoundException，如果能找到相应的类，就会看这类是否有使用其他的类，有的话，又会去加载当前类依赖的类，接下来会做Link，其实和C/C++编译时的Link是一样的，把当前类所需要的其他类放在一起，看看会不会有问题，Link分为三个阶段，字节码校验，当然这个校验可以通过JVM参数去掉，即verify，prepare阶段会对类的静态成员变量做初始化，比如int会被初始化为0,引用类型会被初始化为null，resolve阶段就是看看当前类所依赖的其他类有没有问题，比如classA依赖classB，在classA中使用classB中的方法f，此时会校验classB中方法f是否存在。最后就是Initialize了，这里的Initialize其实就是执行clinit方法。</p>
<p>注意Link中的Prepare阶段会对类静态成员初始化，我们new一个实例的时候，类的非静态成员变量也有类似初始化的过程，但是这两个初始化不是发生在同一个阶段，new的时候会在堆内存上分配内存空间，此时也会对非静态成员变量做初始化。</p>
<p>下面我们来分析一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span> {</span>

    <span class="keyword">static</span> {
        a = <span class="number">1</span>;
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  a = <span class="number">0</span>;
	
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        System.out.println(StaticCode.a);
    }
}
</pre></td></tr></table></figure>

<p>这段代码的输出结果是什么？<br>首先考虑这段代码会不会有编译的问题，提前使用了静态成员变量a。自己编译一下就知道了，这段代码不会有编译的问题。输出结果是0。自己运行一下就知道了。但是为啥结果是0呢？我们来分析一下字节码，看看为啥结果是0<br>使用javap -verbose来查看字节码，注意字节码中静态代码块<br><img src="http://bolinyoung.qiniudn.com/staticcode-0.png" alt="StaticCode中的静态代码块"><br>其实这个静态代码块对应的方法就是clinit方法。这个方法中有5条字节码指令，偏移量0和1处的字节码表示获取常量1并且赋值给静态成员变量i,这两个字节码指令从哪里来的呢？就是声明静态代码块中对静态成员变量a的赋值操作。偏移量4和5处的字节码表示声明静态成员变量a时的赋值操作，此时这个赋值操作排在静态代码块中赋值操作的后面，因此输出结果为0。</p>
<p>对于上述代码块，如果我们把static代码块的顺序静态成员变量声明的顺序改变一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span> {</span>

	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  a = <span class="number">0</span>;
	
    <span class="keyword">static</span> {
        a = <span class="number">1</span>;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        System.out.println(StaticCode.a);
    }
}
</pre></td></tr></table></figure>

<p>此时输出结果为1,因为静态成员变量的声明排在静态代码块的前面，此时静态成员变量声明时的赋值字节码会出现静态代码块中赋值字节码的后面，再看看相关的字节码就能发现<br><img src="http://bolinyoung.qiniudn.com/staticcode-0-latter.png" alt="改变顺序后的字节码"></p>
<p>关于静态代码块中的字节码和静态成员变量赋值的字节码谁先执行谁后执行，取决于java代码中静态成员变量和静态代码块出现的先后顺序。</p>
<p>再看一个对象实例化的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>
	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">12</span>;
	<span class="keyword">public</span> <span class="title">Base</span>() {
		foo();
	}
	
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>() {
		System.out.println(i);
	}
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> {</span>
	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">13</span>;
	
	<span class="keyword">public</span> <span class="title">Child</span>() {
	}
	
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>() {
		System.out.println(i);
	}
	
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		<span class="keyword">new</span> Child();
	}
}
</pre></td></tr></table></figure>

<p>这段代码很简单，在基类构造函数中调用foo方法，这个方法被派生类重写了，此时输出结果为多少？<br>运行发现此时输出结果为0,首先我们new Child()后在基类构造函数中调用的foo方法一定是在派生类中重写过的foo方法，因为当前实例对象是派生类类型的，初始化实例的时候都是先初始化父类，再初始化子类，这是关键，初始化父类的时候子类还没有初始化好，但是调用子类的foo方法，此时i的值是在分配内存空间时初始化的值，int类型的被初始化为0,因此输出结果为0。我们再来分析一下Child类构造函数的字节码。<br><img src="http://bolinyoung.qiniudn.com/ChildByteCode.png" alt="Child类构造函数字节码"><br>JVM调用每个方法的时候都会给这个方法创建一个方法栈帧，每个方法栈帧都包含一个局部变量表，一个操作数栈，当然还有其他的比如堆栈映射表。局部变量表其实就是一个数组，实例方法中局部变量表的第一元素表示当前实例this，我们看看Child构造函数的字节码发现第一条就是aload_0，表示把局部变量表的第0个元素放到栈顶，也就是this引用放到栈的顶部，然后执行invokespecial，即调用父类的构造函数，调用结束后，栈顶的this引用会被弹出，因此需要继续给栈顶压一个this引用，因为后面要对成员变量i赋值，执行aload_0后就能把this引用再次压入到栈顶部，bipush 13标识把13转换成int型的值，然后压入到栈的顶部，putfield表示弹出栈顶的整型值，赋值给成员变量i，此时栈顶部就是this引用了，this引用也会被弹出，因为赋值的时候需要知道变量i是哪个实例的成员变量。分析完这段字节码后，输出结果为0也就很好解释了。因为调用基类构造函数时，派生类成员变量i的赋值还没有进行。</p>
<p>JVM有一个限制，不允许多个线程去初始化同一个类，当一个线程初始化ClassA的时候，另外一个线程要是也来初始化ClassA的话，此时只能等待，等迁移个线程初始化完后后一个线程直接返回。下面这例子就是来证明这个结论</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>class Lock {}

class Danger {
  <span class="keyword">static</span> {
    System.out.println(<span class="string">"clinit begin..."</span>);
    <span class="keyword">try</span> {
    	Thread.sleep(<span class="number">2000</span>);
    } <span class="keyword">catch</span> (Exception e) {
    	System.out.println(e);
    }
    <span class="keyword">synchronized</span> (Lock.class) 
    { 
    	System.out.println(<span class="string">"clinit done!"</span>);
    }
  }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
  	<span class="comment">// 创建一个线程,此处标记为Thread1，方便下面好描述</span>
    <span class="keyword">new</span> Thread() {
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">synchronized</span> (Lock.class) {
          System.out.println(<span class="string">"new thread start!"</span>);
          <span class="keyword">try</span> {
          	Thread.sleep(<span class="number">1000</span>);
          } <span class="keyword">catch</span> (Exception e) {
          	System.out.println(e);
          }
          <span class="keyword">new</span> Danger();
        }
        System.out.println(<span class="string">"new thread end!"</span>);
      }
    }.start();
    <span class="keyword">try</span> {
    	Thread.sleep(<span class="number">500</span>);
    } <span class="keyword">catch</span> (Exception e) {
    	System.out.println(e);
    }
    
    System.out.println(<span class="keyword">new</span> Danger());
    System.out.println(<span class="string">"DONE!"</span>);
  }
}
</pre></td></tr></table></figure>

<p>上述代码运行就会死锁。<br>现在我们来分析为什么会死锁，线程Thread1先执行获取到Lock.class上的锁，然后sleep等待1000ms,此时Main线程sleep等待500ms，Main线程睡醒后，开始创建Danager实例，然后在创建Dananger实例时执行Danager类实例初始化的代码，在类初始化的代码中sleep等待2000ms,在这个过程中Thread1睡醒了，然后也去创建Danger实例，当然也需要执行类实例初始化的代码了，但是Main线程正在执行Danger类实例的初始化，因此Thread1只能等待，等Main线程睡醒了，但是需要等Thread1释放Lock.class上的锁才能完成Danger类实例初始化，此时Thread1等Main线程初始化完Danger类，Main线程等Thread1释放Lock.class上的锁，因此Thread1和Main互等，形成死锁，死锁的本质原因就是JVM不允许多个线程同时初始化一个类实例。</p>
<p>同事F说这段代码写的太复杂了，不太好理解，的确，然后F给出了一个更简单的例子证明JVM不允许多个线程同时初始化一个类实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownDeadLock</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object referObject = <span class="keyword">new</span> Object();
    <span class="keyword">static</span> {
        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                <span class="keyword">if</span> (referObject == <span class="keyword">null</span>)
                ;
            }

        });
        System.exit(<span class="number">0</span>);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {

    }
}
</pre></td></tr></table></figure>

<p>上述代码会导致JVM没法退出，static代码块中在类初始化的时候会执行，System.exit(0);会导致JVM退出，但是有一个JVM退出时回调的钩子线程，这个线程会访问ShutDownDeadLock的静态成员变量referObject，但是此时ShutDownDeadLock类实例不允许其他线程使用，因为当前类实例正在被初始化，被JVM加锁了。</p>
<p>上面的代码做如下修改就能正常退出了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownUnDeadLock</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object referObject = <span class="keyword">new</span> Object();
    
    <span class="keyword">static</span> {
        <span class="keyword">final</span> Object oo = referObject;
        
        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                <span class="keyword">if</span> (oo == <span class="keyword">null</span>)
                ;
            }

        });
        System.exit(<span class="number">0</span>);
    }
    

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {

    }
}
</pre></td></tr></table></figure>

<p>此时JVM能够正常退出，因此线此时访问oo时不需要通过ShutDownUnDeadLock类实例来访问，直接从方法栈帧的局部变量表中读取，也就是说直接从栈上读取。</p>
<p>我们经常在代码中定义常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IQuantConstant</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IQUANT_PAGE_SIZE = <span class="number">30</span>;
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IQuantConstantTest</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		System.out.println(IQuantConstant.IQUANT_PAGE_SIZE);
	}
}
</pre></td></tr></table></figure>

<p>如果IQuantConstant和IQuantConstantTest在不同的JAR包中，此时修改了IQuantConstant中常量IQUANT_PAGE_SIZE的值后，另外一个JAR包感知不到，这个是编译器做的优化，编译的时候直接把IQUANT_PAGE_SIZE的值拷贝过去。</p>
<p>TLAB是指thread local allocation buffers，用来避免线程竞争同步的开销。</p>
<p>一个class能被卸载的前提是加载这个class的classloader加载的所有类都能被卸载，这个在使用groovy脚本时要注意，容易引起classloader的泄漏，导致perm区OOM。perm区的gc就能卸载满足条件的class。</p>
<h4 id="三-GC相关">三.GC相关</h4>
<p><img src="http://bolinyoung.qiniudn.com/cmsgc.png" alt="CMS"><br>使用CMS垃圾回收的时候，会有两次stop-the-world,因此使用jstat -gcutil查看FGC次数时，发现每次FGC都是增加2。</p>
<p>新生代分为eden区，s0和s1,之所以有s0和s1两个对等的区，是因为MinorGC采用的是拷贝复制的算法进行垃圾回收，MinorGC会把存活的对象从s0拷贝到s1，或者从s1拷贝到s0。</p>
<p>GC算法<br>标记-清除，该算法先去标记可回收的对象，然后再一个个回收调，容易产生内存碎片。</p>
<p>复制，该算法把内存划分为两个对等的区域，把存活的对象直接从一个区域拷贝到另外一个区域。</p>
<p>标记-整理，先标记出需要可回收的对象，然后对不可回收的对象进行移动，让不可回收的对象集中在内存的一端。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近看见公司一位前辈有分享JVM相关的知识，自己特地从跑过去听了一下，感觉讲的不是很深入，但是相对来说还是不错的，本文就自己听到的一些东西做一个简单的总结。平时我们大多数都是用JAVA写代码,很多人学JAVA都是从HelloWorld开始，但是从你写HelloWorld代码到最终输出HelloWorld到底发生那些事情呢？要想清楚的回答这个问题，并不是很容易，你需要对JVM有一个清晰的了解后，才能说清楚这个问题，这只是一个引子，本文也不去挑战这个问题，这里主要记录一下自己从这个分享中听到的一些感兴趣的东西。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用ASMifier]]></title>
    <link href="http://yangbolin.cn/2014/07/27/how-to-use-asmifier/"/>
    <id>http://yangbolin.cn/2014/07/27/how-to-use-asmifier/</id>
    <published>2014-07-27T05:53:45.000Z</published>
    <updated>2014-07-27T06:47:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ASM这个字节码处理框架，不仅能够读字节码，而且还能修改字节码，我们经常是先写好JAVA代码，然后编译(IDE或者javac)生成class文件，最后classloader再把相应的class文件加载到内存，但是有了ASM后，我们可以直接使用ASM生成class文件的字节数组，即面向字节码写JAVA代码，这样可以让JVM动态去加载一个类，但是这个类的class文件并不存在磁盘上，也就是说这个类的class文件是在内存中构建出来的。</p>
<a id="more"></a>

<p>下面我们就来看看如何在内存中构造class文件的字节数组，并且让JVM动态加载对应的class.</p>
<h4 id="二-如何使用">二.如何使用</h4>
<p>假如我们我们需要JVM动态加载的类的源代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> ASMTest {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"Hello ASM"</span>);
    }
}
</pre></td></tr></table></figure>

<p>此时这类并不再当前应用所对应的classpath中。当然我们可以自己去分析这个类的字节码，然后一步一步去构造这个类的字节码，但是这样比较麻烦，ASM提供了这样一个工具，可以把一个编译过的class文件转换一段java代码，运行这段java代码可以产生这个编译过的class文件对应的字节数组。</p>
<p>因此，我们先执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>javac ASMTest<span class="preprocessor">.java</span>
</pre></td></tr></table></figure>

<p>生成ASMTest对应的class文件。接下来我们使用ASMifier来生成可以产生字节数组的代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>java -classpath asm-debug-all-<span class="number">4.1</span><span class="preprocessor">.jar</span>:. org<span class="preprocessor">.objectweb</span><span class="preprocessor">.asm</span><span class="preprocessor">.util</span><span class="preprocessor">.ASMifier</span> ASMTest &gt; ASMTestDump<span class="preprocessor">.java</span>
</pre></td></tr></table></figure>

<p>在执行java命令的时候我们指定了classpath,多个classpath使用冒号分隔，此时一定要保证ASMTest的所在的路径被加入到classpath中，生成的ASMTestDump类如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMTestDump</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">dump</span>() <span class="keyword">throws</span> Exception {

        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);
        MethodVisitor mv;

        cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, <span class="string">"ASMTest"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);
        {
            mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
            mv.visitCode();
            mv.visitVarInsn(ALOAD, <span class="number">0</span>);
            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);
            mv.visitInsn(RETURN);
            mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);
            mv.visitEnd();
        }
        {
            mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"hello"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
            mv.visitCode();
            mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);
            mv.visitLdcInsn(<span class="string">"Hello ASM"</span>);
            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>);
            mv.visitInsn(RETURN);
            mv.visitMaxs(<span class="number">2</span>, <span class="number">1</span>);
            mv.visitEnd();
        }
        cw.visitEnd();

        <span class="keyword">return</span> cw.toByteArray();
    }
}
</pre></td></tr></table></figure>

<p>接下来定义自己的classloader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> {</span>

    <span class="keyword">public</span> Class <span class="title">defineClass</span>(String clazz, <span class="keyword">byte</span>[] bytes) {
        <span class="keyword">return</span> defineClass(clazz, bytes, <span class="number">0</span>, bytes.length);
    }
}
</pre></td></tr></table></figure>

<p>使用自己的classloader加载ASMTestDump产生的字节数组,并通过反射来调用ASMTest类的Hello方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWriterTest</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        MyClassLoader mycl = <span class="keyword">new</span> MyClassLoader();
        Class classInstance = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            classInstance =  mycl.defineClass(<span class="string">"ASMTest"</span>, ASMTestDump.dump());
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
        
        <span class="keyword">if</span> (classInstance != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                Object oo = classInstance.newInstance();
                Method method = classInstance.getMethod(<span class="string">"hello"</span>, <span class="keyword">null</span>);
                method.invoke(oo, <span class="keyword">null</span>);
            } <span class="keyword">catch</span> (InstantiationException e) {
                e.printStackTrace();
            } <span class="keyword">catch</span> (IllegalAccessException e) {
                e.printStackTrace();
            } <span class="keyword">catch</span> (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</pre></td></tr></table></figure>

<p>使用ASMifier就这么简单。</p>
<h4 id="三-总结">三.总结</h4>
<p>ASMifier其实也可以认为是一个编译器，把class文件转换成java代码，这里的java代码并不是反编译后的java代码，而是一段可以生成当前class字节数组的代码，可能很多人会有以为，class文件到字节数组需要这么麻烦吗？我们直接读取class文件，然后字节转换成字节数组不就搞定了么，不用这么绕一大圈的么，关键是有时候字节码并不是存在磁盘上的，需要在内存中动态构建，如果你愿意在内存中写字节码也行。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ASM这个字节码处理框架，不仅能够读字节码，而且还能修改字节码，我们经常是先写好JAVA代码，然后编译(IDE或者javac)生成class文件，最后classloader再把相应的class文件加载到内存，但是有了ASM后，我们可以直接使用ASM生成class文件的字节数组，即面向字节码写JAVA代码，这样可以让JVM动态去加载一个类，但是这个类的class文件并不存在磁盘上，也就是说这个类的class文件是在内存中构建出来的。</p>
]]></summary>
    
      <category term="ASM" scheme="http://yangbolin.cn/tags/ASM/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM字节码指令相关]]></title>
    <link href="http://yangbolin.cn/2014/07/26/jvm-byte-code-attention/"/>
    <id>http://yangbolin.cn/2014/07/26/jvm-byte-code-attention/</id>
    <published>2014-07-26T11:46:08.000Z</published>
    <updated>2014-07-26T12:11:07.000Z</updated>
    <content type="html"><![CDATA[<p>JAVA代码中的每个方法都会被编译成一系列的JVM字节码指令，这些字节码指令会被JVM所执行，从而产生相应的数据，我们通常可以用javap -verbose来查看一个方法的字节码指令。</p>
<a id="more"></a>

<p>记得自己之前写过一个简单编译器，编译之后生成的相关的指令，这写指令的编号都是连续的，因为这些指令被我存储在一个指令数组中，每次执行指令的时候，程序计数器PC就会加一，指向下一条需要执行的指令，但是我们使用javap -verbose查看方法字节码指令时，你会发现方法字节码指令前面的编号不是连续的<br><img src="http://bolinyoung.qiniudn.com/method-byte-code.jpg" alt="方法字节码指令"><br>我们看到Lookup方法有三条字节码指令，为什么这三条字节码指令前面的编号不是0,1,2呢？</p>
<p>这里的编号不是以指令为单位的，而是以字节为单位。<br>字节码指令的结构是：<br>[ opcode ][ operands ]<br>其中opcode一定是1字节的，而operands可能是1字节、2字节、4字节或更多（如switch系指令）。<br>此外，方法的字节码指令都是存储在一个字节数组中的，对于aload_0前面的0表示这个字节码指令在字节数组中的偏移量是0,invokespecial前面的指令标识自己在字节数组中的偏移量是1,return表示自己在字节数组中的偏移量是4,从上面的分析可以知道invokespecial在字节数组中占据1,2,3三个下标对应的字节。</p>
<p>这里顺便提一下几个容易混淆的字节码指令：</p>
<ul>
<li>load指令表示把局部变量区中的数据加载到操作数栈顶部</li>
<li>store指令表示把栈顶的数据存储到局部变量区中</li>
<li>invokevirtual表示调用实例的方法</li>
<li>invokespecial表示调用类的构造方法，实例初始化方法，私有方法</li>
<li>invokestatic表示调用静态方法</li>
<li>invokeinterface表示调用接口方法</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>JAVA代码中的每个方法都会被编译成一系列的JVM字节码指令，这些字节码指令会被JVM所执行，从而产生相应的数据，我们通常可以用javap -verbose来查看一个方法的字节码指令。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA线程模型]]></title>
    <link href="http://yangbolin.cn/2014/07/26/java-thread-model/"/>
    <id>http://yangbolin.cn/2014/07/26/java-thread-model/</id>
    <published>2014-07-26T11:13:14.000Z</published>
    <updated>2014-07-26T11:37:52.000Z</updated>
    <content type="html"><![CDATA[<p>我们在JAVA代码中创建一个线程，这线程在系统中会经历下面5个阶段：<br>New-&gt;Runnable-&gt;Blocked-&gt;Running-&gt;Dead</p>
<a id="more"></a>

<p>这里我们来详细看一下这几个阶段的演变以及转换<br><img src="http://bolinyoung.qiniudn.com/java-thread-model.png" alt="线程状态转换"></p>
<ul>
<li><p>New<br>表示这个线程对象刚刚被创建，它具备线程的一些特性，但是系统没有给它分配资源。</p>
</li>
<li><p>Runnable<br>表示这个线程处于就绪状态，要是能获得CPU的话，线程马上就能运行起来。</p>
</li>
<li><p>Blocked<br>一个正在运行的线程由于某些原因不能继续运行，它将进入阻塞状态。比如线程对象执行suspend(),sleep()等阻塞类型的方法后，线程就会进入BlockedPool，当线程调用resume()方法或者自动苏醒后，线程会进入Runnable状态;线程因为要执行synchronized同步代码块需要获取锁，但是当前要获取的锁被其他线程所占有，此时线程会进入LockPool，要是线程获取到这把锁后，线程又会进入到Runnable状态;线程执行了某个对象的wait()方法，此时线程会进入到WaitPool，当相应对象上的notify方法被调用后，线程就会进入Runnable状态。</p>
</li>
<li><p>Running<br>处于Runnable状态的线程要是能获取到CPU的话，马上就变成Running状态</p>
</li>
<li><p>Dead<br>线程运行结束，或者线程被interrupt，或者线程被stop，线程的生命周期也就结束了。</p>
</li>
</ul>
<p>JVM在执行某个方法的时候，会创建一个方法执行栈帧(Frame),这个栈帧包含局部变量区和操作数栈，在局部变量区的第一个位置上存储当前方法所属的实例对象。</p>
]]></content>
    <summary type="html"><![CDATA[<p>我们在JAVA代码中创建一个线程，这线程在系统中会经历下面5个阶段：<br>New-&gt;Runnable-&gt;Blocked-&gt;Running-&gt;Dead</p>
]]></summary>
    
      <category term="并发" scheme="http://yangbolin.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单元测试Failed的排查]]></title>
    <link href="http://yangbolin.cn/2014/07/26/ut-failed-problems/"/>
    <id>http://yangbolin.cn/2014/07/26/ut-failed-problems/</id>
    <published>2014-07-26T07:47:22.000Z</published>
    <updated>2014-07-26T08:13:24.000Z</updated>
    <content type="html"><![CDATA[<p>最近各种中间件升级的事情，升级中间件可能会出现很多诡异的问题，此时我们需要定位这些问题是自己升级导致还是其他原因导致，升级中间件可能会出现很多JAR包冲突的问题，此时需要一一排查。</p>
<a id="more"></a>

<p>前两天升级后遇到这样的问题，系统中的单元测试在eclipse中单独跑没有问题，但是使用mvn test一起跑就会出现大部分单元测试PASS不了，此时查看单元测试FAIL的日志发现获取数据库连接超时，由于本次升级出现了很多JAR包冲突的问题，导致自己一直在怀疑是不是某个JAR包又冲突了导致数据库连接获取超时了？因此排查思路一直停留在JAR包冲突的这个范围内，查了好久，问题依然没有解决，由于自己维护的这个服务化应用非常重要，不能不管单元测试就发布，同时自己也不会放过这个问题，一定要追查到底。</p>
<p>是不是自己的陷入了排查误区了呢？于是把整个代码的变更自己又回顾了一遍，发现最多的就是JAR包版本的升级，引入新的JAR包版本。记得之前自己总结过一句话：要是一个问题排查了好久没有眉目的话，记得去看看那些被你忽略过的细节问题，很可能问题就出现这些被忽略的细节上面。</p>
<p>那到底那些细节被忽略了呢？问题的现象是什么？单个跑UT能够PASS,批量跑UT一部分不能PASS,因为数据库连接获取超时，单个和批量就是这里的细节了，此时自己有一种突然醒悟的感觉，问题就这里了，单个跑只获取一个数据库连接，批量跑会获取多个数据库连接，数据库连接池的问题，不是我升级导致，因此找DBA搞定这个问题。</p>
<p>其实这个问题很简单，发现自己有时候很容易被最近刚出现的问题困扰住，思路一直停留如何最近刚出现的问题上，以后需要注意分析问题出现的本质原因，比如数据连接获取不到其实跟JAR包冲突的关系不是很大，可以说几乎没啥关系，不要受一些最近出现的问题的影响，避免思路被困住。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近各种中间件升级的事情，升级中间件可能会出现很多诡异的问题，此时我们需要定位这些问题是自己升级导致还是其他原因导致，升级中间件可能会出现很多JAR包冲突的问题，此时需要一一排查。</p>
]]></summary>
    
      <category term="单元测试" scheme="http://yangbolin.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="开发杂谈" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IBatis不同版本对parameterMap的处理]]></title>
    <link href="http://yangbolin.cn/2014/07/23/ibatis-version-for-parametermap/"/>
    <id>http://yangbolin.cn/2014/07/23/ibatis-version-for-parametermap/</id>
    <published>2014-07-23T11:58:04.000Z</published>
    <updated>2014-07-23T12:46:37.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>今天在升级一个监控的中间件时，发现必须升级ibatis的版本到2.3.4,原来ibatis的版本是2.3.0,升级后，发现sqlmap的解析出问题了，对于parameterMap这个标签解析出错，原因是parameterMap对应class没法实例化，为什么原来没有问题，升级后就有问题了呢？这时候只能怀疑版本的问题,2.3.4和2.3.0在解析parameterMap时有所不同。</p>
<a id="more"></a>

<p>下面是我们应用中一份sqlmap中写的parameterMap<br><img src="http://bolinyoung.qiniudn.com/parameterMap.png" alt="parameterMap"></p>
<p>其实这个parameterMap在这份配置文件中压根就没有被使用过，TA-COACH-CONFIG-PARAM这个class在当前的classpath中显然不存在，同时也不是某个class在sqlmap中的别名，因此在解析的时候会报TA-COACH-CONFIG-PARAM这个class找不到。</p>
<h5 id="二-到底那里不一样">二.到底那里不一样</h5>
<p>那具体到ibatis的源代码中，那些代码发生了变更呢？我们首先找到解析sqlmap的类即SqlMapParser这个类，先看看2.3.0中这个类解析paramterMap的行为<br><img src="http://bolinyoung.qiniudn.com/parameterMap230.png" alt="2.3.0"><br>我们看到在2.3.0这个版本中拿到parameterClassName后，尝试去实例化这个类型的实例，此时要是这个类找不到就出现Exception，但是该版本中没有处理这个异常，就是说这个异常默默地被吞了。</p>
<p>接下来再看看2.3.4中SqlMapParser解析parameterMap的行为<br><img src="http://bolinyoung.qiniudn.com/parameterMap234.png" alt="2.3.4"><br>其实在2.3.0中作者已经意识到这个事情了，只是写了TODO，在2.3.4中正式开始抛出异常了。</p>
<p>综上所述：<br>在ibatis的配置的文件中，要么使用类的权限定名，要么使用类的别名，要是一个class在classpath中不存在，但是你在sqlmap中使用了，你就等着翻源码查问题吧。还好上面的那个parameterMap形同虚设，我可以放心地删了它。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>今天在升级一个监控的中间件时，发现必须升级ibatis的版本到2.3.4,原来ibatis的版本是2.3.0,升级后，发现sqlmap的解析出问题了，对于parameterMap这个标签解析出错，原因是parameterMap对应class没法实例化，为什么原来没有问题，升级后就有问题了呢？这时候只能怀疑版本的问题,2.3.4和2.3.0在解析parameterMap时有所不同。</p>
]]></summary>
    
      <category term="IBatis" scheme="http://yangbolin.cn/tags/IBatis/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase的基础类型KeyValue]]></title>
    <link href="http://yangbolin.cn/2014/07/20/hbase-keyvalue-type/"/>
    <id>http://yangbolin.cn/2014/07/20/hbase-keyvalue-type/</id>
    <published>2014-07-20T08:22:39.000Z</published>
    <updated>2014-07-20T09:38:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>HBase是面向列的存储数据的，最终的存储单元都是KeyValue的结构，HBase本身也定义了一个KeyValue的类型，这是HBase数据存储的基本类型。那么KeyValue本身会存储那些信息呢？</p>
<a id="more"></a>

<p>从名字来看应该只有两个数据，一个是Key,一个是Value,的确如此，不过这里的Key是多个元素的聚合，有rowkey,列族，列名，时间戳以及key的类型，key的类型定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Type {
    Minimum((<span class="keyword">byte</span>)<span class="number">0</span>),
    Put((<span class="keyword">byte</span>)<span class="number">4</span>),

    Delete((<span class="keyword">byte</span>)<span class="number">8</span>),
    DeleteColumn((<span class="keyword">byte</span>)<span class="number">12</span>),
    DeleteFamily((<span class="keyword">byte</span>)<span class="number">14</span>),

    <span class="comment">// Maximum is used when searching; you look from maximum on down.</span>
    Maximum((<span class="keyword">byte</span>)<span class="number">255</span>);
    ....
  }
</pre></td></tr></table></figure>

<h4 id="二-KeyValue结构概述">二.KeyValue结构概述</h4>
<p><img src="http://bolinyoung.qiniudn.com/HBase-key-value.png" alt="HBase的KeyValue"></p>
<p>HBase的KeyValue内部维护着一个字节数组，然后通过不同的偏移量来获取不同的部分，前面说过KeyValue本身就两部分，Key&amp;&amp;Value,因此KeyLength标识KeyValue中Key在字节数组中所占的长度，ValueLength标识Value在字节数组中所占的长度。观察上图，我们看到从RowLength到KeyType都是KeyValue这个基本类型的Key,我们来看一下这个Key中包含那些东西，RowLength即rowkey的长度，RowKey即rowkey的内容，ColumnFamilyLength即列族的长度，ColumnFamily即列族的内容，ColumnQualifier即列的名称，TimeStamp即时间戳，KeyType即Key的类型，前面已经介绍过。</p>
<p>我们看到从ColumnQualifier开始内容前面不在带有长度了，关于TimeStamp和KeyType很好理解，因为他们所占的字节数目是固定，时间戳是一个long型的数字，占固定、字节数目，KeyType看其定义就能知道占1个字节，此时就剩下ColumnQualifier了，列名所占的字节数目计算一下即可，KeyLength-RowLength-ColumnFamilyLength即可，其中TimeStamp以及KeyType所占的字节长度不计算到KeyLength中，虽然他们是Keyalue中key的一部分，原因就是他们的长度固定，没有必要单独表示。<br>下面我们看看KeyValue中计算列名所占字节数目的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>  <span class="comment">// 字节数组中用固定长度的字节数目表示内容所占的字节数目</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEY_INFRASTRUCTURE_SIZE = ROW_LENGTH_SIZE
      + FAMILY_LENGTH_SIZE + TIMESTAMP_TYPE_SIZE;
      
  ......
  <span class="javadoc">/**
   *<span class="javadoctag"> @return</span> Qualifier length
   */</span>
  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQualifierLength</span>() {
    <span class="keyword">return</span> getQualifierLength(getRowLength(),getFamilyLength());
  }

  <span class="javadoc">/**
   *<span class="javadoctag"> @return</span> Qualifier length
   */</span>
  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQualifierLength</span>(<span class="keyword">int</span> rlength, <span class="keyword">int</span> flength) {
    <span class="comment">// KeyLength-表示长度的字节数目-rowKeyLength-familyLength即列名所占的字节数目</span>
    <span class="keyword">return</span> getKeyLength() -
      (KEY_INFRASTRUCTURE_SIZE + rlength + flength);
  }
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>HBase是面向列的存储数据的，最终的存储单元都是KeyValue的结构，HBase本身也定义了一个KeyValue的类型，这是HBase数据存储的基本类型。那么KeyValue本身会存储那些信息呢？</p>
]]></summary>
    
      <category term="HBase" scheme="http://yangbolin.cn/tags/HBase/"/>
    
      <category term="大数据" scheme="http://yangbolin.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
