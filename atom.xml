<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BolinYoung's Blog]]></title>
  <subtitle><![CDATA[Believe in yourself]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yangbolin.cn/"/>
  <updated>2014-08-22T16:43:45.955Z</updated>
  <id>http://yangbolin.cn/</id>
  
  <author>
    <name><![CDATA[BolinYoung]]></name>
    <email><![CDATA[boris.yangbl@alibaba-inc.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一次velocity异常的分析]]></title>
    <link href="http://yangbolin.cn/2014/08/22/velocity-exception-analyze/"/>
    <id>http://yangbolin.cn/2014/08/22/velocity-exception-analyze/</id>
    <published>2014-08-22T14:05:14.000Z</published>
    <updated>2014-08-22T16:41:07.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>最近在使用velocity模板的时候RuntimeInstance的1103行代码出现了NPE,如下图所示<br><img src="http://bolinyoung.qiniudn.com/velocity-npe.png" alt="velocity-npe"><br>该行代码一直在抛NPE。</p>
<a id="more"></a>

<h4 id="二-分析">二.分析</h4>
<p>RuntimeInstance的1103行出现NPE原因只有一个，那就是parserPool是NULL，现在我们只要搞清楚parserPool为啥在这里是NULL，我们就知道这个NPE出现的原因了，看上面的图，我们发现在执行1103行代码的时候调用了requireInitialization()，那么此时需要看看requireInitialization()到底做了那些事情。<br><img src="http://bolinyoung.qiniudn.com/requireInitialization.png" alt="requireInitialization"><br>我们看到了requireInitialization中调用了init方法，但是这个方法可能抛出异常。关于requireInitialization方法中的代码很有疑问，首先想到的是并发问题，这里怎么没考虑到多个线程并发初始化的问题呢？其次，initialized标识当前实例是否已经被初始化了，能进入到if分支中，说明当前实例肯定没有被初始化，因此initialized值一定是false，initializing标识当前实例正在被初始化,能进入到if分支中，说明当前实例没有被正在初始化，因此initializing的值一定是false。接下来我们看看init的代码<br><img src="http://bolinyoung.qiniudn.com/init.png" alt="init"><br>一开始怀疑并发的问题，看了init的代码后，这个点就不用再去怀疑了。init中也有一个if分支，进入if分支的逻辑和requireInitialization进入if分支的逻辑是一样的，这里就不再进行分析了，关键看2处的代码，此时会标记当前实例正在被初始化，加入initializeParserPool()方法中抛出了一个Exception，此时下面的代码就不会被执行，当前方法栈帧直接退出，当前线程获取的锁也会被释放(后面给出验证的例子)，此时initializing值没有机会设置成false了，也就是说3处的代码没法机会执行了，直接回到requireInitialization方法中，该方法中捕获了这个异常，此时问题就出现了，等下次再初始化的时候requireInitialization中的init方法永远就不会被调用了，此时1103行代码就一直NPE了，由于错过了第一次init时的真正异常，后面看到就一直是NPE，不知道NPE的具体原因是啥了，也就是说requireInitialization中catch住的异常后续发现不了。</p>
<h4 id="三-解决思路">三.解决思路</h4>
<p>通过上面的分析，我们只要找到requireInitialization中catch住的异常是啥，问题也就差不多解决了，因为第一次初始化的时候异常已经发生了，后续的初始化都不会进入到requireInitialization中的if分支了，此时要么重启系统去看第一初始化时异常是什么，要么找日志，debug神器中可以动态修改变量的值，那么在requireInitialization的if分支处设置断点，然后动态修改initializing的值为false,此时异常出现了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Failed <span class="built_in">to</span> initialize <span class="operator">an</span> instance <span class="operator">of</span> org.apache.velocity.runtime.<span class="built_in">log</span>.Log4JLogChute <span class="operator">with</span> <span class="operator">the</span> current runtime configuration.
</pre></td></tr></table></figure>

<p> 异常信息表明可能log有问题，因为出现Log4J关键词了，这个异常很陌生，不知如何解决，直接去谷歌一下就能解决问题，一般参考stackoverflow上的答案，有人说在velocity引擎初始化的时候增加下面代码即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Properties p = <span class="keyword">new</span> Properties();
p.setProperty(<span class="string">"runtime.log.logsystem.class"</span>, <span class="string">"org.apache.velocity.runtime.log.NullLogSystem"</span>);
<span class="keyword">try</span> {
      INSTANCE.init(p);
} <span class="keyword">catch</span> (Exception e) {
      LOG.error(e);
}
</pre></td></tr></table></figure>

<p>索性试一下，发现问题解决啦。</p>
<h4 id="四-总结">四.总结</h4>
<p>1.个人认为RuntimeInstance的requireInitialization方法有BUG，应该增加finally分支，在该分支中把initializing设置为false，后续可以考虑修复一下velocity的这个BUG，在开源项目中贡献一些代码。<br>2.遇见陌生异常时记得谷歌，记得stackoverflow。<br>3.在分析的过程中，自己突然想到一个问题，synchronized修饰的方法内部抛出Exception后当前线程获取到锁会不会释放，答案是会释放，深层次的分析估计要看JVM源码了，这里给出验证的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> {</span>

    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span>() <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (<span class="keyword">true</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"test exception"</span>);
        }
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        SynchronizedTest oo = <span class="keyword">new</span> SynchronizedTest();
        
        <span class="keyword">new</span> ThreadModel1(oo).start();
        <span class="keyword">try</span> {
            Thread.sleep(<span class="number">1000</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        <span class="keyword">new</span> ThreadModel2(oo).start();
    }
}

class ThreadModel1 extends Thread {

    <span class="keyword">private</span> SynchronizedTest synchronizedTest;
    <span class="keyword">public</span> <span class="title">ThreadModel1</span>(SynchronizedTest synchronizedTest) {
        <span class="keyword">this</span>.synchronizedTest = synchronizedTest;
    }
    
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">try</span> {
            synchronizedTest.init();
        } <span class="keyword">catch</span> (Exception e) {
            System.out.println(<span class="string">"ThreadModel1 Exception..."</span>);
            <span class="keyword">while</span>(<span class="keyword">true</span>) {}
        }
    }
}

class ThreadModel2 extends Thread {

    <span class="keyword">private</span> SynchronizedTest synchronizedTest;
    <span class="keyword">public</span> <span class="title">ThreadModel2</span>(SynchronizedTest synchronizedTest) {
        <span class="keyword">this</span>.synchronizedTest = synchronizedTest;
    }
    
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">try</span> {
            synchronizedTest.init();
        } <span class="keyword">catch</span> (Exception e) {
            System.out.println(<span class="string">"ThreadModel2 Exception..."</span>);
        }
    }
}
</pre></td></tr></table></figure>

<p>输出结果:<br>ThreadModel1 Exception…<br>ThreadModel2 Exception…</p>
<p>ThreadModel2线程能继续运行并且输出结果，说明init上的锁已经被ThreadModel1线程所释放。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>最近在使用velocity模板的时候RuntimeInstance的1103行代码出现了NPE,如下图所示<br><img src="http://bolinyoung.qiniudn.com/velocity-npe.png" alt="velocity-npe"><br>该行代码一直在抛NPE。</p>
]]></summary>
    
      <category term="velocity" scheme="http://yangbolin.cn/tags/velocity/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次JVM分享的相关记录]]></title>
    <link href="http://yangbolin.cn/2014/08/16/a-jvm-share/"/>
    <id>http://yangbolin.cn/2014/08/16/a-jvm-share/</id>
    <published>2014-08-16T07:44:15.000Z</published>
    <updated>2014-08-16T14:38:20.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近看见公司一位前辈有分享JVM相关的知识，自己特地从跑过去听了一下，感觉讲的不是很深入，但是相对来说还是不错的，本文就自己听到的一些东西做一个简单的总结。平时我们大多数都是用JAVA写代码,很多人学JAVA都是从HelloWorld开始，但是从你写HelloWorld代码到最终输出HelloWorld到底发生那些事情呢？要想清楚的回答这个问题，并不是很容易，你需要对JVM有一个清晰的了解后，才能说清楚这个问题，这只是一个引子，本文也不去挑战这个问题，这里主要记录一下自己从这个分享中听到的一些感兴趣的东西。</p>
<a id="more"></a>

<h4 id="二-JVM运行时数据区">二.JVM运行时数据区</h4>
<p><img src="http://bolinyoung.qiniudn.com/jvmdataarea.png" alt="JVM运行时数据区"></p>
<p>JVM运行时数据区域分为堆内存和非堆内存。注意这里的程序计数器，和CPU没有关系，不要看见Register就认为是CPU的寄存器，每个方法都会由一系列的字节码组成，这里的PC指向的是当前要执行的字节码，执行完字节码后，PC就会向前移动。</p>
<h4 id="三-类初始化">三.类初始化</h4>
<p>在JAVA代码中，我们经常写class，JVM加载一个类的时候，先会初始化一个类实例，这个初始化好的类实例存储在perm区中，注意这个类实例不是我们在代码中new出来的对象实例，我们在代码中new出来的对象实例是存储在堆内存中的，也就是说new一个对象的实例和类实例是存储在不同地方的。</p>
<p><img src="http://bolinyoung.qiniudn.com/classinitprocess.png" alt="类初始化的过程"></p>
<p>类初始化的过程总体上分为Load,Link,Initialize三个阶段，当代码中需要某个类的时候，JVM先会在classpath中尝试去找，如果找不到相应的类，此时会抛出ClassNotFoundException，如果能找到相应的类，就会看这类是否有使用其他的类，有的话，又会去加载当前类依赖的类，接下来会做Link，其实和C/C++编译时的Link是一样的，把当前类所需要的其他类放在一起，看看会不会有问题，Link分为三个阶段，字节码校验，当然这个校验可以通过JVM参数去掉，即verify，prepare阶段会对类的静态成员变量做初始化，比如int会被初始化为0,引用类型会被初始化为null，resolve阶段就是看看当前类所依赖的其他类有没有问题，比如classA依赖classB，在classA中使用classB中的方法f，此时会校验classB中方法f是否存在。最后就是Initialize了，这里的Initialize其实就是执行clinit方法。</p>
<p>注意Link中的Prepare阶段会对类静态成员初始化，我们new一个实例的时候，类的非静态成员变量也有类似初始化的过程，但是这两个初始化不是发生在同一个阶段，new的时候会在堆内存上分配内存空间，此时也会对非静态成员变量做初始化。</p>
<p>下面我们来分析一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span> {</span>
	<span class="keyword">static</span> {
		a = <span class="number">1</span>;
	}
	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  a = <span class="number">0</span>;
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		System.out.println(StaticCode.a);
	}
}
</pre></td></tr></table></figure>

<p>这段代码的输出结果是什么？<br>首先考虑这段代码会不会有编译的问题，提前使用了静态成员变量a。自己编译一下就知道了，这段代码不会有编译的问题。输出结果是1。自己运行一下就知道了。但是为啥结果是1呢？我们来分析一下字节码，看看为啥结果是1<br>使用javap -verbose来查看字节码，注意字节码中静态代码块<br><img src="http://bolinyoung.qiniudn.com/staticcode.png" alt="StaticCode中的静态代码块"><br>其实这个静态代码块对应的方法就是clinit方法。这个方法中有5条字节码指令，偏移量0和1处的字节码表示获取常量0并且赋值给静态成员变量i,这两个字节码指令从哪里来的呢？就是声明静态成员变量i时的赋值操作对应的字节码。这些字节码会排列在静态代码块本身字节码之前，因为静态成员变量的声明排在static代码块的前面。偏移量4和5出的字节码表示静态代码块中对静态成员变量赋值的字节码。</p>
<p>对于上述代码块，如果我们把static代码块的顺序静态成员变量声明的顺序改变一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span> {</span>
	
	<span class="keyword">static</span> {
		a = <span class="number">1</span>;
	}
	
	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  a = <span class="number">0</span>;
	
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		System.out.println(StaticCode.a);
	}
}
</pre></td></tr></table></figure>

<p>此时输出结果为0,因为静态成员变量的声明排在静态代码块的后面，此时静态成员变量声明时的赋值字节码会出现静态代码块中赋值字节码的后面，再看看相关的字节码就能发现<br><img src="http://bolinyoung.qiniudn.com/staticcode.png" alt="改变顺序后的字节码"></p>
<p>再看一个对象实例化的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>
	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">12</span>;
	<span class="keyword">public</span> <span class="title">Base</span>() {
		foo();
	}
	
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>() {
		System.out.println(i);
	}
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> {</span>
	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">13</span>;
	
	<span class="keyword">public</span> <span class="title">Child</span>() {
	}
	
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span>() {
		System.out.println(i);
	}
	
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		<span class="keyword">new</span> Child();
	}
}
</pre></td></tr></table></figure>

<p>这段代码很简单，在基类构造函数中调用foo方法，这个方法被派生类重写了，此时输出结果为多少？<br>运行发现此时输出结果为0,首先我们new Child()后在基类构造函数中调用的foo方法一定是在派生类中重写过的foo方法，因为当前实例对象是派生类类型的，初始化实例的时候都是先初始化父类，再初始化子类，这是关键，初始化父类的时候子类还没有初始化好，但是调用子类的foo方法，此时i的值是在分配内存空间时初始化的值，int类型的被初始化为0,因此输出结果为0。我们再来分析一下Child类构造函数的字节码。<br><img src="http://bolinyoung.qiniudn.com/ChildByteCode.png" alt="Child类构造函数字节码"><br>JVM调用每个方法的时候都会给这个方法创建一个方法栈帧，每个方法栈帧都包含一个局部变量表，一个操作数栈，当然还有其他的比如堆栈映射表。局部变量表其实就是一个数组，实例方法中局部变量表的第一元素表示当前实例this，我们看看Child构造函数的字节码发现第一条就是aload_0，表示把局部变量表的第0个元素放到栈顶，也就是this引用放到栈的顶部，然后执行invokespecial，即调用父类的构造函数，调用结束后，栈顶的this引用会被弹出，因此需要继续给栈顶压一个this引用，因为后面要对成员变量i赋值，执行aload_0后就能把this引用再次压入到栈顶部，bipush 13标识把13转换成int型的值，然后压入到栈的顶部，putfield表示弹出栈顶的整型值，赋值给成员变量i，此时栈顶部就是this引用了，this引用也会被弹出，因为赋值的时候需要知道变量i是哪个实例的成员变量。分析完这段字节码后，输出结果为0也就很好解释了。因为调用基类构造函数时，派生类成员变量i的赋值还没有进行。</p>
<p>JVM有一个限制，不允许多个线程去初始化同一个类，当一个线程初始化ClassA的时候，另外一个线程要是也来初始化ClassA的话，此时只能等待，等迁移个线程初始化完后后一个线程直接返回。下面这例子就是来证明这个结论</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>class Lock {}

class Danger {
  <span class="keyword">static</span> {
    System.out.println(<span class="string">"clinit begin..."</span>);
    <span class="keyword">try</span> {
    	Thread.sleep(<span class="number">2000</span>);
    } <span class="keyword">catch</span> (Exception e) {
    	System.out.println(e);
    }
    <span class="keyword">synchronized</span> (Lock.class) 
    { 
    	System.out.println(<span class="string">"clinit done!"</span>);
    }
  }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
  	<span class="comment">// 创建一个线程,此处标记为Thread1，方便下面好描述</span>
    <span class="keyword">new</span> Thread() {
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        <span class="keyword">synchronized</span> (Lock.class) {
          System.out.println(<span class="string">"new thread start!"</span>);
          <span class="keyword">try</span> {
          	Thread.sleep(<span class="number">1000</span>);
          } <span class="keyword">catch</span> (Exception e) {
          	System.out.println(e);
          }
          <span class="keyword">new</span> Danger();
        }
        System.out.println(<span class="string">"new thread end!"</span>);
      }
    }.start();
    <span class="keyword">try</span> {
    	Thread.sleep(<span class="number">500</span>);
    } <span class="keyword">catch</span> (Exception e) {
    	System.out.println(e);
    }
    
    System.out.println(<span class="keyword">new</span> Danger());
    System.out.println(<span class="string">"DONE!"</span>);
  }
}
</pre></td></tr></table></figure>

<p>上述代码运行就会死锁。<br>现在我们来分析为什么会死锁，线程Thread1先执行获取到Lock.class上的锁，然后sleep等待1000ms,此时Main线程sleep等待500ms，Main线程睡醒后，开始创建Danager实例，然后在创建Dananger实例时执行Danager类实例初始化的代码，在类初始化的代码中sleep等待2000ms,在这个过程中Thread1睡醒了，然后也去创建Danger实例，当然也需要执行类实例初始化的代码了，但是Main线程正在执行Danger类实例的初始化，因此Thread1只能等待，等Main线程睡醒了，但是需要等Thread1释放Lock.class上的锁才能完成Danger类实例初始化，此时Thread1等Main线程初始化完Danger类，Main线程等Thread1释放Lock.class上的锁，因此Thread1和Main互等，形成死锁，死锁的本质原因就是JVM不允许多个线程同时初始化一个类实例。</p>
<p>同事F说这段代码写的太复杂了，不太好理解，的确，然后F给出了一个更简单的例子证明JVM不允许多个线程同时初始化一个类实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownDeadLock</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object referObject = <span class="keyword">new</span> Object();
    <span class="keyword">static</span> {
        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                <span class="keyword">if</span> (referObject == <span class="keyword">null</span>)
                ;
            }

        });
        System.exit(<span class="number">0</span>);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {

    }
}
</pre></td></tr></table></figure>

<p>上述代码会导致JVM没法退出，static代码块中在类初始化的时候会执行，System.exit(0);会导致JVM退出，但是有一个JVM退出时回调的钩子线程，这个线程会访问ShutDownDeadLock的静态成员变量referObject，但是此时ShutDownDeadLock类实例不允许其他线程使用，因为当前类实例正在被初始化，被JVM加锁了。</p>
<p>上面的代码做如下修改就能正常退出了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownUnDeadLock</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object referObject = <span class="keyword">new</span> Object();
    
    <span class="keyword">static</span> {
        <span class="keyword">final</span> Object oo = referObject;
        
        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() {

            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
                <span class="keyword">if</span> (oo == <span class="keyword">null</span>)
                ;
            }

        });
        System.exit(<span class="number">0</span>);
    }
    

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {

    }
}
</pre></td></tr></table></figure>

<p>此时JVM能够正常退出，因此线此时访问oo时不需要通过ShutDownUnDeadLock类实例来访问，直接从方法栈帧的局部变量表中读取，也就是说直接从栈上读取。</p>
<p>我们经常在代码中定义常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IQuantConstant</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IQUANT_PAGE_SIZE = <span class="number">30</span>;
}
</pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IQuantConstantTest</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
		System.out.println(IQuantConstant.IQUANT_PAGE_SIZE);
	}
}
</pre></td></tr></table></figure>

<p>如果IQuantConstant和IQuantConstantTest在不同的JAR包中，此时修改了IQuantConstant中常量IQUANT_PAGE_SIZE的值后，另外一个JAR包感知不到，这个是编译器做的优化，编译的时候直接把IQUANT_PAGE_SIZE的值拷贝过去。</p>
<p>TLAB是指thread local allocation buffers，用来避免线程竞争同步的开销。</p>
<p>一个class能被卸载的前提是加载这个class的classloader加载的所有类都能被卸载，这个在使用groovy脚本时要注意，容易引起classloader的泄漏，导致perm区OOM。perm区的gc就能卸载满足条件的class。</p>
<h4 id="三-GC相关">三.GC相关</h4>
<p><img src="http://bolinyoung.qiniudn.com/cmsgc.png" alt="CMS"><br>使用CMS垃圾回收的时候，会有两次stop-the-world,因此使用jstat -gcutil查看FGC次数时，发现每次FGC都是增加2。</p>
<p>新生代分为eden区，s0和s1,之所以有s0和s1两个对等的区，是因为MinorGC采用的是拷贝复制的算法进行垃圾回收，MinorGC会把存活的对象从s0拷贝到s1，或者从s1拷贝到s0。</p>
<p>GC算法<br>标记-清除，该算法先去标记可回收的对象，然后再一个个回收调，容易产生内存碎片。</p>
<p>复制，该算法把内存划分为两个对等的区域，把存活的对象直接从一个区域拷贝到另外一个区域。</p>
<p>标记-整理，先标记出需要可回收的对象，然后对不可回收的对象进行移动，让不可回收的对象集中在内存的一端。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>最近看见公司一位前辈有分享JVM相关的知识，自己特地从跑过去听了一下，感觉讲的不是很深入，但是相对来说还是不错的，本文就自己听到的一些东西做一个简单的总结。平时我们大多数都是用JAVA写代码,很多人学JAVA都是从HelloWorld开始，但是从你写HelloWorld代码到最终输出HelloWorld到底发生那些事情呢？要想清楚的回答这个问题，并不是很容易，你需要对JVM有一个清晰的了解后，才能说清楚这个问题，这只是一个引子，本文也不去挑战这个问题，这里主要记录一下自己从这个分享中听到的一些感兴趣的东西。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用ASMifier]]></title>
    <link href="http://yangbolin.cn/2014/07/27/how-to-use-asmifier/"/>
    <id>http://yangbolin.cn/2014/07/27/how-to-use-asmifier/</id>
    <published>2014-07-27T05:53:45.000Z</published>
    <updated>2014-07-27T06:47:30.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ASM这个字节码处理框架，不仅能够读字节码，而且还能修改字节码，我们经常是先写好JAVA代码，然后编译(IDE或者javac)生成class文件，最后classloader再把相应的class文件加载到内存，但是有了ASM后，我们可以直接使用ASM生成class文件的字节数组，即面向字节码写JAVA代码，这样可以让JVM动态去加载一个类，但是这个类的class文件并不存在磁盘上，也就是说这个类的class文件是在内存中构建出来的。</p>
<a id="more"></a>

<p>下面我们就来看看如何在内存中构造class文件的字节数组，并且让JVM动态加载对应的class.</p>
<h4 id="二-如何使用">二.如何使用</h4>
<p>假如我们我们需要JVM动态加载的类的源代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> ASMTest {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span>() {
        System.<span class="keyword">out</span>.println(<span class="string">"Hello ASM"</span>);
    }
}
</pre></td></tr></table></figure>

<p>此时这类并不再当前应用所对应的classpath中。当然我们可以自己去分析这个类的字节码，然后一步一步去构造这个类的字节码，但是这样比较麻烦，ASM提供了这样一个工具，可以把一个编译过的class文件转换一段java代码，运行这段java代码可以产生这个编译过的class文件对应的字节数组。</p>
<p>因此，我们先执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>javac ASMTest<span class="preprocessor">.java</span>
</pre></td></tr></table></figure>

<p>生成ASMTest对应的class文件。接下来我们使用ASMifier来生成可以产生字节数组的代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>java -classpath asm-debug-all-<span class="number">4.1</span><span class="preprocessor">.jar</span>:. org<span class="preprocessor">.objectweb</span><span class="preprocessor">.asm</span><span class="preprocessor">.util</span><span class="preprocessor">.ASMifier</span> ASMTest &gt; ASMTestDump<span class="preprocessor">.java</span>
</pre></td></tr></table></figure>

<p>在执行java命令的时候我们指定了classpath,多个classpath使用冒号分隔，此时一定要保证ASMTest的所在的路径被加入到classpath中，生成的ASMTestDump类如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASMTestDump</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] <span class="title">dump</span>() <span class="keyword">throws</span> Exception {

        ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);
        MethodVisitor mv;

        cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, <span class="string">"ASMTest"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);
        {
            mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
            mv.visitCode();
            mv.visitVarInsn(ALOAD, <span class="number">0</span>);
            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);
            mv.visitInsn(RETURN);
            mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);
            mv.visitEnd();
        }
        {
            mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"hello"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
            mv.visitCode();
            mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);
            mv.visitLdcInsn(<span class="string">"Hello ASM"</span>);
            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>);
            mv.visitInsn(RETURN);
            mv.visitMaxs(<span class="number">2</span>, <span class="number">1</span>);
            mv.visitEnd();
        }
        cw.visitEnd();

        <span class="keyword">return</span> cw.toByteArray();
    }
}
</pre></td></tr></table></figure>

<p>接下来定义自己的classloader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> {</span>

    <span class="keyword">public</span> Class <span class="title">defineClass</span>(String clazz, <span class="keyword">byte</span>[] bytes) {
        <span class="keyword">return</span> defineClass(clazz, bytes, <span class="number">0</span>, bytes.length);
    }
}
</pre></td></tr></table></figure>

<p>使用自己的classloader加载ASMTestDump产生的字节数组,并通过反射来调用ASMTest类的Hello方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassWriterTest</span> {</span>

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        MyClassLoader mycl = <span class="keyword">new</span> MyClassLoader();
        Class classInstance = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            classInstance =  mycl.defineClass(<span class="string">"ASMTest"</span>, ASMTestDump.dump());
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
        
        <span class="keyword">if</span> (classInstance != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                Object oo = classInstance.newInstance();
                Method method = classInstance.getMethod(<span class="string">"hello"</span>, <span class="keyword">null</span>);
                method.invoke(oo, <span class="keyword">null</span>);
            } <span class="keyword">catch</span> (InstantiationException e) {
                e.printStackTrace();
            } <span class="keyword">catch</span> (IllegalAccessException e) {
                e.printStackTrace();
            } <span class="keyword">catch</span> (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</pre></td></tr></table></figure>

<p>使用ASMifier就这么简单。</p>
<h4 id="三-总结">三.总结</h4>
<p>ASMifier其实也可以认为是一个编译器，把class文件转换成java代码，这里的java代码并不是反编译后的java代码，而是一段可以生成当前class字节数组的代码，可能很多人会有以为，class文件到字节数组需要这么麻烦吗？我们直接读取class文件，然后字节转换成字节数组不就搞定了么，不用这么绕一大圈的么，关键是有时候字节码并不是存在磁盘上的，需要在内存中动态构建，如果你愿意在内存中写字节码也行。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>ASM这个字节码处理框架，不仅能够读字节码，而且还能修改字节码，我们经常是先写好JAVA代码，然后编译(IDE或者javac)生成class文件，最后classloader再把相应的class文件加载到内存，但是有了ASM后，我们可以直接使用ASM生成class文件的字节数组，即面向字节码写JAVA代码，这样可以让JVM动态去加载一个类，但是这个类的class文件并不存在磁盘上，也就是说这个类的class文件是在内存中构建出来的。</p>
]]></summary>
    
      <category term="ASM" scheme="http://yangbolin.cn/tags/ASM/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM字节码指令相关]]></title>
    <link href="http://yangbolin.cn/2014/07/26/jvm-byte-code-attention/"/>
    <id>http://yangbolin.cn/2014/07/26/jvm-byte-code-attention/</id>
    <published>2014-07-26T11:46:08.000Z</published>
    <updated>2014-07-26T12:11:07.000Z</updated>
    <content type="html"><![CDATA[<p>JAVA代码中的每个方法都会被编译成一系列的JVM字节码指令，这些字节码指令会被JVM所执行，从而产生相应的数据，我们通常可以用javap -verbose来查看一个方法的字节码指令。</p>
<a id="more"></a>

<p>记得自己之前写过一个简单编译器，编译之后生成的相关的指令，这写指令的编号都是连续的，因为这些指令被我存储在一个指令数组中，每次执行指令的时候，程序计数器PC就会加一，指向下一条需要执行的指令，但是我们使用javap -verbose查看方法字节码指令时，你会发现方法字节码指令前面的编号不是连续的<br><img src="http://bolinyoung.qiniudn.com/method-byte-code.jpg" alt="方法字节码指令"><br>我们看到Lookup方法有三条字节码指令，为什么这三条字节码指令前面的编号不是0,1,2呢？</p>
<p>这里的编号不是以指令为单位的，而是以字节为单位。<br>字节码指令的结构是：<br>[ opcode ][ operands ]<br>其中opcode一定是1字节的，而operands可能是1字节、2字节、4字节或更多（如switch系指令）。<br>此外，方法的字节码指令都是存储在一个字节数组中的，对于aload_0前面的0表示这个字节码指令在字节数组中的偏移量是0,invokespecial前面的指令标识自己在字节数组中的偏移量是1,return表示自己在字节数组中的偏移量是4,从上面的分析可以知道invokespecial在字节数组中占据1,2,3三个下标对应的字节。</p>
<p>这里顺便提一下几个容易混淆的字节码指令：</p>
<ul>
<li>load指令表示把局部变量区中的数据加载到操作数栈顶部</li>
<li>store指令表示把栈顶的数据存储到局部变量区中</li>
<li>invokevirtual表示调用实例的方法</li>
<li>invokespecial表示调用类的构造方法，实例初始化方法，私有方法</li>
<li>invokestatic表示调用静态方法</li>
<li>invokeinterface表示调用接口方法</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>JAVA代码中的每个方法都会被编译成一系列的JVM字节码指令，这些字节码指令会被JVM所执行，从而产生相应的数据，我们通常可以用javap -verbose来查看一个方法的字节码指令。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA线程模型]]></title>
    <link href="http://yangbolin.cn/2014/07/26/java-thread-model/"/>
    <id>http://yangbolin.cn/2014/07/26/java-thread-model/</id>
    <published>2014-07-26T11:13:14.000Z</published>
    <updated>2014-07-26T11:37:52.000Z</updated>
    <content type="html"><![CDATA[<p>我们在JAVA代码中创建一个线程，这线程在系统中会经历下面5个阶段：<br>New-&gt;Runnable-&gt;Blocked-&gt;Running-&gt;Dead</p>
<a id="more"></a>

<p>这里我们来详细看一下这几个阶段的演变以及转换<br><img src="http://bolinyoung.qiniudn.com/java-thread-model.png" alt="线程状态转换"></p>
<ul>
<li><p>New<br>表示这个线程对象刚刚被创建，它具备线程的一些特性，但是系统没有给它分配资源。</p>
</li>
<li><p>Runnable<br>表示这个线程处于就绪状态，要是能获得CPU的话，线程马上就能运行起来。</p>
</li>
<li><p>Blocked<br>一个正在运行的线程由于某些原因不能继续运行，它将进入阻塞状态。比如线程对象执行suspend(),sleep()等阻塞类型的方法后，线程就会进入BlockedPool，当线程调用resume()方法或者自动苏醒后，线程会进入Runnable状态;线程因为要执行synchronized同步代码块需要获取锁，但是当前要获取的锁被其他线程所占有，此时线程会进入LockPool，要是线程获取到这把锁后，线程又会进入到Runnable状态;线程执行了某个对象的wait()方法，此时线程会进入到WaitPool，当相应对象上的notify方法被调用后，线程就会进入Runnable状态。</p>
</li>
<li><p>Running<br>处于Runnable状态的线程要是能获取到CPU的话，马上就变成Running状态</p>
</li>
<li><p>Dead<br>线程运行结束，或者线程被interrupt，或者线程被stop，线程的生命周期也就结束了。</p>
</li>
</ul>
<p>JVM在执行某个方法的时候，会创建一个方法执行栈帧(Frame),这个栈帧包含局部变量区和操作数栈，在局部变量区的第一个位置上存储当前方法所属的实例对象。</p>
]]></content>
    <summary type="html"><![CDATA[<p>我们在JAVA代码中创建一个线程，这线程在系统中会经历下面5个阶段：<br>New-&gt;Runnable-&gt;Blocked-&gt;Running-&gt;Dead</p>
]]></summary>
    
      <category term="并发" scheme="http://yangbolin.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单元测试Failed的排查]]></title>
    <link href="http://yangbolin.cn/2014/07/26/ut-failed-problems/"/>
    <id>http://yangbolin.cn/2014/07/26/ut-failed-problems/</id>
    <published>2014-07-26T07:47:22.000Z</published>
    <updated>2014-07-26T08:13:24.000Z</updated>
    <content type="html"><![CDATA[<p>最近各种中间件升级的事情，升级中间件可能会出现很多诡异的问题，此时我们需要定位这些问题是自己升级导致还是其他原因导致，升级中间件可能会出现很多JAR包冲突的问题，此时需要一一排查。</p>
<a id="more"></a>

<p>前两天升级后遇到这样的问题，系统中的单元测试在eclipse中单独跑没有问题，但是使用mvn test一起跑就会出现大部分单元测试PASS不了，此时查看单元测试FAIL的日志发现获取数据库连接超时，由于本次升级出现了很多JAR包冲突的问题，导致自己一直在怀疑是不是某个JAR包又冲突了导致数据库连接获取超时了？因此排查思路一直停留在JAR包冲突的这个范围内，查了好久，问题依然没有解决，由于自己维护的这个服务化应用非常重要，不能不管单元测试就发布，同时自己也不会放过这个问题，一定要追查到底。</p>
<p>是不是自己的陷入了排查误区了呢？于是把整个代码的变更自己又回顾了一遍，发现最多的就是JAR包版本的升级，引入新的JAR包版本。记得之前自己总结过一句话：要是一个问题排查了好久没有眉目的话，记得去看看那些被你忽略过的细节问题，很可能问题就出现这些被忽略的细节上面。</p>
<p>那到底那些细节被忽略了呢？问题的现象是什么？单个跑UT能够PASS,批量跑UT一部分不能PASS,因为数据库连接获取超时，单个和批量就是这里的细节了，此时自己有一种突然醒悟的感觉，问题就这里了，单个跑只获取一个数据库连接，批量跑会获取多个数据库连接，数据库连接池的问题，不是我升级导致，因此找DBA搞定这个问题。</p>
<p>其实这个问题很简单，发现自己有时候很容易被最近刚出现的问题困扰住，思路一直停留如何最近刚出现的问题上，以后需要注意分析问题出现的本质原因，比如数据连接获取不到其实跟JAR包冲突的关系不是很大，可以说几乎没啥关系，不要受一些最近出现的问题的影响，避免思路被困住。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近各种中间件升级的事情，升级中间件可能会出现很多诡异的问题，此时我们需要定位这些问题是自己升级导致还是其他原因导致，升级中间件可能会出现很多JAR包冲突的问题，此时需要一一排查。</p>
]]></summary>
    
      <category term="单元测试" scheme="http://yangbolin.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="开发杂谈" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IBatis不同版本对parameterMap的处理]]></title>
    <link href="http://yangbolin.cn/2014/07/23/ibatis-version-for-parametermap/"/>
    <id>http://yangbolin.cn/2014/07/23/ibatis-version-for-parametermap/</id>
    <published>2014-07-23T11:58:04.000Z</published>
    <updated>2014-07-23T12:46:37.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>今天在升级一个监控的中间件时，发现必须升级ibatis的版本到2.3.4,原来ibatis的版本是2.3.0,升级后，发现sqlmap的解析出问题了，对于parameterMap这个标签解析出错，原因是parameterMap对应class没法实例化，为什么原来没有问题，升级后就有问题了呢？这时候只能怀疑版本的问题,2.3.4和2.3.0在解析parameterMap时有所不同。</p>
<a id="more"></a>

<p>下面是我们应用中一份sqlmap中写的parameterMap<br><img src="http://bolinyoung.qiniudn.com/parameterMap.png" alt="parameterMap"></p>
<p>其实这个parameterMap在这份配置文件中压根就没有被使用过，TA-COACH-CONFIG-PARAM这个class在当前的classpath中显然不存在，同时也不是某个class在sqlmap中的别名，因此在解析的时候会报TA-COACH-CONFIG-PARAM这个class找不到。</p>
<h5 id="二-到底那里不一样">二.到底那里不一样</h5>
<p>那具体到ibatis的源代码中，那些代码发生了变更呢？我们首先找到解析sqlmap的类即SqlMapParser这个类，先看看2.3.0中这个类解析paramterMap的行为<br><img src="http://bolinyoung.qiniudn.com/parameterMap230.png" alt="2.3.0"><br>我们看到在2.3.0这个版本中拿到parameterClassName后，尝试去实例化这个类型的实例，此时要是这个类找不到就出现Exception，但是该版本中没有处理这个异常，就是说这个异常默默地被吞了。</p>
<p>接下来再看看2.3.4中SqlMapParser解析parameterMap的行为<br><img src="http://bolinyoung.qiniudn.com/parameterMap234.png" alt="2.3.4"><br>其实在2.3.0中作者已经意识到这个事情了，只是写了TODO，在2.3.4中正式开始抛出异常了。</p>
<p>综上所述：<br>在ibatis的配置的文件中，要么使用类的权限定名，要么使用类的别名，要是一个class在classpath中不存在，但是你在sqlmap中使用了，你就等着翻源码查问题吧。还好上面的那个parameterMap形同虚设，我可以放心地删了它。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>今天在升级一个监控的中间件时，发现必须升级ibatis的版本到2.3.4,原来ibatis的版本是2.3.0,升级后，发现sqlmap的解析出问题了，对于parameterMap这个标签解析出错，原因是parameterMap对应class没法实例化，为什么原来没有问题，升级后就有问题了呢？这时候只能怀疑版本的问题,2.3.4和2.3.0在解析parameterMap时有所不同。</p>
]]></summary>
    
      <category term="IBatis" scheme="http://yangbolin.cn/tags/IBatis/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HBase的基础类型KeyValue]]></title>
    <link href="http://yangbolin.cn/2014/07/20/hbase-keyvalue-type/"/>
    <id>http://yangbolin.cn/2014/07/20/hbase-keyvalue-type/</id>
    <published>2014-07-20T08:22:39.000Z</published>
    <updated>2014-07-20T09:38:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>HBase是面向列的存储数据的，最终的存储单元都是KeyValue的结构，HBase本身也定义了一个KeyValue的类型，这是HBase数据存储的基本类型。那么KeyValue本身会存储那些信息呢？</p>
<a id="more"></a>

<p>从名字来看应该只有两个数据，一个是Key,一个是Value,的确如此，不过这里的Key是多个元素的聚合，有rowkey,列族，列名，时间戳以及key的类型，key的类型定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Type {
    Minimum((<span class="keyword">byte</span>)<span class="number">0</span>),
    Put((<span class="keyword">byte</span>)<span class="number">4</span>),

    Delete((<span class="keyword">byte</span>)<span class="number">8</span>),
    DeleteColumn((<span class="keyword">byte</span>)<span class="number">12</span>),
    DeleteFamily((<span class="keyword">byte</span>)<span class="number">14</span>),

    <span class="comment">// Maximum is used when searching; you look from maximum on down.</span>
    Maximum((<span class="keyword">byte</span>)<span class="number">255</span>);
    ....
  }
</pre></td></tr></table></figure>

<h4 id="二-KeyValue结构概述">二.KeyValue结构概述</h4>
<p><img src="http://bolinyoung.qiniudn.com/HBase-key-value.png" alt="HBase的KeyValue"></p>
<p>HBase的KeyValue内部维护着一个字节数组，然后通过不同的偏移量来获取不同的部分，前面说过KeyValue本身就两部分，Key&amp;&amp;Value,因此KeyLength标识KeyValue中Key在字节数组中所占的长度，ValueLength标识Value在字节数组中所占的长度。观察上图，我们看到从RowLength到KeyType都是KeyValue这个基本类型的Key,我们来看一下这个Key中包含那些东西，RowLength即rowkey的长度，RowKey即rowkey的内容，ColumnFamilyLength即列族的长度，ColumnFamily即列族的内容，ColumnQualifier即列的名称，TimeStamp即时间戳，KeyType即Key的类型，前面已经介绍过。</p>
<p>我们看到从ColumnQualifier开始内容前面不在带有长度了，关于TimeStamp和KeyType很好理解，因为他们所占的字节数目是固定，时间戳是一个long型的数字，占固定、字节数目，KeyType看其定义就能知道占1个字节，此时就剩下ColumnQualifier了，列名所占的字节数目计算一下即可，KeyLength-RowLength-ColumnFamilyLength即可，其中TimeStamp以及KeyType所占的字节长度不计算到KeyLength中，虽然他们是Keyalue中key的一部分，原因就是他们的长度固定，没有必要单独表示。<br>下面我们看看KeyValue中计算列名所占字节数目的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>  <span class="comment">// 字节数组中用固定长度的字节数目表示内容所占的字节数目</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEY_INFRASTRUCTURE_SIZE = ROW_LENGTH_SIZE
      + FAMILY_LENGTH_SIZE + TIMESTAMP_TYPE_SIZE;
      
  ......
  <span class="javadoc">/**
   *<span class="javadoctag"> @return</span> Qualifier length
   */</span>
  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQualifierLength</span>() {
    <span class="keyword">return</span> getQualifierLength(getRowLength(),getFamilyLength());
  }

  <span class="javadoc">/**
   *<span class="javadoctag"> @return</span> Qualifier length
   */</span>
  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQualifierLength</span>(<span class="keyword">int</span> rlength, <span class="keyword">int</span> flength) {
    <span class="comment">// KeyLength-表示长度的字节数目-rowKeyLength-familyLength即列名所占的字节数目</span>
    <span class="keyword">return</span> getKeyLength() -
      (KEY_INFRASTRUCTURE_SIZE + rlength + flength);
  }
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>HBase是面向列的存储数据的，最终的存储单元都是KeyValue的结构，HBase本身也定义了一个KeyValue的类型，这是HBase数据存储的基本类型。那么KeyValue本身会存储那些信息呢？</p>
]]></summary>
    
      <category term="HBase" scheme="http://yangbolin.cn/tags/HBase/"/>
    
      <category term="大数据" scheme="http://yangbolin.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ASM读取class的字节码]]></title>
    <link href="http://yangbolin.cn/2014/07/16/asm-read-class-bytes/"/>
    <id>http://yangbolin.cn/2014/07/16/asm-read-class-bytes/</id>
    <published>2014-07-16T12:18:54.000Z</published>
    <updated>2014-07-16T13:07:27.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>我们平时写的JAVA代码经过编译后就是class文件，class文件其实有非常严谨的结构，具体可以参考<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.1" target="_blank">JVM class文件格式规范</a>,认真读完这个规范，只要你按照这个规范来解析class文件，你就一定能写个javap出来。</p>
<a id="more"></a>

<p>我们写的JAVA代码最终都是跑在JVM上面的，但是JVM不会跑JAVA源代码，JVM上面跑的是编译后的字节码，也就是说JVM只认识class文件，不认识.java文件。最近在分析Java字节码然后检测一些代码中存在的问题，需要读取Java的class文件，当然按照前面的规范去自己解析class文件也可以，不过这么做你需要处理很多细节问题，ASM就是一个优秀的字节码读取框架，这个框架把byte数组转换成更加具体的对象，方便我们对字节码进行深层次的分析，以及修改，因此最后选择ASM作为字节处理的工具，不过在使用这个工具的时候，发现常量池没法体现出来，因为我只需要常量池中的东西就够了，为了避免全部解析class文件，自己动手解析了常量池。</p>
<p>ASM把class文件定义成下面几部分<br><img src="http://bolinyoung.qiniudn.com/ASM-SECTION-PDF.png" alt="ASM字节码分块"></p>
<h4 id="二-ASM读取Class的字节码文件">二.ASM读取Class的字节码文件</h4>
<p>使用ASM读取Class的字节码文件时，我们与两种思路可以选择</p>
<ul>
<li><p>Core-API<br>这中思路其实就是事件的思想，前面我们提到过ASM对字节码进行分块，读取到某一块的时候就会调用相应的visit方法，类似与产生一个事件，然后相应的事件监听者做出相应的响应。这中思路的优点解析过程中内存占用少，速度快，但是缺点就是过了这村就没这店，因为这种解析是顺序的，不可能倒过来的，除非你重新触发一次解析的过程，类似XML的SAX解析思想。流水式的解析，错过了，就永远错过了，除非从头再来。</p>
</li>
<li><p>Tree-API<br>Tree-API弥补了Core-API的不足，Tree-API会把解析出来的每一块都保存在内存中，你可以随时获取字节码中的任意一块，这样避免了Core-API的缺点，但是暴漏出来的缺点就是内存占用比较大，类似XML的DOM解析思想。保证字节码的每一块内容在整个解析的过程中一直存储在内存中。</p>
</li>
</ul>
<p>我们可以借鉴ASM这种API设计的理念，解决API设计中存在的一些问题。</p>
<p><img src="http://bolinyoung.qiniudn.com/ASM-API.png" alt="ASM-API核心类图"></p>
<p>ClassVistor是一个抽象类，我们在使用Core-API的时候需要构造一个自己的Visitor继承ClassVistor即可，然后重载一些ClassVistor中访问各个字节码模块的方法，这样在解析到每个class文件的相应模块时，这些方法会被回调。我们在使用Tree-API的时候，需要构造一个ClassNode,通过上述类图就能看出ClassNode也是ClassVisitor的一个派生类，这不过这个ClassNode在实现这些visit方法的时候把流水式解析的结果存储在一些自己的成员变量中，从而保证各个字节码分块在整个解析的过程中都在内存中一直存在。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>我们平时写的JAVA代码经过编译后就是class文件，class文件其实有非常严谨的结构，具体可以参考<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.1" target="_blank">JVM class文件格式规范</a>,认真读完这个规范，只要你按照这个规范来解析class文件，你就一定能写个javap出来。</p>
]]></summary>
    
      <category term="ASM" scheme="http://yangbolin.cn/tags/ASM/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA字节码常量池中常量编号的疑问]]></title>
    <link href="http://yangbolin.cn/2014/07/16/class-bytecode-constant-pool-num/"/>
    <id>http://yangbolin.cn/2014/07/16/class-bytecode-constant-pool-num/</id>
    <published>2014-07-16T09:50:43.000Z</published>
    <updated>2014-07-26T11:48:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-问题描述">一.问题描述</h4>
<p>最近在解析JAVA字节码的时候，发现常量池中常量编号不连续了，导致解析程序经常NPE，然后仔细测试了一下，发现常量类型如果是Long或者Double的话，就会导致常量池中常量的编号不连续了。</p>
<a id="more"></a>

<p>假如当前常量类型是Long的话，并且当前常量编号是N，此时如果还有下一个常量的话，下一个常量的编号就是N+2不是N+1了。</p>
<p><img src="http://bolinyoung.qiniudn.com/bytecode-why.png" alt="字节码常量池中常量的编号"></p>
<p>此时我们发现编号为2的常量是Long类型，结果下面一个常量的编号变成4了，为什么不是3?同时编号为5的常量是Double类型，结果下面一个常量的编号变成7了，为什么不是6?</p>
<p>从上面的分析暂时可以得出的结论是:Long或者Double类型的常量在常量池中占据两个常量的编号，这个是为什么呢？</p>
<h4 id="二-相关解释">二.相关解释</h4>
<p>一开始以为这里的编号可能不是按照自然顺序来的，或者是相对与什么的偏移量，因为方法的字节指令前面的编号就是字节码数组中的偏移量。后面查找了一下<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.5" target="_blank">JVM规范</a>，发现这是一个Class文件的规范定义。</p>
<p><img src="http://bolinyoung.qiniudn.com/bytecode-guifan.png" alt="JVM常量池规范"></p>
<p>而且已经在规范里面吐槽过了。因此在解析常量池中常量编号的时候不能一直按照自然顺序单调递增，如果常量是Long或者Double类型的话，需要跳过一个常量的编号。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-问题描述">一.问题描述</h4>
<p>最近在解析JAVA字节码的时候，发现常量池中常量编号不连续了，导致解析程序经常NPE，然后仔细测试了一下，发现常量类型如果是Long或者Double的话，就会导致常量池中常量的编号不连续了。</p>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring容器的事件机制]]></title>
    <link href="http://yangbolin.cn/2014/07/07/spring-application-event/"/>
    <id>http://yangbolin.cn/2014/07/07/spring-application-event/</id>
    <published>2014-07-07T05:08:20.000Z</published>
    <updated>2014-07-10T15:40:24.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>Spring容器暴漏了很多扩展点给框架的使用者，让框架的使用者能够干涉一些容器内部的事情，也让框架的使用能够感知到容器内部发生了什么事情，比如Spring容器在初始化完后，就会广播一个容器初始化完成的事件，然后事件的监听者监听到这个事件后做相应的事情，这也是Spring容器的一个非常有用的扩展点。</p>
<a id="more"></a>

<h4 id="二-事件相关的类图">二.事件相关的类图</h4>
<p><img src="http://bolinyoung.qiniudn.com/Spring-Event.png" alt="Spring事件机制相关的类图"></p>
<p>上面这张类图就是Spring事件机制涉及到的一些核心类图。关于事件机制核心的接口有两个ApplicationEventMulticaster和ApplicationListener,前者是事件的广播中心接口，主要负责事件的广播和监听者的注册，后者是事件监听接口,还有一个事件对象ApplicationEvent，定义事件相关的属性，比如事件的类型，事件关联的数据，不过Spring中并没有定义相关的事件类型，不同的事件对应不同的类，比如ContextRefreshedEvent，表示Spring容器上下文初始化结束了。</p>
<p>其实事件这个概念在我们日常的开发中经常会被用到，很多人喜欢设计一个事件模块，要是让你去设计一个事件模块的话，需要考虑三个点，事件本身的定义，包括事件的类型以及事件所包含的数据，其次，需要定义事件的广播机制，一般有同步和异步，最后当然就是事件监听者的定义了，在监听者内部定义如何响应各自感兴趣的事件。</p>
<h5 id="三-Spring事件机制的巧妙使用">三.Spring事件机制的巧妙使用</h5>
<p>Spring容器在初始化完成后，会发广播一个容器初始化OK的事件出来，我们可以在每个bean注册一个监听上下文刷新成功的事件，等上下文刷新成功了，我们在用这个bean去做一些其他事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>
    // 把<span class="title">Spring</span>容器注入到这个<span class="title">bean</span>中
    <span class="title">public</span> <span class="title">void</span> <span class="title">setApplicationContext</span>(<span class="title">ApplicationContext</span> <span class="title">applicationContext</span>) <span class="title">throws</span> <span class="title">BeansException</span> {</span>
        <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> AbstractApplicationContext) {
            AbstractApplicationContext apc = (AbstractApplicationContext)applicationContext;
            <span class="comment">// 注册新listener</span>
            apc.addListener(<span class="keyword">new</span> XXXApplicationListener());
        }
    }

    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> {</span>
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span>(ApplicationEvent event) {
            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent) {
                <span class="comment">// 这时候这个bean已经在Spring容器中初始化OK了</span>
                XXBean.<span class="keyword">this</span>.xxx.xxx <span class="comment">// 使用初始化好的bean中的相关属性做一些事情</span>
            }
        }
    }
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>Spring容器暴漏了很多扩展点给框架的使用者，让框架的使用者能够干涉一些容器内部的事情，也让框架的使用能够感知到容器内部发生了什么事情，比如Spring容器在初始化完后，就会广播一个容器初始化完成的事件，然后事件的监听者监听到这个事件后做相应的事情，这也是Spring容器的一个非常有用的扩展点。</p>
]]></summary>
    
      <category term="Spring" scheme="http://yangbolin.cn/tags/Spring/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何读懂JVM GC日志]]></title>
    <link href="http://yangbolin.cn/2014/07/01/how-to-read-gc-log/"/>
    <id>http://yangbolin.cn/2014/07/01/how-to-read-gc-log/</id>
    <published>2014-07-01T15:55:05.000Z</published>
    <updated>2014-07-26T11:48:57.000Z</updated>
    <content type="html"><![CDATA[<p>我们经常会在线上观察JVM运行时GC日志，其实GC日志中有很多信息可以挖掘，比如下面的GC日志信息</p>
<blockquote>
<p>[GC [DefNew: 34538K-&gt;2311K(36352K), 0.0232439 secs] 45898K-&gt;15874K(520320K), 0.0233874 secs]<br>[Full GC [Tenured: 313563K-&gt;15402K(483968K), 0.2368177 secs]<br>343563K-&gt;18402K(520320K), [Perm : 28671K-&gt;28635K(28672K)], 0.2371537 secs]</p>
</blockquote>
<a id="more"></a>

<p>观察上面的GC日志，我们发现出现了一次YGC和一次FGC,JVM的内存是分代的，有老年代，新生代，还有永久代。一般我们创建的对象先会进入新生代，要是经过N次YGC后，这个对象还存在，那么这个对象就晋升到老年代，这个N是可以配置的。永久代主要存储JVM字节码以及相关的类信息。</p>
<ul>
<li><p>关于YGC日志的解释：<br>新生代的总大小是36352K,当新生代使用到34538K时发生了一次YGC,此时新生代的占用从34538K变到2311K，同时我们也能看到整个堆内存的变化，整个堆内存大小是520320K，当使用到45898K时发生了一次YGC,堆内存的使用由45898K变化到15874K。后面的时间是指内存回收的耗时。</p>
</li>
<li><p>关于YGC日志的解释：<br>老年代总大小为483968K，当老年代使用到313563K，发生了一次FGC,老年代的使用由313563K变到15402K。堆的总内存大小为520320K，当使用到343563K发生了一次FGC,堆内存的使用由343563K变到18402K。永久代的总大小为28672K，当永久代内存使用到28671K时发生了一次FGC，永久代使用的内存由28671K变到28635K。后面的时间表示内存回收的耗时。</p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>我们经常会在线上观察JVM运行时GC日志，其实GC日志中有很多信息可以挖掘，比如下面的GC日志信息</p>
<blockquote>
<p>[GC [DefNew: 34538K-&gt;2311K(36352K), 0.0232439 secs] 45898K-&gt;15874K(520320K), 0.0233874 secs]<br>[Full GC [Tenured: 313563K-&gt;15402K(483968K), 0.2368177 secs]<br>343563K-&gt;18402K(520320K), [Perm : 28671K-&gt;28635K(28672K)], 0.2371537 secs]</p>
</blockquote>
]]></summary>
    
      <category term="JVM" scheme="http://yangbolin.cn/tags/JVM/"/>
    
      <category term="JVM学习" scheme="http://yangbolin.cn/categories/JVM%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sqlmap被Spring容器加载了]]></title>
    <link href="http://yangbolin.cn/2014/07/01/sqlmap-load-by-spring-container/"/>
    <id>http://yangbolin.cn/2014/07/01/sqlmap-load-by-spring-container/</id>
    <published>2014-07-01T12:10:20.000Z</published>
    <updated>2014-07-01T15:55:31.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>最近发布需求升级一个中间件，一个web应用在启动的时候，偶尔会会报下面的错误，报错的规律无法跟踪，导致应用启动失败。<br><img src="http://bolinyoung.qiniudn.com/ibatis-spring.png" alt="ibatis-psring"><br>有时候启动应用就会出现上面的异常，有时候启动应用没有异常，在发布的时候要是机器启动失败，我们就不断重启，直到机器重启成功。</p>
<a id="more"></a>

<h4 id="二-分析">二.分析</h4>
<p>首先，从上面的异常看到是由于当前机器上没法访问ibatis.apache.org这个域名导致，一台机器要是没法访问某个域名，要么这台机器本身有问题，要么域名对应的机器有问题，机器本身的问题可以排除，因为ping这个域名能ping的通，那么唯一的问题就是域名对应的机器拒绝访问导致，或许ibatis.apache.org这个服务不稳定。因此，上面的UnkonwHostException:ibatis.apache.org只能解释解释域名提供的服务不稳定了。</p>
<p>其次，我们在所有的配置文件中找ibatis.apache.org这个域名，发现sqlmap的总控文件和每个sqlmap文件中有引用这个域名</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE sqlMapConfig PUBLIC "-//ibatis.apache.org//DTD SQL Map Config 2.0//EN" "http://ibatis.apache.org/dtd/sql-map-config-2.dtd"&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE sqlMap PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN" "http://ibatis.apache.org/dtd/sql-map-2.dtd"&gt;</span>
</pre></td></tr></table></figure>

<p>奇怪，ibatis的配置文件怎么会被Spring解析呢？要解析也是有ibatis来解析。为什么说ibatis的配置文件被Spring解析了呢？看上图异常堆栈的开始，箭头所指</p>
<blockquote>
<p>at org.apache.xerces.parsers.DOMParser.parse(Unknown Source)<br>at org.apache.xerces.jaxp.DocumentBuilderImpl.parse(Unknown Source)<br>at org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:75)<br>at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:396)<br>… 63 more</p>
</blockquote>
<p>这行日志很明确地告诉我们Spring在偷偷解析的sqlmap配置文件了，注意核心关键词org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(),Spring这个时候处于bean定义的读取状态。</p>
<p>至此，有两个问题没有解决</p>
<p>1.Spring为什么会解析这份sqlmap的配置文件呢？<br>2.Spring解析每份XML的配置文件时，都会从网上找DTD文件吗？</p>
<p>先来回答问题1，Spring之所以会去偷偷解析这份配置文件，因为这份配置文件被Spring容器加载了，这份配置文件能被Spring容器加载，那是因为有人写错了，看了一下应用的总控配置文件，果然被写成这样子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">beans</span>&gt;</span>
    <span class="tag">&lt;<span class="title">import</span> <span class="attribute">resource</span>=<span class="value">"classpath*:xxxx/bean/**/*.xml"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<p>刚好那份sqlmap的总控配置文件也写在这xxx/bean/<em>*/</em>能匹配到的目录下面，这样这份配置文件必然会被Spring容器所加载了。</p>
<p>再看第2个问题，答案是显然不会从网上去找DTD文件，换做是你，你也不会这么写,Spring那么多DTD文件都是存在于Spring的jar包中，在XML解析的时候会把网络地址转换成classpath中某个DTD文件的路径。关键上面的域名ibatis.apache.org在Spring做XML解析的时候没法转换成自己jar包正某个DTD文件的路径，因此XML解析程序就会从网上去找这个DTD文件，这样ibatis.apache.org这个域名就会被访问了，这个过程可以看XML解析的源代码。</p>
<p>其实只要看看EntityResolver这个接口的注释就明白了。</p>
<h4 id="三-解决办法">三.解决办法</h4>
<p>1.移动sqlmap的位置，保证不会被Spring容器所加载。<br>2.把Spring总控配置文件中正则表达式修改一下，不要命中sqlmap即可。</p>
<h4 id="四-总结">四.总结</h4>
<p>1.最好避免sqlmap被Spring容器加载，首先这份配置文件有解析它的代码，但是不是Spring，其次Spring解析它，一个bean也解析不到，还有可能在网络不好的时候出现网络访问异常。<br>2.关于上面问题的排查，其实不像写的这么顺利，一开始忽略了最重要的问题：Spring为什么会去解析ibatis的配置文件呢？导致自己一直在怀疑XML jar包是不是冲突导致，另外要是有个问题很难定位的时候，注意那些曾经被我们忽略的细节点，或许问题的根源就在哪里。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-现象">一.现象</h4>
<p>最近发布需求升级一个中间件，一个web应用在启动的时候，偶尔会会报下面的错误，报错的规律无法跟踪，导致应用启动失败。<br><img src="http://bolinyoung.qiniudn.com/ibatis-spring.png" alt="ibatis-psring"><br>有时候启动应用就会出现上面的异常，有时候启动应用没有异常，在发布的时候要是机器启动失败，我们就不断重启，直到机器重启成功。</p>
]]></summary>
    
      <category term="Spring" scheme="http://yangbolin.cn/tags/Spring/"/>
    
      <category term="IBatis" scheme="http://yangbolin.cn/tags/IBatis/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BeanFactoryPostProcessor和BeanPostProcessor]]></title>
    <link href="http://yangbolin.cn/2014/06/24/beanfactorypostprocessor-and-beanpostprocessor/"/>
    <id>http://yangbolin.cn/2014/06/24/beanfactorypostprocessor-and-beanpostprocessor/</id>
    <published>2014-06-24T15:29:37.000Z</published>
    <updated>2014-06-30T05:54:26.000Z</updated>
    <content type="html"><![CDATA[<p>一.概述<br>我们经常使用Spring框架，Spring帮我托管bean的创建以及bean的管理，同时又暴漏出一些可扩展的地方，方面程序员去干涉bean或者Spring容器的创建。今天有同学问BeanPostProcessor相关的东西，由此很容易想到BeanFactoryPostProcessor，这里总结一下，方便后面在开发的过程中灵活使用。</p>
<a id="more"></a>

<p>二.BeanPostProcessor前置处理器<br>Spring容器在创建bean的时候，会看有没有BeanPostProcessor，如果有的话，会回调BeanPostProcessor接口中的两个方法，在bean创建之前执行程序员的一些个性化代码，在bean创建之后也执行一些程序员的个性化代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> {</span>
    <span class="javadoc">/** 创建bean之前回调 **/</span>
	Object postProcessBeforeInitialization(Object bean, String beanName) <span class="keyword">throws</span> BeansException;
	<span class="javadoc">/** 创建bean之后回调 **/</span>
	Object postProcessAfterInitialization(Object bean, String beanName) <span class="keyword">throws</span> BeansException;
}
</pre></td></tr></table></figure>

<p>三.BeanFactoryPostProcessor<br>这个可以让程序员去干涉一下Spring容器的创建，Spring容器创建的时候会回调这个接口的定义的这个方法，比如你可以在实现了这个接口的方法中给Spring容器注册一个JVM关闭时回调的钩子。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span>{</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span>(ConfigurableListableBeanFactory beanFactory) <span class="keyword">throws</span> BeansException {
        <span class="comment">// 注册JVM关闭时的回调</span>
        ConfigurableApplicationContext cxt = (ConfigurableApplicationContext)beanFactory;
        cxt.registerShutdownHook();
    }
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>一.概述<br>我们经常使用Spring框架，Spring帮我托管bean的创建以及bean的管理，同时又暴漏出一些可扩展的地方，方面程序员去干涉bean或者Spring容器的创建。今天有同学问BeanPostProcessor相关的东西，由此很容易想到BeanFactoryPostProcessor，这里总结一下，方便后面在开发的过程中灵活使用。</p>
]]></summary>
    
      <category term="Spring" scheme="http://yangbolin.cn/tags/Spring/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA代码中如何感知到JVM退出]]></title>
    <link href="http://yangbolin.cn/2014/06/19/how-to-aware-jvm-exit/"/>
    <id>http://yangbolin.cn/2014/06/19/how-to-aware-jvm-exit/</id>
    <published>2014-06-19T14:42:58.000Z</published>
    <updated>2014-06-30T14:30:16.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>当JVM退出的时候，把内存中的某块数据写入到DB。分析这个需求，我们需要让应用感知到JVM准备退出了，然后把数据写入DB，然后JVM继续执行退出…</p>
<a id="more"></a>

<h4 id="二-实现">二.实现</h4>
<ul>
<li>基于Spring的DisposableBean接口来实现<br>我们只要在自己的应用编写一个bean,实现DisposableBean这个接口中的destroy方法，然后在destroy方法中编写清理逻辑即可。要是我们不给Spring容器注册这样一个JVM关闭的钩子，JVM关闭的时候destroy方法同样不会被调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"....xml"</span>);
<span class="comment">// 注册JVM关闭时回调的钩子到Spring容器</span>
ctx.registerShutdownHook();
</pre></td></tr></table></figure>

<p>必须在应用中给Spring容器注册这样关闭钩子，负责bean的destroy方法在JVM退出的时候是没法调用的。</p>
<p>另外，如果我们的应用是一个web应用，我们在停止web应用是，该应用中实现了DisposableBean这个接口的bean的destroy方法也会被调用，这个被调用的原因不是由于创建Spring容器时注册了关闭JVM回调的钩子，而是因为关闭web应用时会回调ServletContextListener的contextDestroyed方法，ServletContextListener的实现类是ContextLoaderListener，contextDestroyed的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> {</span>
    <span class="keyword">private</span> ContextLoader contextLoader;
    ...
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span>(ServletContextEvent event) {
		<span class="keyword">if</span> (<span class="keyword">this</span>.contextLoader != <span class="keyword">null</span>) {
		    <span class="comment">//  关闭Spring容器</span>
			<span class="keyword">this</span>.contextLoader.closeWebApplicationContext(event.getServletContext());
		}
	}
    ...
}
</pre></td></tr></table></figure>

<p>我们再看看ContextLoader的closeWebApplicationContext方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoader</span> {</span>
    <span class="comment">//....</span>
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeWebApplicationContext</span>(ServletContext servletContext){
		servletContext.log(<span class="string">"Closing Spring root WebApplicationContext"</span>);
		<span class="keyword">try</span> {
			<span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext){
			    <span class="comment">// 销毁servlet的上下文，调用Spring容器的close方法</span>
			    ((ConfigurableWebApplicationContext) <span class="keyword">this</span>.context).close();
			}
		}
		<span class="keyword">finally</span> {
		    <span class="comment">// ...</span>
		}
	}
	<span class="comment">//...</span>
}
</pre></td></tr></table></figure>

<p>因此web应用中不需要给Spring容器注册JVM关闭的钩子，代码中依然能够感知到JVM的关闭。</p>
<ul>
<li>直接基于Runtime的addShutdownHook方法来实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(){

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
        System.out.println(<span class="string">"JVM EXIT..."</span>);
    }
});
</pre></td></tr></table></figure>

<p>JVM退出的时候会回调我们注册的这个钩子，Spring注册JVM关闭的回调也是这么搞的，具体AbstractApplicationContext.java中源代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span>
		<span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> {</span>
	....
		<span class="javadoc">/**
	 * Register a shutdown hook with the JVM runtime, closing this context
	 * on JVM shutdown unless it has already been closed at that time.
	 * &lt;p&gt;Delegates to &lt;code&gt;doClose()&lt;/code&gt; for the actual closing procedure.
	 *<span class="javadoctag"> @see</span> java.lang.Runtime#addShutdownHook
	 *<span class="javadoctag"> @see</span> #close()
	 *<span class="javadoctag"> @see</span> #doClose()
	 */</span>
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span>() {
		<span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) {
			<span class="comment">// No shutdown hook registered yet.</span>
			<span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() {
				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
					doClose();
				}
			};
			Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);
		}
	}
	....
}
</pre></td></tr></table></figure>

<h4 id="三-总结">三.总结</h4>
<ul>
<li><p>回调思想<br>回调也是实现程序解耦的一种思路，在平时开发的过程中要注意回调的使用，回调的调用面向接口，回调的实现交给第三方来实现，我们也可提供缺省的回调实现。</p>
</li>
<li><p>可扩展性<br>自己实现的框架或一定要提供可扩展的地方，方便满足别人个性化的一些需求。</p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>当JVM退出的时候，把内存中的某块数据写入到DB。分析这个需求，我们需要让应用感知到JVM准备退出了，然后把数据写入DB，然后JVM继续执行退出…</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程语言" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[maven自己的仲裁机制]]></title>
    <link href="http://yangbolin.cn/2014/06/18/maven-default-arbitration/"/>
    <id>http://yangbolin.cn/2014/06/18/maven-default-arbitration/</id>
    <published>2014-06-18T14:09:25.000Z</published>
    <updated>2014-06-18T14:25:15.000Z</updated>
    <content type="html"><![CDATA[<p>maven现在被广泛用来做项目管理的工具，我们经常在maven的pom文件中指定我们项目依赖的二方库，我们也会经常遇到jar包冲突，类冲突的问题。关于类冲突就是由于maven自己的仲裁机制，把应该引入的jar包给仲裁了，那么maven自己到底是如何仲裁jar包的呢？</p>
<a id="more"></a>

<p>假设我们在自己的pom.xml中引入下面的jar包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>    ...
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.xx.yy<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>AA<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.xx.yy<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>BB<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    ....
</pre></td></tr></table></figure>

<p>AA间接依赖CC对应maven坐标如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.xx.yy<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>CC<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<p>BB间接依赖CC对应maven坐标如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.xx.yy<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>CC<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</pre></td></tr></table></figure>

<p>此时maven编译的时候会进行仲裁，首先看依赖的路径，假设当前项目是X，对于CC有两条依赖路径,只是version不同，其他都一样。<br>1.X-&gt;AA-&gt;CC 1.0.0<br>2.X-&gt;BB-&gt;CC 1.0.1<br>发现两条路径的长度一样。接下来观察AA和BB在pom中声明的顺序，发现AA在BB的前面，此时CC使用1.0.0的版本。</p>
<p>因此maven自己的仲裁机制是先看路径长度，路径长度一样再看声明顺序。</p>
<p>如果我们书写下面的pom文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>...
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.xx.yy<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>AA<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
        <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.xx.yy<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>AA<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
        <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
...
</pre></td></tr></table></figure>

<p>按照上面的规则，路径相同，看声明顺序，因此1.0.0的版本被使用。</p>
<p>注意:<br>maven仲裁的前置条件是artifactId和groupId一样。</p>
]]></content>
    <summary type="html"><![CDATA[<p>maven现在被广泛用来做项目管理的工具，我们经常在maven的pom文件中指定我们项目依赖的二方库，我们也会经常遇到jar包冲突，类冲突的问题。关于类冲突就是由于maven自己的仲裁机制，把应该引入的jar包给仲裁了，那么maven自己到底是如何仲裁jar包的呢？</p>
]]></summary>
    
      <category term="maven" scheme="http://yangbolin.cn/tags/maven/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sql语句的大小]]></title>
    <link href="http://yangbolin.cn/2014/06/17/sql-size/"/>
    <id>http://yangbolin.cn/2014/06/17/sql-size/</id>
    <published>2014-06-17T13:52:39.000Z</published>
    <updated>2014-06-18T14:11:21.000Z</updated>
    <content type="html"><![CDATA[<p>今天写了下面的sql语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">select</span> XX,YY <span class="keyword">from</span> tableXX <span class="keyword">where</span> XX <span class="keyword">in</span> (<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>)</span>
</pre></td></tr></table></figure>

<a id="more"></a>

<p>这个sql不是在mysql或者oracle数据库上执行，而是在一个实时计算的数据产品上执行，当in的范围超过400后，发现执行失败，咨询相关同学后，原来这个实时计算的产品中对in的范围大小有限制，缺省的限制是400。</p>
<p>我们平时都在使用mysql，那么mysql本身对in的范围大小是否有限制呢？mysql虽然没有对in的范围直接限制，但是限制了sql语句的长度，我们可以在不同的数据库中使用下面的命令来查看当前数据库server能接受的数据包大小</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'max_allowed_packet%'</span></span>
</pre></td></tr></table></figure>

<p>sql也是server端需要接收的数据，这个配置如果是Linux系统的化，可以查看my.cnf配置文件中配置的值。</p>
<p>mysql不管你使用InnoDB还是MYISAM,sql的大小都有限制，和使用的数据库引擎没有关系，InnoDB支持事务，MYISAM不支持事务。</p>
]]></content>
    <summary type="html"><![CDATA[<p>今天写了下面的sql语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">select</span> XX,YY <span class="keyword">from</span> tableXX <span class="keyword">where</span> XX <span class="keyword">in</span> (<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>)</span>
</pre></td></tr></table></figure>

]]></summary>
    
      <category term="sql" scheme="http://yangbolin.cn/tags/sql/"/>
    
      <category term="数据库" scheme="http://yangbolin.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何获取当前JAVA进程的PID]]></title>
    <link href="http://yangbolin.cn/2014/06/14/how-to-get-java-pid/"/>
    <id>http://yangbolin.cn/2014/06/14/how-to-get-java-pid/</id>
    <published>2014-06-14T01:24:39.000Z</published>
    <updated>2014-06-14T01:28:17.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>如何在JAVA代码中获取当前运行JAVA进程的进程ID，通常我们可以在JVM外部执行jps命令看到某一JAVA进程的PID，但是如何在JVM内部获取这个PID呢？</p>
<a id="more"></a>

<h4 id="二-实现">二.实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="javadoc">/**
 * 获取java进程PID
 * 
 *<span class="javadoctag"> @return</span>
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPID</span>() {
    String rtName = ManagementFactory.getRuntimeMXBean().getName();
    <span class="keyword">int</span> index = rtName.indexOf(<span class="string">"@"</span>);
    <span class="keyword">if</span> (index != -<span class="number">1</span>) {
        <span class="keyword">return</span> Integer.parseInt(rtName.substring(<span class="number">0</span>, index));
    }

    <span class="keyword">return</span> -<span class="number">99</span>;
}
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h4 id="一-需求">一.需求</h4>
<p>如何在JAVA代码中获取当前运行JAVA进程的进程ID，通常我们可以在JVM外部执行jps命令看到某一JAVA进程的PID，但是如何在JVM内部获取这个PID呢？</p>
]]></summary>
    
      <category term="JAVA" scheme="http://yangbolin.cn/tags/JAVA/"/>
    
      <category term="编程开发" scheme="http://yangbolin.cn/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux命令总结]]></title>
    <link href="http://yangbolin.cn/2014/06/13/linux-command/"/>
    <id>http://yangbolin.cn/2014/06/13/linux-command/</id>
    <published>2014-06-13T06:30:04.000Z</published>
    <updated>2014-06-19T09:29:38.000Z</updated>
    <content type="html"><![CDATA[<p>一些常用Linux命令的总结</p>
<a id="more"></a>

<ul>
<li>lsof -p <pid> | grep xx<br>查看当前进程中有没有使用xx相关的东西，比如可以查看当前JVM有加载的某个jar包完整信息 ，包括版本。</li>
<li>pmap <pid> | grep xx<br>查看当前进程中有没有使用xx相关的东西，比如可以查看当前JVM有加载的某个jar包完整信息 ，包括版本。</li>
<li>df -hl<br>查看磁盘占用率</li>
<li><p>du -sh 文件目录<br>查看当前文件的大小</p>
</li>
<li><p>grep -R “xxx” .<br>在当前目录下查看包含xxx字符串的文件</p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>一些常用Linux命令的总结</p>
]]></summary>
    
      <category term="Linux" scheme="http://yangbolin.cn/tags/Linux/"/>
    
      <category term="开发工具" scheme="http://yangbolin.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在本地通过eclipse来调试HBase的源代码]]></title>
    <link href="http://yangbolin.cn/2014/06/07/how-to-debug-hbase-source/"/>
    <id>http://yangbolin.cn/2014/06/07/how-to-debug-hbase-source/</id>
    <published>2014-06-07T14:36:16.000Z</published>
    <updated>2014-06-08T07:30:57.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>要想把HBase的源代码梳理清楚，需要在本地调试一下，可能直接看代码也能搞清楚，但是调试能让我们尽快搞清楚HBase的源代码，下面就来看一下如何在eclipse中调试HBase的源代码。</p>
<a id="more"></a>

<h4 id="二-编译HBase的源代码">二.编译HBase的源代码</h4>
<p>1.HBase源代码的获取<br>你可以直接从HBase的官方网站上下载HBase的包，<a href="http://hbase.apache.org/" target="_blank">HBase官方地址</a><br>你也可以使用svn把hbase的代码签出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>svn co <span class="symbol">http:</span>/<span class="regexp">/svn.apache.org/repos</span><span class="regexp">/asf/hbase</span><span class="regexp">/tags/</span><span class="number">0</span>.<span class="number">94.2</span>/ hbase_sources
</pre></td></tr></table></figure>

<p>2.HBase源代码的编译<br>进入到HBase代码的目录下面，执行下面的命令</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>mvn clean <span class="keyword">install</span> mvn clean <span class="keyword">install</span> -DskipTests
mvn eclipse clean eclipse:eclipse
</pre></td></tr></table></figure>

<p>执行完上面的命令后，就把HBase的源码导入到eclipse中去。在执行maven命令的时候注意使用maven包自带的settings.xml，不要使用其他settings.xml文件，会导致编译不过的。</p>
<p>3.在eclipse中做相关的设置</p>
<p>在eclipse的Run Configurations中设置启动类<br><img src="http://bolinyoung.qiniudn.com/hbase-start.png" alt="设置启动类HMaster"></p>
<p>在eclipse的Run Configurations中设置启动参数<br><img src="http://bolinyoung.qiniudn.com/hbase-start-args.png" alt="设置启动参数"></p>
<p>在eclipse的Run Configurations中把conf文件放到classpath中<br><img src="http://bolinyoung.qiniudn.com/hbase-start-conf.png" alt="把conf文件放到classpath中"></p>
<p>4.点击Run运行<br>出现了下面的错误<br><img src="http://bolinyoung.qiniudn.com/hbase-xml-version.png" alt="xml版本校验出错"><br>观察出错日志，显示hbase-default.xml版本校验出错，搞不定，搜一把，有人说在hbase-site.xml增加下面的配置项</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">property</span>&gt;</span>
	<span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.defaults.for.version.skip<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
	<span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
	<span class="tag">&lt;<span class="title">description</span>&gt;</span>
		Set to true to skip the 'hbase.defaults.for.version' check.
		Setting this to true can be useful in contexts other than
		the other side of a maven generation; i.e. running in an
		ide. You'll want to set this boolean to true to avoid
		seeing the RuntimException complaint: "hbase-default.xml file
		seems to be for and old version of HBase (@@@VERSION@@@), this
		version is X.X.X-SNAPSHOT"
	<span class="tag">&lt;/<span class="title">description</span>&gt;</span>
<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
</pre></td></tr></table></figure>

<p>索性试一下，此错误消失了，又来一错误<br><img src="http://bolinyoung.qiniudn.com/hbase-zk-error.png" alt="HBase ZK ERROR"><br>这个错之前遇到过是由于zookeeper没启动导致，一直以为运行HMaster类，会自己启动zookeeper，所以一直在网上找答案，结果找到的答案都是错的，于是怀疑zookeeper在自己的电脑上压根就没有启动起来,所以需要想办法在本地启动zookeeper，我们看到hbase源代码中有一个HQuorumPeer类，这个类就是hbase-zookeeper的启动类，该类中有一个main方法，我们在eclipse中以application的方式启动。<br><img src="http://bolinyoung.qiniudn.com/hbase-zk-start.png" alt="hbase zk启动类"><br>把conf下面的配置文件设置到classpath中<br><img src="http://bolinyoung.qiniudn.com/hbase-zk-classpath.png" alt="设置conf到classpath"><br>这样我们就可以在eclipse中启动zookeeper啦。接下来我们再次启动HMaster<br><img src="http://bolinyoung.qiniudn.com/hbase-region-server-error.png" alt="启动HMaster控制台不断输出错误日志"><br>又出错了，看看错误日志，我们发现是RegionServer没有启动好，使用jps可以发现没有RegionServer的进程，虽然日志的级别是INFO的，回头一看确实没有启动过RegionServer，所以启动一下RegionServer啦，我们还是在eclipse中以application的方式去启动RegionServer<br><img src="http://bolinyoung.qiniudn.com/hbase-region-server.png" alt="HBase RegionServer的启动配置"><br>同样需要把conf文件加入到eclipse的classpath中，方法和前面一样，这里就不用再重复了。配置好就启动,然后发现HMaster的控制台INFO级别的日志停掉了。关于这个点我们稍微再深入一些，我们刚才的场景是启动了HMaster但是没有启动RegionServer，此时HMaster的控制台一直有INFO级别的日志输出，我们看一下ServerManager这个类中输出这段日志的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="code"><pre><span class="javadoc">/**
   * Wait for the region servers to report in.
   * We will wait until one of this condition is met:
   *  - the master is stopped
   *  - the 'hbase.master.wait.on.regionservers.maxtostart' number of
   *    region servers is reached
   *  - the 'hbase.master.wait.on.regionservers.mintostart' is reached AND
   *   there have been no new region server in for
   *      'hbase.master.wait.on.regionservers.interval' time AND
   *   the 'hbase.master.wait.on.regionservers.timeout' is reached
   *
   *<span class="javadoctag"> @throws</span> InterruptedException
   */</span>
  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForRegionServers</span>(MonitoredTask status)
  <span class="keyword">throws</span> InterruptedException {
    <span class="keyword">final</span> <span class="keyword">long</span> interval = <span class="keyword">this</span>.master.getConfiguration().
      getLong(WAIT_ON_REGIONSERVERS_INTERVAL, <span class="number">1500</span>);
    <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="keyword">this</span>.master.getConfiguration().
      getLong(WAIT_ON_REGIONSERVERS_TIMEOUT, <span class="number">4500</span>);
    <span class="keyword">int</span> minToStart = <span class="keyword">this</span>.master.getConfiguration().
      getInt(WAIT_ON_REGIONSERVERS_MINTOSTART, <span class="number">1</span>);
    <span class="keyword">if</span> (minToStart &lt; <span class="number">1</span>) {
      LOG.warn(String.format(
        <span class="string">"The value of '%s' (%d) can not be less than 1, ignoring."</span>,
        WAIT_ON_REGIONSERVERS_MINTOSTART, minToStart));
      minToStart = <span class="number">1</span>;
    }
    <span class="keyword">int</span> maxToStart = <span class="keyword">this</span>.master.getConfiguration().
      getInt(WAIT_ON_REGIONSERVERS_MAXTOSTART, Integer.MAX_VALUE);
    <span class="keyword">if</span> (maxToStart &lt; minToStart) {
        LOG.warn(String.format(
            <span class="string">"The value of '%s' (%d) is set less than '%s' (%d), ignoring."</span>,
            WAIT_ON_REGIONSERVERS_MAXTOSTART, maxToStart,
            WAIT_ON_REGIONSERVERS_MINTOSTART, minToStart));
        maxToStart = Integer.MAX_VALUE;
    }

    <span class="keyword">long</span> now =  System.currentTimeMillis();
    <span class="keyword">final</span> <span class="keyword">long</span> startTime = now;
    <span class="keyword">long</span> slept = <span class="number">0</span>;
    <span class="keyword">long</span> lastLogTime = <span class="number">0</span>;
    <span class="keyword">long</span> lastCountChange = startTime;
    <span class="keyword">int</span> count = countOfRegionServers();
    <span class="keyword">int</span> oldCount = <span class="number">0</span>;
    <span class="keyword">while</span> (
      !<span class="keyword">this</span>.master.isStopped() &&
        count &lt; maxToStart &&
        (lastCountChange+interval &gt; now || timeout &gt; slept || count &lt; minToStart)
      ){

      <span class="comment">// Log some info at every interval time or if there is a change</span>
      <span class="keyword">if</span> (oldCount != count || lastLogTime+interval &lt; now){
        lastLogTime = now;
        String msg =
          <span class="string">"Waiting for region servers count to settle; currently"</span>+
            <span class="string">" checked in "</span> + count + <span class="string">", slept for "</span> + slept + <span class="string">" ms,"</span> +
            <span class="string">" expecting minimum of "</span> + minToStart + <span class="string">", maximum of "</span>+ maxToStart+
            <span class="string">", timeout of "</span>+timeout+<span class="string">" ms, interval of "</span>+interval+<span class="string">" ms."</span>;
        LOG.info(msg);
        status.setStatus(msg);
      }

      <span class="comment">// We sleep for some time</span>
      <span class="keyword">final</span> <span class="keyword">long</span> sleepTime = <span class="number">50</span>;
      Thread.sleep(sleepTime);
      now =  System.currentTimeMillis();
      slept = now - startTime;

      oldCount = count;
      count = countOfRegionServers();
      <span class="keyword">if</span> (count != oldCount) {
        lastCountChange = now;
      }
    }

    LOG.info(<span class="string">"Finished waiting for region servers count to settle;"</span> +
      <span class="string">" checked in "</span> + count + <span class="string">", slept for "</span> + slept + <span class="string">" ms,"</span> +
      <span class="string">" expecting minimum of "</span> + minToStart + <span class="string">", maximum of "</span>+ maxToStart+<span class="string">","</span>+
      <span class="string">" master is "</span>+ (<span class="keyword">this</span>.master.isStopped() ? <span class="string">"stopped."</span>: <span class="string">"running."</span>)
    );
  }
</pre></td></tr></table></figure>

<p>重点关注这段代码中的while循环，这段代码不断轮寻RegionServer数目，只有启动起来的RegionServer数目&gt;=hbase.master.wait.on.regionservers.mintostart这个while循环才能退出，不然while循环里面就会一直输出INFO的级别的日志，说没有RegionServer启动好，其实hbase.master.wait.on.regionservers.mintostart的默认值就是1.</p>
<p>至此，Zookeeper，HMaster，HRegionServer都已经启动好了，这里所说的HRegionServer和上面所说的RegionServer指的是同一个东西。接下来我们访问<a href="http://localhost:60010/master-status" target="_blank">http://localhost:60010/master-status</a> 就能看到相关的信息。</p>
<p>这样我们就可以在本地eclipse中debug一下HBase的源代码啦^=^。</p>
<h4 id="三-最后总结">三.最后总结</h4>
<p>我们发现在本地部署HBase，我们需要启动三个东西，Zookeeper,HMaster以及RegionServer。</p>
<p>zookeeper通过HMaster负责协调整个HBase集群，同时zookeeper保存了hbase中-ROOT-表的地址和HMaster的地址。HRegionServer也会把自己以Ephemeral方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的健康状态。</p>
<p>HMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行，HMaster在功能上主要负责Table和Region的管理工作：</p>
<ol>
<li>管理用户对Table的增、删、改、查操作</li>
<li>管理HRegionServer的负载均衡，调整Region分布</li>
<li>在Region Split后，负责新Region的分配</li>
<li>在HRegionServer停机后，负责失效HRegionServer 上的Regions迁移</li>
</ol>
<p>HRegionServer主要负责响应用户I/O请求，向HDFS文件系统中读写数据，是HBase中最核心的模块。<br>HRegionServer内部管理了一系列HRegion对象，每个HRegion对应了Table中的一个Region，HRegion中由多个HStore组成。每个HStore对应了Table中的一个Column Family的存储，可以看出每个Column Family其实就是一个集中的存储单元，因此最好将具备共同IO特性的column放在一个Column Family中，这样最高效。</p>
]]></content>
    <summary type="html"><![CDATA[<h4 id="一-概述">一.概述</h4>
<p>要想把HBase的源代码梳理清楚，需要在本地调试一下，可能直接看代码也能搞清楚，但是调试能让我们尽快搞清楚HBase的源代码，下面就来看一下如何在eclipse中调试HBase的源代码。</p>
]]></summary>
    
      <category term="HBase" scheme="http://yangbolin.cn/tags/HBase/"/>
    
      <category term="大数据" scheme="http://yangbolin.cn/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
